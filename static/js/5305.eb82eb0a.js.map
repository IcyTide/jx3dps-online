{"version":3,"file":"static/js/5305.eb82eb0a.js","mappings":"gkDAaA,IAAMA,EAAe,WA2Bd,SAASC,EACdC,GAEA,IAAKA,IAAWA,EAAOC,OAAQ,OAAO,KACtC,IAAMC,EAAS,CAAC,EAMhB,OALAF,EAAOG,SAAQ,SAAAC,GACb,IAAMC,EAAQD,EAAMC,MACpBH,EAAOG,GAASH,EAAOG,IAAU,GACjCH,EAAOG,GAAOC,KAAKF,EAHrB,IAKOF,CACR,CAEM,SAASK,EACdC,GAEQ,2BADLC,EACK,iCADLA,EACK,KAAAC,UAAAA,GACR,IAAIC,EAAI,EACFC,EAAMH,EAAKR,OACjB,GAAwB,oBAAbO,EACT,OAAOA,EAASK,MAAM,KAAMJ,GAE9B,GAAwB,kBAAbD,EAAuB,CAChC,IAAIM,EAAMN,EAASO,QAAQjB,GAAc,SAAAkB,GACvC,GAAU,OAANA,EACF,MAAO,IAET,GAAIL,GAAKC,EACP,OAAOI,EAET,OAAQA,GACN,IAAK,KACH,OAAOC,OAAOR,EAAKE,MACrB,IAAK,KACH,OAAQO,OAAOT,EAAKE,MACtB,IAAK,KACH,IACE,OAAOQ,KAAKC,UAAUX,EAAKE,KAG5B,CAFC,MAAOU,GACP,MAAO,YACR,CACD,MACF,QACE,OAAOL,EApBH,IAuBV,OAAOF,CACR,CACD,OAAON,CACR,CAaM,SAASc,EAAaC,EAAcC,GACzC,YAAcC,IAAVF,GAAiC,OAAVA,MAGd,UAATC,IAAoBE,MAAMC,QAAQJ,IAAWA,EAAMtB,YAfzD,SAA4BuB,GAC1B,MACW,WAATA,GACS,QAATA,GACS,QAATA,GACS,UAATA,GACS,SAATA,GACS,YAATA,CAEH,CASKI,CAAmBJ,IAA0B,kBAAVD,GAAuBA,GAI/D,CA4BD,SAASM,EACPC,EACAC,EACAC,GAEA,IAAIC,EAAQ,EACNC,EAAYJ,EAAI7B,QAEtB,SAASkC,EAAKnC,GACZ,GAAIA,GAAUA,EAAOC,OACnB+B,EAAShC,OADX,CAIA,IAAMoC,EAAWH,EACjBA,GAAgB,EACZG,EAAWF,EACbH,EAAKD,EAAIM,GAAWD,GAEpBH,EAAS,GANV,CAQF,CAEDG,CAAK,GACN,CAUD,IAAaE,EAAb,Y,QAIE,SACErC,EAAAA,EACAE,GACA,aACAoC,EAAAA,EAAAA,KAAAA,KAAM,2BAAN,MACKtC,OAASA,EACdsC,EAAKpC,OAASA,EAHd,CAID,CAXH,O,EAAAqC,G,EAAAA,G,sEAAA,KAA0CC,QAmBnC,SAASC,EACdC,EACAC,EACAZ,EACAC,EACAY,GAEA,GAAID,EAAOE,MAAO,CAChB,IAAMC,EAAU,IAAIC,SAAgB,SAACC,EAASC,GAC5C,IAMMC,EA1CZ,SAAuBR,GACrB,IAAMS,EAA0B,GAIhC,OAHAC,OAAOC,KAAKX,GAAQvC,SAAQ,SAAAmD,GAC1BH,EAAI7C,KAAJ6C,MAAAA,EAAaT,EAAOY,IAAM,GAD5B,IAGOH,CACR,CAoCwBI,CAAcb,GACjCb,EAAiBqB,EAAYnB,GAPhB,SAAC/B,GAEZ,OADAgC,EAAShC,GACFA,EAAOC,OACVgD,EAAO,IAAIZ,EAAqBrC,EAAQD,EAAmBC,KAC3DgD,EAAQJ,EAJd,GADc,IAWhB,OADAE,EAAO,OAAO,SAAAU,GAAC,OAAIA,CAAnB,IACOV,CACR,CACD,IAAMW,GACmB,IAAvBd,EAAOc,YACHL,OAAOC,KAAKX,GACZC,EAAOc,aAAe,GAEtBC,EAAaN,OAAOC,KAAKX,GACzBiB,EAAeD,EAAWzD,OAC5B2D,EAAQ,EACNC,EAA2B,GAC3Bf,EAAU,IAAIC,SAAgB,SAACC,EAASC,GAC5C,IAAMd,EAAO,SAACnC,GAGZ,GAFA6D,EAAQvD,KAAKO,MAAMgD,EAAS7D,KAC5B4D,IACcD,EAEZ,OADA3B,EAAS6B,GACFA,EAAQ5D,OACXgD,EACE,IAAIZ,EAAqBwB,EAAS9D,EAAmB8D,KAEvDb,EAAQJ,EAThB,EAYKc,EAAWzD,SACd+B,EAAS6B,GACTb,EAAQJ,IAEVc,EAAWvD,SAAQ,SAAA2D,GACjB,IAAMhC,EAAMY,EAAOoB,IACe,IAA9BL,EAAYM,QAAQD,GACtBjC,EAAiBC,EAAKC,EAAMI,GA5HpC,SACEL,EACAC,EACAC,GAEA,IAAM6B,EAA2B,GAC7BD,EAAQ,EACN1B,EAAYJ,EAAI7B,OAEtB,SAAS+D,EAAMhE,GACb6D,EAAQvD,KAARuD,MAAAA,EAAiB7D,GAAU,MAC3B4D,IACc1B,GACZF,EAAS6B,EAEZ,CAED/B,EAAI3B,SAAQ,SAAA8D,GACVlC,EAAKkC,EAAGD,EADV,GAGD,CA0GOE,CAAmBpC,EAAKC,EAAMI,EALlC,GAjBc,IA2BhB,OADAW,EAAO,OAAO,SAAAU,GAAC,OAAIA,CAAnB,IACOV,CACR,CAmBM,SAASqB,EAAgBC,EAAwBxB,GACtD,OAAO,SAACyB,GACN,IAAIC,EAlBNC,EAwBE,OAJED,EADEF,EAAKI,WAdb,SAAkBjD,EAAekD,GAE/B,IADA,IAAIC,EAAInD,EACCZ,EAAI,EAAGA,EAAI8D,EAAKxE,OAAQU,IAAK,CACpC,QAASc,GAALiD,EACF,OAAOA,EAETA,EAAIA,EAAED,EAAK9D,GACZ,CACD,OAAO+D,CACR,CAMkBC,CAAS/B,EAAQwB,EAAKI,YAEtB5B,EAAQyB,EAAWhE,OAAS+D,EAAKQ,YAtBlDL,EAwBiBF,SAtBmC5C,IAAlC8C,EAAsBM,SAuBpCR,EAAGhE,MAAQgE,EAAGhE,OAAS+D,EAAKQ,UAC5BP,EAAGC,WAAaA,EACTD,GAEF,CACLQ,QAAuB,oBAAPR,EAAoBA,IAAOA,EAC3CC,WAAAA,EACAjE,MAASgE,EAAiChE,OAAS+D,EAAKQ,UAf5D,CAkBD,CAEM,SAASE,EAA4BC,EAAWnC,GACrD,GAAIA,EACF,IAAK,IAAMoC,KAAKpC,EACd,GAAIA,EAAOqC,eAAeD,GAAI,CAC5B,IAAMzD,EAAQqB,EAAOoC,GACA,kBAAVzD,GAA2C,kBAAdwD,EAAOC,GAC7CD,EAAOC,GAAPD,EAAAA,CAAAA,EACKA,EAAOC,GACPzD,GAGLwD,EAAOC,GAAKzD,CAEf,CAGL,OAAOwD,CACR,CCjTD,ICFIG,EDEEC,EAAwB,SAACf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAAS5D,IAEjE4C,EAAKe,UACHvC,EAAOqC,eAAeb,EAAK/D,SAC3BiB,EAAaC,EAAOC,GAAQ4C,EAAK5C,OAEnCxB,EAAOM,KAAKC,EAAO6E,EAAQC,SAASF,SAAUf,EAAKQ,WANvD,EEGMU,EAEG,uOAFHA,EAOC,iCAGDC,EAAQ,CACZC,QADY,SACJjE,GACN,OAAOgE,EAAME,OAAOlE,IAAUmE,SAASnE,EAAO,MAAQA,CAF5C,iBAINA,GACJ,OAAOgE,EAAME,OAAOlE,KAAWgE,EAAMC,QAAQjE,EALnC,EAOZoE,MAPY,SAONpE,GACJ,OAAOG,MAAMC,QAAQJ,EARX,EAUZqE,OAVY,SAULrE,GACL,GAAIA,aAAiBsE,OACnB,OAAO,EAET,IACE,QAAS,IAAIA,OAAOtE,EAGrB,CAFC,MAAOiC,GACP,OAAO,CACR,CAlBS,EAoBZsC,KApBY,SAoBPvE,GACH,MAC2B,oBAAlBA,EAAMwE,SACa,oBAAnBxE,EAAMyE,UACY,oBAAlBzE,EAAM0E,UACZC,MAAM3E,EAAMwE,UAzBL,EA4BZN,OA5BY,SA4BLlE,GACL,OAAI2E,MAAM3E,IAGc,kBAAVA,CAhCJ,EAkCZ4E,OAlCY,SAkCL5E,GACL,MAAwB,kBAAVA,IAAuBgE,EAAMI,MAAMpE,EAnCvC,EAqCZ6E,OArCY,SAqCL7E,GACL,MAAwB,oBAAVA,CAtCJ,EAwCZ8E,MAxCY,SAwCN9E,GACJ,MACmB,kBAAVA,GACPA,EAAMtB,QAAU,OACdsB,EAAM+E,MAAMhB,EA5CN,EA+CZiB,IA/CY,SA+CRhF,GACF,MACmB,kBAAVA,GACPA,EAAMtB,QAAU,QACdsB,EAAM+E,MDhEC,WACb,GAAIpB,EACF,OAAOA,EAGT,IAAMsB,EAAO,eACPC,EAAI,SAAArB,GAAO,OACfA,GAAWA,EAAQsB,kBAAnBtB,mBACuBoB,EADvB,SACoCA,EADpC,cAEI,EAHN,EAKMG,EACJ,iGAEIC,EAAQ,mBACRC,GAEHD,aAAAA,EAFQ,WAEQA,EAFR,mFAGRA,EAHQ,WAGQD,EAAOC,KAAAA,EACvBA,kHAAAA,EAJQ,YAISD,EAJT,QAImBC,EAJnB,8GAKRA,EALQ,eAKYA,EALZ,UAK2BD,EAAUC,QAAAA,EAC7CA,4FAAAA,EANQ,eAMYA,EANZ,UAM2BD,EAN3B,QAMqCC,EAC7CA,4FAAAA,EAAoBA,eAAAA,EAAeD,UAAAA,EAAUC,QAAAA,EAPrC,4FAQRA,EARQ,eAQYA,EARZ,UAQ2BD,EAAUC,QAAAA,EACrCA,oGAAAA,EATA,UASeD,EATf,QASyBC,EATzB,sLAYR7F,QAAQ,eAAgB,IACxBA,QAAQ,MAAO,IACf+F,OAGGC,EAAW,IAAIlB,OAAJ,OAAkBc,EAAlB,UAA8BE,EAA/C,MACMG,EAAU,IAAInB,OAAJ,IAAec,EAA/B,KACMM,EAAU,IAAIpB,OAAJ,IAAegB,EAA/B,KAEMK,EAAK,SAAA9B,GAAO,OAChBA,GAAWA,EAAQ+B,MACfJ,EACA,IAAIlB,OAAJ,MACQY,EAAErB,GAAWuB,EAAKF,EAAErB,GAD5B,QAC4CqB,EAAErB,GAAWyB,EAAKJ,EAC1DrB,GAFJ,IAIE,IAPR,EAUA8B,EAAGP,GAAK,SAACvB,GAAD,OACNA,GAAWA,EAAQ+B,MACfH,EACA,IAAInB,OAAUY,GAAAA,EAAErB,GAAWuB,EAAKF,EAAErB,GAAY,IAHpD,EAIA8B,EAAGL,GAAK,SAACzB,GAAD,OACNA,GAAWA,EAAQ+B,MACfF,EACA,IAAIpB,OAAUY,GAAAA,EAAErB,GAAWyB,EAAKJ,EAAErB,GAAY,IAHpD,EAKA,IAEMgC,EAAOF,EAAGP,KAAK/D,OACfyE,EAAOH,EAAGL,KAAKjE,OASrB,OADAsC,EAAS,IAAIW,OAAJ,qEADkDuB,EAAQC,IAAAA,EAC1D,qMAA6B,IAlExC,CCgEoBC,GAnDN,EAsDZC,IAtDY,SAsDRhG,GACF,MAAwB,kBAAVA,KAAwBA,EAAM+E,MAAMhB,EACnD,GCjEH,EAAe,CACbH,SAAAA,EACAqC,WCK8B,SAACpD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,IACxD,QAAQqC,KAAKlG,IAAoB,KAAVA,IACzBvB,EAAOM,KAAKC,EAAO6E,EAAQC,SAASmC,WAAYpD,EAAKQ,WAFzD,EDJEpD,KDiEwB,SAAC4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACtD,GAAIhB,EAAKe,eAAsB1D,IAAVF,EACnB4D,EAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,OADxC,CAIA,IAaMsC,EAAWtD,EAAK5C,KAbP,CACb,UACA,QACA,QACA,SACA,SACA,SACA,QACA,SACA,OACA,MACA,OAGSuC,QAAQ2D,IAAa,EACzBnC,EAAMmC,GAAUnG,IACnBvB,EAAOM,KACLC,EAAO6E,EAAQC,SAASE,MAAMmC,GAAWtD,EAAKQ,UAAWR,EAAK5C,OAIzDkG,UAAmBnG,IAAU6C,EAAK5C,MAC3CxB,EAAOM,KACLC,EAAO6E,EAAQC,SAASE,MAAMmC,GAAWtD,EAAKQ,UAAWR,EAAK5C,MAxBjE,CAJH,EChEEmG,MERyB,SAACvD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACvD,IAAMxE,EAA0B,kBAAbwD,EAAKxD,IAClBgH,EAA0B,kBAAbxD,EAAKwD,IAClBC,EAA0B,kBAAbzD,EAAKyD,IAGpBC,EAAMvG,EACNuC,EAAM,KACJiE,EAAuB,kBAAVxG,EACbT,EAAuB,kBAAVS,EACbO,EAAMJ,MAAMC,QAAQJ,GAW1B,GAVIwG,EACFjE,EAAM,SACGhD,EACTgD,EAAM,SACGhC,IACTgC,EAAM,UAKHA,EACH,OAAO,EAELhC,IACFgG,EAAMvG,EAAMtB,QAEVa,IAEFgH,EAAMvG,EAAMR,QAxBG,kCAwBe,KAAKd,QAEjCW,EACEkH,IAAQ1D,EAAKxD,KACfZ,EAAOM,KAAKC,EAAO6E,EAAQC,SAASvB,GAAKlD,IAAKwD,EAAKQ,UAAWR,EAAKxD,MAE5DgH,IAAQC,GAAOC,EAAM1D,EAAKwD,IACnC5H,EAAOM,KAAKC,EAAO6E,EAAQC,SAASvB,GAAK8D,IAAKxD,EAAKQ,UAAWR,EAAKwD,MAC1DC,IAAQD,GAAOE,EAAM1D,EAAKyD,IACnC7H,EAAOM,KAAKC,EAAO6E,EAAQC,SAASvB,GAAK+D,IAAKzD,EAAKQ,UAAWR,EAAKyD,MAC1DD,GAAOC,IAAQC,EAAM1D,EAAKwD,KAAOE,EAAM1D,EAAKyD,MACrD7H,EAAOM,KACLC,EAAO6E,EAAQC,SAASvB,GAAK6D,MAAOvD,EAAKQ,UAAWR,EAAKwD,IAAKxD,EAAKyD,KAzCzE,EFSEG,KGP8B,SAAC5D,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GAC5DhB,EAAI,KAAS1C,MAAMC,QAAQyC,EAAI,MAAUA,EAAI,KAAS,IACnB,IAA/BA,EAAI,KAAOL,QAAQxC,IACrBvB,EAAOM,KACLC,EAAO6E,EAAQC,SAARD,KAAwBhB,EAAKQ,UAAWR,EAAI,KAAO6D,KAAK,OAJrE,EHQE3C,QIV2B,SAAClB,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACzD,GAAIhB,EAAKkB,QACP,GAAIlB,EAAKkB,mBAAmBO,OAI1BzB,EAAKkB,QAAQ4C,UAAY,EACpB9D,EAAKkB,QAAQmC,KAAKlG,IACrBvB,EAAOM,KACLC,EACE6E,EAAQC,SAASC,QAAQ6C,SACzB/D,EAAKQ,UACLrD,EACA6C,EAAKkB,eAIN,GAA4B,kBAAjBlB,EAAKkB,QAAsB,CAC1B,IAAIO,OAAOzB,EAAKkB,SACnBmC,KAAKlG,IACjBvB,EAAOM,KACLC,EACE6E,EAAQC,SAASC,QAAQ6C,SACzB/D,EAAKQ,UACLrD,EACA6C,EAAKkB,SAIZ,CA7BL,GCCM9D,EAAyB,SAAC4C,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC7D,IAAMsC,EAAWtD,EAAK5C,KAChBxB,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,EAAOmG,KAActD,EAAKe,SACzC,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAASsC,GAChDpG,EAAaC,EAAOmG,IACvBU,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE3C,CACDpD,EAAShC,EAdX,ECYA,EAAe,CACbqI,OCb+B,SAACjE,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC/D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,EAAO,YAAc6C,EAAKe,SACzC,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAAS,UAChD9D,EAAaC,EAAO,YACvB6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACxCgD,EAAMT,MAAMvD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACzCgD,EAAM9C,QAAQlB,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,IACnB,IAApBhB,EAAKoD,YACPY,EAAMZ,WAAWpD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GAGnD,CACDpD,EAAShC,EAlBX,EDcEoG,OEd+B,SAAChC,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC/D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,GACF6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE3C,CACDpD,EAAShC,EAbX,EFeEyF,OGf+B,SAACrB,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC/D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CAIZ,GAHc,KAAVkB,IACFA,OAAQE,GAENH,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,IACF6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACxCgD,EAAMT,MAAMvD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GAE5C,CACDpD,EAAShC,EAjBX,EHgBEsI,QIhBgC,SAAClE,EAAM7C,EAAOS,EAAUY,EAAQwC,GAChE,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,GACF6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE3C,CACDpD,EAAShC,EAbX,EJiBE4F,OKjB+B,SAACxB,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC/D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACvC9D,EAAaC,IAChB6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE3C,CACDpD,EAAShC,EAbX,ELkBEwF,QMlBgC,SAACpB,EAAM7C,EAAOS,EAAUY,EAAQwC,GAChE,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,IACF6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACxCgD,EAAMT,MAAMvD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GAE5C,CACDpD,EAAShC,EAdX,ENmBEuI,MOnBgC,SAACnE,EAAM7C,EAAOS,EAAUY,EAAQwC,GAChE,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,IACF6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACxCgD,EAAMT,MAAMvD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GAE5C,CACDpD,EAAShC,EAdX,EPoBE2F,MQrB8B,SAACvB,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC9D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,SAAeoB,IAAVF,GAAiC,OAAVA,KAAoB6C,EAAKe,SACnD,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAAS,cACvC3D,IAAVF,GAAiC,OAAVA,IACzB6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACxCgD,EAAMT,MAAMvD,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GAE5C,CACDpD,EAAShC,EAdX,ERsBEmG,OSrB+B,SAAC/B,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC/D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,GACF6G,EAAM5G,KAAK4C,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE3C,CACDpD,EAAShC,EAbX,ETsBEgI,KUpBmC,SACnC5D,EACA7C,EACAS,EACAY,EACAwC,GAEA,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,QAC9B3D,IAAVF,GACF6G,EAAK,KAAOhE,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE5C,CACDpD,EAAShC,EAnBX,EVqBEsF,QWvBgC,SAAClB,EAAM7C,EAAOS,EAAUY,EAAQwC,GAChE,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,EAAO,YAAc6C,EAAKe,SACzC,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,GACvC9D,EAAaC,EAAO,WACvB6G,EAAM9C,QAAQlB,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAE9C,CACDpD,EAAShC,EAbX,EXwBE8F,KYxB6B,SAAC1B,EAAM7C,EAAOS,EAAUY,EAAQwC,GAE7D,IAAMpF,EAAmB,GAIzB,GAFEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OAEnD,CACZ,GAAIiB,EAAaC,EAAO,UAAY6C,EAAKe,SACvC,OAAOnD,IAIP,IAAIwG,EADN,GADAJ,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,IACvC9D,EAAaC,EAAO,QAIrBiH,EADEjH,aAAiBkH,KACNlH,EAEA,IAAIkH,KAAKlH,GAGxB6G,EAAM5G,KAAK4C,EAAMoE,EAAY5F,EAAQ5C,EAAQoF,GACzCoD,GACFJ,EAAMT,MAAMvD,EAAMoE,EAAWzC,UAAWnD,EAAQ5C,EAAQoF,EAG7D,CACDpD,EAAShC,EA1BX,EZyBEuG,IAAK/E,EACL+F,IAAK/F,EACL6E,MAAO7E,EACP2D,Sa7BiC,SAACf,EAAM7C,EAAOS,EAAUY,EAAQwC,GACjE,IAAMpF,EAAmB,GACnBwB,EAAOE,MAAMC,QAAQJ,GAAS,eAAiBA,EACrD6G,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAAS5D,GACrDQ,EAAShC,EAJX,Eb8BE0I,Ic7B4B,SAACtE,EAAM7C,EAAOS,EAAUY,EAAQwC,GAC5D,IAAMpF,EAAmB,GAGzB,GADEoE,EAAKe,WAAcf,EAAKe,UAAYvC,EAAOqC,eAAeb,EAAK/D,OACnD,CACZ,GAAIiB,EAAaC,KAAW6C,EAAKe,SAC/B,OAAOnD,IAEToG,EAAMjD,SAASf,EAAM7C,EAAOqB,EAAQ5C,EAAQoF,EAC7C,CACDpD,EAAShC,EAVX,GCFO,SAAS2I,IACd,MAAO,CACLC,QAAS,+BACTzD,SAAU,iBACV6C,KAAM,uBACNR,WAAY,qBACZ1B,KAAM,CACJvF,OAAQ,sCACRsI,MAAO,8CACPC,QAAS,yBAEXvD,MAAO,CACL8C,OAAQ,iBACRjC,OAAQ,4BACRT,MAAO,kBACPQ,OAAQ,kBACRV,OAAQ,iBACRK,KAAM,iBACNwC,QAAS,iBACT9C,QAAS,kBACT+C,MAAO,iBACP3C,OAAQ,uBACRS,MAAO,uBACPE,IAAK,uBACLgB,IAAK,wBAEPc,OAAQ,CACNzH,IAAK,mCACLgH,IAAK,oCACLC,IAAK,yCACLF,MAAO,2CAETlC,OAAQ,CACN7E,IAAK,mBACLgH,IAAK,4BACLC,IAAK,+BACLF,MAAO,gCAEThC,MAAO,CACL/E,IAAK,kCACLgH,IAAK,sCACLC,IAAK,yCACLF,MAAO,0CAETrC,QAAS,CACP6C,SAAU,yCAEZY,MAAQ,WACN,IAAMC,EAAS7H,KAAK0H,MAAM1H,KAAKC,UAAU6H,OAEzC,OADAD,EAAOD,MAAQE,KAAKF,MACbC,CACR,EAEJ,CAEM,IAAM3D,EAAWsD,ICtBlBO,EAAAA,WAqBJ,WAAYC,GAAmB,KAH/Bf,MAAoC,KAGL,KAF/BgB,UAAsCC,EAGpCJ,KAAKK,OAAOH,EACb,C,2BAEDG,OAAAA,SAAOlB,GAAc,WACnB,IAAKA,EACH,MAAM,IAAI5F,MAAM,2CAElB,GAAqB,kBAAV4F,GAAsB1G,MAAMC,QAAQyG,GAC7C,MAAM,IAAI5F,MAAM,2BAElByG,KAAKb,MAAQ,CAAC,EAEdhF,OAAOC,KAAK+E,GAAOjI,SAAQ,SAAAoJ,GACzB,IAAMC,EAAapB,EAAMmB,GACzBjH,EAAK8F,MAAMmB,GAAQ7H,MAAMC,QAAQ6H,GAAQA,EAAO,CAACA,EAFnD,G,IAMFnE,SAAAA,SAASA,GAIP,OAHIA,IACF4D,KAAKG,UAAYtE,EAAU6D,IAAetD,IAErC4D,KAAKG,S,EAWdK,EAAAA,SAAAA,SAASC,EAAiBC,EAAaC,GAAqC,oBAAlDD,IAAAA,EAAS,CAAC,QAAwC,IAArCC,IAAAA,EAAU,WAA2B,GAC1E,IAAIhH,EAAiB8G,EACjBtE,EAA0BuE,EAC1B3H,EAA6B4H,EAKjC,GAJuB,oBAAZxE,IACTpD,EAAWoD,EACXA,EAAU,CAAC,IAER6D,KAAKb,OAA4C,IAAnChF,OAAOC,KAAK4F,KAAKb,OAAOnI,OAIzC,OAHI+B,GACFA,EAAS,KAAMY,GAEVG,QAAQC,QAAQJ,GA6BzB,GAAIwC,EAAQC,SAAU,CACpB,IAAIA,EAAW4D,KAAK5D,WAChBA,IAAagE,IACfhE,EAAWsD,KAEb7D,EAAUO,EAAUD,EAAQC,UAC5BD,EAAQC,SAAWA,CANrB,MAQED,EAAQC,SAAW4D,KAAK5D,WAG1B,IAAMwE,EAA6C,CAAC,GACvCzE,EAAQ/B,MAAQD,OAAOC,KAAK4F,KAAKb,QACzCjI,SAAQ,SAAA2J,GACX,IAAMhI,EAAMiI,EAAK3B,MAAM0B,GACnBvI,EAAQqB,EAAOkH,GACnBhI,EAAI3B,SAAQ,SAAA6J,GACV,IAAI5F,EAAyB4F,EACC,oBAAnB5F,EAAK6F,YACVrH,IAAW8G,IACb9G,EAAS,EAAH,GAAQA,IAEhBrB,EAAQqB,EAAOkH,GAAK1F,EAAK6F,UAAU1I,KAGnC6C,EADkB,oBAATA,EACF,CACL8F,UAAW9F,GAGN,EAAH,GAAQA,IAIT8F,UAAYH,EAAKI,oBAAoB/F,GACrCA,EAAK8F,YAIV9F,EAAK/D,MAAQyJ,EACb1F,EAAKQ,UAAYR,EAAKQ,WAAakF,EACnC1F,EAAK5C,KAAOuI,EAAKK,QAAQhG,GACzByF,EAAOC,GAAKD,EAAOC,IAAM,GACzBD,EAAOC,GAAGxJ,KAAK,CACb8D,KAAAA,EACA7C,MAAAA,EACAqB,OAAAA,EACAvC,MAAOyJ,IA9BX,GAHF,IAqCA,IAAMO,EAAc,CAAC,EACrB,OAAO5H,EACLoH,EACAzE,GACA,SAACkF,EAAMC,GACL,IA+FIC,EA/FEpG,EAAOkG,EAAKlG,KACdqG,GACa,WAAdrG,EAAK5C,MAAmC,UAAd4C,EAAK5C,QACR,kBAAhB4C,EAAKlE,QACkB,kBAAtBkE,EAAKsG,cAIhB,SAASC,EAAa7G,EAAa8G,GACjC,OAAO,EAAP,GACKA,EADL,CAEEhG,UAAcR,EAAKQ,UAAV,IAAuBd,EAChCU,WAAYJ,EAAKI,WAAiBJ,GAAAA,OAAAA,EAAKI,WAAYV,CAAAA,IAAO,CAACA,IAE9D,CAED,SAAS+G,EAAGrH,QAAyC,IAAzCA,IAAAA,EAAqC,IAC/C,IAAIsH,EAAYpJ,MAAMC,QAAQ6B,GAAKA,EAAI,CAACA,IACnC4B,EAAQ2F,iBAAmBD,EAAU7K,QACxCiJ,EAAO8B,QAAQ,mBAAoBF,GAEjCA,EAAU7K,aAA2BwB,IAAjB2C,EAAKS,UAC3BiG,EAAY,GAAGG,OAAO7G,EAAKS,UAI7B,IAAIqG,EAAeJ,EAAUK,IAAIhH,EAAgBC,EAAMxB,IAEvD,GAAIwC,EAAQvC,OAASqI,EAAajL,OAEhC,OADAoK,EAAYjG,EAAK/D,OAAS,EACnBkK,EAAKW,GAEd,GAAKT,EAEE,CAIL,GAAIrG,EAAKe,WAAamF,EAAK/I,MAazB,YAZqBE,IAAjB2C,EAAKS,QACPqG,EAAe,GACZD,OAAO7G,EAAKS,SACZsG,IAAIhH,EAAgBC,EAAMxB,IACpBwC,EAAQhF,QACjB8K,EAAe,CACb9F,EAAQhF,MACNgE,EACA7D,EAAO6E,EAAQC,SAASF,SAAUf,EAAK/D,UAItCkK,EAAKW,GAGd,IAAIE,EAAqC,CAAC,EACtChH,EAAKsG,cACPtH,OAAOC,KAAKiH,EAAK/I,OAAO4J,KAAI,SAAArH,GAC1BsH,EAAatH,GAAOM,EAAKsG,YAD3B,IAIFU,EAAe,EAAH,GACPA,EACAd,EAAKlG,KAAKlE,QAGf,IAAMmL,EAAgD,CAAC,EAEvDjI,OAAOC,KAAK+H,GAAcjL,SAAQ,SAAAE,GAChC,IAAMiL,EAAcF,EAAa/K,GAC3BkL,EAAkB7J,MAAMC,QAAQ2J,GAClCA,EACA,CAACA,GACLD,EAAkBhL,GAASkL,EAAgBJ,IACzCR,EAAaa,KAAK,KAAMnL,GAN5B,IASA,IAAMuK,EAAS,IAAI1B,EAAOmC,GAC1BT,EAAOvF,SAASD,EAAQC,UACpBiF,EAAKlG,KAAKgB,UACZkF,EAAKlG,KAAKgB,QAAQC,SAAWD,EAAQC,SACrCiF,EAAKlG,KAAKgB,QAAQhF,MAAQgF,EAAQhF,OAEpCwK,EAAOnB,SAASa,EAAK/I,MAAO+I,EAAKlG,KAAKgB,SAAWA,GAAS,SAAAqG,GACxD,IAAMC,EAAc,GAChBR,GAAgBA,EAAajL,QAC/ByL,EAAYpL,KAAZoL,MAAAA,EAAoBR,GAElBO,GAAQA,EAAKxL,QACfyL,EAAYpL,KAAZoL,MAAAA,EAAoBD,GAEtBlB,EAAKmB,EAAYzL,OAASyL,EAAc,KAR1C,GAUD,MA3DCnB,EAAKW,EA4DR,CAGD,GA3FAT,EAAOA,IAASrG,EAAKe,WAAcf,EAAKe,UAAYmF,EAAK/I,OACzD6C,EAAK/D,MAAQiK,EAAKjK,MA0Fd+D,EAAKuH,eACPnB,EAAMpG,EAAKuH,eAAevH,EAAMkG,EAAK/I,MAAOsJ,EAAIP,EAAK1H,OAAQwC,QACxD,GAAIhB,EAAK8F,UAAW,CACzB,IACEM,EAAMpG,EAAK8F,UAAU9F,EAAMkG,EAAK/I,MAAOsJ,EAAIP,EAAK1H,OAAQwC,EAUzD,CATC,MAAOhF,GACPwL,MAAAA,QAAQxL,OAARwL,QAAQxL,MAAQA,GAEXgF,EAAQyG,wBACXC,YAAW,WACT,MAAM1L,CADE,GAEP,GAELyK,EAAGzK,EAAMyE,QACV,EACW,IAAR2F,EACFK,KACiB,IAARL,EACTK,EAC0B,oBAAjBzG,EAAKS,QACRT,EAAKS,QAAQT,EAAKQ,WAAaR,EAAK/D,OACpC+D,EAAKS,UAAcT,EAAKQ,WAAaR,EAAK/D,OAA1C,UAEGmK,aAAe9I,MACxBmJ,EAAGL,GACMA,aAAehI,OACxBqI,EAAGL,EAAI3F,QAEV,CACG2F,GAAQA,EAAsBuB,MAC/BvB,EAAsBuB,MACrB,kBAAMlB,GADR,IAEE,SAAArH,GAAC,OAAIqH,EAAGrH,EAFV,GAlIS,IAwIb,SAAAK,IArNF,SAAkBA,GAChB,IAAI7D,EAA0B,GAC1BE,EAA8B,CAAC,EAEnC,SAAS8L,EAAIxI,GACW,MAAlB9B,MAAMC,QAAQ6B,GAChBxD,GAAS,EAAAA,GAAOiL,OAAP,QAAiBzH,GAE1BxD,EAAOM,KAAKkD,EAEf,CAED,IAAK,IAAI7C,EAAI,EAAGA,EAAIkD,EAAQ5D,OAAQU,IAClCqL,EAAInI,EAAQlD,IAETX,EAAOC,QAGVC,EAASH,EAAmBC,GAC3BgC,EAGUhC,EAAQE,IANnB8B,EAAS,KAAMY,EAQlB,CA8LGqJ,CAASpI,EAzIE,GA2IbjB,E,IAIJwH,QAAAA,SAAQhG,GAIN,QAHkB3C,IAAd2C,EAAK5C,MAAsB4C,EAAKkB,mBAAmBO,SACrDzB,EAAK5C,KAAO,WAGc,oBAAnB4C,EAAK8F,WACZ9F,EAAK5C,OACJ0K,EAAWjH,eAAeb,EAAK5C,MAEhC,MAAM,IAAIgB,MAAMjC,EAAO,uBAAwB6D,EAAK5C,OAEtD,OAAO4C,EAAK5C,MAAQ,Q,IAGtB2I,oBAAAA,SAAoB/F,GAClB,GAA8B,oBAAnBA,EAAK8F,UACd,OAAO9F,EAAK8F,UAEd,IAAM7G,EAAOD,OAAOC,KAAKe,GACnB+H,EAAe9I,EAAKU,QAAQ,WAIlC,OAHsB,IAAlBoI,GACF9I,EAAK+I,OAAOD,EAAc,GAER,IAAhB9I,EAAKpD,QAA4B,aAAZoD,EAAK,GACrB6I,EAAW/G,SAEb+G,EAAWjD,KAAKmB,QAAQhG,UAAU3C,C,IA5TvCyH,GAAAA,EAEGmD,SAAW,SAAkB7K,EAAc0I,GAChD,GAAyB,oBAAdA,EACT,MAAM,IAAI1H,MACR,oEAGJ0J,EAAW1K,GAAQ0I,CACpB,EATGhB,EAWG8B,Q1B7B6D,WAA/D,E0BkBD9B,EAaG7D,SAAWgE,EAbdH,EAeGgD,WAAaA,C","sources":["../node_modules/src/util.ts","../node_modules/src/rule/required.ts","../node_modules/src/rule/url.ts","../node_modules/src/rule/type.ts","../node_modules/src/rule/index.ts","../node_modules/src/rule/whitespace.ts","../node_modules/src/rule/range.ts","../node_modules/src/rule/enum.ts","../node_modules/src/rule/pattern.ts","../node_modules/src/validator/type.ts","../node_modules/src/validator/index.ts","../node_modules/src/validator/string.ts","../node_modules/src/validator/method.ts","../node_modules/src/validator/number.ts","../node_modules/src/validator/boolean.ts","../node_modules/src/validator/regexp.ts","../node_modules/src/validator/integer.ts","../node_modules/src/validator/float.ts","../node_modules/src/validator/array.ts","../node_modules/src/validator/object.ts","../node_modules/src/validator/enum.ts","../node_modules/src/validator/pattern.ts","../node_modules/src/validator/date.ts","../node_modules/src/validator/required.ts","../node_modules/src/validator/any.ts","../node_modules/src/messages.ts","../node_modules/src/index.ts"],"sourcesContent":["/* eslint no-console:0 */\n\nimport {\n  ValidateError,\n  ValidateOption,\n  RuleValuePackage,\n  InternalRuleItem,\n  SyncErrorType,\n  RuleType,\n  Value,\n  Values,\n} from './interface';\n\nconst formatRegExp = /%[sdj%]/g;\n\ndeclare var ASYNC_VALIDATOR_NO_WARNING;\n\nexport let warning: (type: string, errors: SyncErrorType[]) => void = () => {};\n\n// don't print warning message when in production env or node runtime\nif (\n  typeof process !== 'undefined' &&\n  process.env &&\n  process.env.NODE_ENV !== 'production' &&\n  typeof window !== 'undefined' &&\n  typeof document !== 'undefined'\n) {\n  warning = (type, errors) => {\n    if (\n      typeof console !== 'undefined' &&\n      console.warn &&\n      typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined'\n    ) {\n      if (errors.every(e => typeof e === 'string')) {\n        console.warn(type, errors);\n      }\n    }\n  };\n}\n\nexport function convertFieldsError(\n  errors: ValidateError[],\n): Record<string, ValidateError[]> {\n  if (!errors || !errors.length) return null;\n  const fields = {};\n  errors.forEach(error => {\n    const field = error.field;\n    fields[field] = fields[field] || [];\n    fields[field].push(error);\n  });\n  return fields;\n}\n\nexport function format(\n  template: ((...args: any[]) => string) | string,\n  ...args: any[]\n): string {\n  let i = 0;\n  const len = args.length;\n  if (typeof template === 'function') {\n    return template.apply(null, args);\n  }\n  if (typeof template === 'string') {\n    let str = template.replace(formatRegExp, x => {\n      if (x === '%%') {\n        return '%';\n      }\n      if (i >= len) {\n        return x;\n      }\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n        case '%d':\n          return (Number(args[i++]) as unknown) as string;\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n          break;\n        default:\n          return x;\n      }\n    });\n    return str;\n  }\n  return template;\n}\n\nfunction isNativeStringType(type: string) {\n  return (\n    type === 'string' ||\n    type === 'url' ||\n    type === 'hex' ||\n    type === 'email' ||\n    type === 'date' ||\n    type === 'pattern'\n  );\n}\n\nexport function isEmptyValue(value: Value, type?: string) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  if (type === 'array' && Array.isArray(value) && !value.length) {\n    return true;\n  }\n  if (isNativeStringType(type) && typeof value === 'string' && !value) {\n    return true;\n  }\n  return false;\n}\n\nexport function isEmptyObject(obj: object) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction asyncParallelArray(\n  arr: RuleValuePackage[],\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n) {\n  const results: ValidateError[] = [];\n  let total = 0;\n  const arrLength = arr.length;\n\n  function count(errors: ValidateError[]) {\n    results.push(...(errors || []));\n    total++;\n    if (total === arrLength) {\n      callback(results);\n    }\n  }\n\n  arr.forEach(a => {\n    func(a, count);\n  });\n}\n\nfunction asyncSerialArray(\n  arr: RuleValuePackage[],\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n) {\n  let index = 0;\n  const arrLength = arr.length;\n\n  function next(errors: ValidateError[]) {\n    if (errors && errors.length) {\n      callback(errors);\n      return;\n    }\n    const original = index;\n    index = index + 1;\n    if (original < arrLength) {\n      func(arr[original], next);\n    } else {\n      callback([]);\n    }\n  }\n\n  next([]);\n}\n\nfunction flattenObjArr(objArr: Record<string, RuleValuePackage[]>) {\n  const ret: RuleValuePackage[] = [];\n  Object.keys(objArr).forEach(k => {\n    ret.push(...(objArr[k] || []));\n  });\n  return ret;\n}\n\nexport class AsyncValidationError extends Error {\n  errors: ValidateError[];\n  fields: Record<string, ValidateError[]>;\n\n  constructor(\n    errors: ValidateError[],\n    fields: Record<string, ValidateError[]>,\n  ) {\n    super('Async Validation Error');\n    this.errors = errors;\n    this.fields = fields;\n  }\n}\n\ntype ValidateFunc = (\n  data: RuleValuePackage,\n  doIt: (errors: ValidateError[]) => void,\n) => void;\n\nexport function asyncMap(\n  objArr: Record<string, RuleValuePackage[]>,\n  option: ValidateOption,\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n  source: Values,\n): Promise<Values> {\n  if (option.first) {\n    const pending = new Promise<Values>((resolve, reject) => {\n      const next = (errors: ValidateError[]) => {\n        callback(errors);\n        return errors.length\n          ? reject(new AsyncValidationError(errors, convertFieldsError(errors)))\n          : resolve(source);\n      };\n      const flattenArr = flattenObjArr(objArr);\n      asyncSerialArray(flattenArr, func, next);\n    });\n    pending.catch(e => e);\n    return pending;\n  }\n  const firstFields =\n    option.firstFields === true\n      ? Object.keys(objArr)\n      : option.firstFields || [];\n\n  const objArrKeys = Object.keys(objArr);\n  const objArrLength = objArrKeys.length;\n  let total = 0;\n  const results: ValidateError[] = [];\n  const pending = new Promise<Values>((resolve, reject) => {\n    const next = (errors: ValidateError[]) => {\n      results.push.apply(results, errors);\n      total++;\n      if (total === objArrLength) {\n        callback(results);\n        return results.length\n          ? reject(\n              new AsyncValidationError(results, convertFieldsError(results)),\n            )\n          : resolve(source);\n      }\n    };\n    if (!objArrKeys.length) {\n      callback(results);\n      resolve(source);\n    }\n    objArrKeys.forEach(key => {\n      const arr = objArr[key];\n      if (firstFields.indexOf(key) !== -1) {\n        asyncSerialArray(arr, func, next);\n      } else {\n        asyncParallelArray(arr, func, next);\n      }\n    });\n  });\n  pending.catch(e => e);\n  return pending;\n}\n\nfunction isErrorObj(\n  obj: ValidateError | string | (() => string),\n): obj is ValidateError {\n  return !!(obj && (obj as ValidateError).message !== undefined);\n}\n\nfunction getValue(value: Values, path: string[]) {\n  let v = value;\n  for (let i = 0; i < path.length; i++) {\n    if (v == undefined) {\n      return v;\n    }\n    v = v[path[i]];\n  }\n  return v;\n}\n\nexport function complementError(rule: InternalRuleItem, source: Values) {\n  return (oe: ValidateError | (() => string) | string): ValidateError => {\n    let fieldValue;\n    if (rule.fullFields) {\n      fieldValue = getValue(source, rule.fullFields);\n    } else {\n      fieldValue = source[(oe as any).field || rule.fullField];\n    }\n    if (isErrorObj(oe)) {\n      oe.field = oe.field || rule.fullField;\n      oe.fieldValue = fieldValue;\n      return oe;\n    }\n    return {\n      message: typeof oe === 'function' ? oe() : oe,\n      fieldValue,\n      field: ((oe as unknown) as ValidateError).field || rule.fullField,\n    };\n  };\n}\n\nexport function deepMerge<T extends object>(target: T, source: Partial<T>): T {\n  if (source) {\n    for (const s in source) {\n      if (source.hasOwnProperty(s)) {\n        const value = source[s];\n        if (typeof value === 'object' && typeof target[s] === 'object') {\n          target[s] = {\n            ...target[s],\n            ...value,\n          };\n        } else {\n          target[s] = value;\n        }\n      }\n    }\n  }\n  return target;\n}\n","import { ExecuteRule } from '../interface';\nimport { format, isEmptyValue } from '../util';\n\nconst required: ExecuteRule = (rule, value, source, errors, options, type) => {\n  if (\n    rule.required &&\n    (!source.hasOwnProperty(rule.field) ||\n      isEmptyValue(value, type || rule.type))\n  ) {\n    errors.push(format(options.messages.required, rule.fullField));\n  }\n};\n\nexport default required;\n","// https://github.com/kevva/url-regex/blob/master/index.js\nlet urlReg: RegExp;\n\nexport default () => {\n  if (urlReg) {\n    return urlReg;\n  }\n\n  const word = '[a-fA-F\\\\d:]';\n  const b = options =>\n    options && options.includeBoundaries\n      ? `(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))`\n      : '';\n\n  const v4 =\n    '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\n  const v6seg = '[a-fA-F\\\\d]{1,4}';\n  const v6 = `\n(?:\n(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`\n    .replace(/\\s*\\/\\/.*$/gm, '')\n    .replace(/\\n/g, '')\n    .trim();\n\n  // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n  const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\n  const v4exact = new RegExp(`^${v4}$`);\n  const v6exact = new RegExp(`^${v6}$`);\n\n  const ip = options =>\n    options && options.exact\n      ? v46Exact\n      : new RegExp(\n          `(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(\n            options,\n          )})`,\n          'g',\n        );\n\n  ip.v4 = (options?) =>\n    options && options.exact\n      ? v4exact\n      : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');\n  ip.v6 = (options?) =>\n    options && options.exact\n      ? v6exact\n      : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');\n\n  const protocol = `(?:(?:[a-z]+:)?//)`;\n  const auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  const ipv4 = ip.v4().source;\n  const ipv6 = ip.v6().source;\n  const host = '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)';\n  const domain =\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*';\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))`;\n  const port = '(?::\\\\d{2,5})?';\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ipv4}|${ipv6}|${host}${domain}${tld})${port}${path}`;\n  urlReg = new RegExp(`(?:^${regex}$)`, 'i');\n  return urlReg;\n};\n","import { ExecuteRule, Value } from '../interface';\nimport { format } from '../util';\nimport required from './required';\nimport getUrlRegex from './url';\n/* eslint max-len:0 */\n\nconst pattern = {\n  // http://emailregex.com/\n  email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n  // url: new RegExp(\n  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n  //   'i',\n  // ),\n  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,\n};\n\nconst types = {\n  integer(value: Value) {\n    return types.number(value) && parseInt(value, 10) === value;\n  },\n  float(value: Value) {\n    return types.number(value) && !types.integer(value);\n  },\n  array(value: Value) {\n    return Array.isArray(value);\n  },\n  regexp(value: Value) {\n    if (value instanceof RegExp) {\n      return true;\n    }\n    try {\n      return !!new RegExp(value);\n    } catch (e) {\n      return false;\n    }\n  },\n  date(value: Value) {\n    return (\n      typeof value.getTime === 'function' &&\n      typeof value.getMonth === 'function' &&\n      typeof value.getYear === 'function' &&\n      !isNaN(value.getTime())\n    );\n  },\n  number(value: Value) {\n    if (isNaN(value)) {\n      return false;\n    }\n    return typeof value === 'number';\n  },\n  object(value: Value) {\n    return typeof value === 'object' && !types.array(value);\n  },\n  method(value: Value) {\n    return typeof value === 'function';\n  },\n  email(value: Value) {\n    return (\n      typeof value === 'string' &&\n      value.length <= 320 &&\n      !!value.match(pattern.email)\n    );\n  },\n  url(value: Value) {\n    return (\n      typeof value === 'string' &&\n      value.length <= 2048 &&\n      !!value.match(getUrlRegex())\n    );\n  },\n  hex(value: Value) {\n    return typeof value === 'string' && !!value.match(pattern.hex);\n  },\n};\n\nconst type: ExecuteRule = (rule, value, source, errors, options) => {\n  if (rule.required && value === undefined) {\n    required(rule, value, source, errors, options);\n    return;\n  }\n  const custom = [\n    'integer',\n    'float',\n    'array',\n    'regexp',\n    'object',\n    'method',\n    'email',\n    'number',\n    'date',\n    'url',\n    'hex',\n  ];\n  const ruleType = rule.type;\n  if (custom.indexOf(ruleType) > -1) {\n    if (!types[ruleType](value)) {\n      errors.push(\n        format(options.messages.types[ruleType], rule.fullField, rule.type),\n      );\n    }\n    // straight typeof check\n  } else if (ruleType && typeof value !== rule.type) {\n    errors.push(\n      format(options.messages.types[ruleType], rule.fullField, rule.type),\n    );\n  }\n};\n\nexport default type;\n","import required from './required';\nimport whitespace from './whitespace';\nimport type from './type';\nimport range from './range';\nimport enumRule from './enum';\nimport pattern from './pattern';\n\nexport default {\n  required,\n  whitespace,\n  type,\n  range,\n  enum: enumRule,\n  pattern,\n};\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\nconst whitespace: ExecuteRule = (rule, value, source, errors, options) => {\n  if (/^\\s+$/.test(value) || value === '') {\n    errors.push(format(options.messages.whitespace, rule.fullField));\n  }\n};\n\nexport default whitespace;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\nconst range: ExecuteRule = (rule, value, source, errors, options) => {\n  const len = typeof rule.len === 'number';\n  const min = typeof rule.min === 'number';\n  const max = typeof rule.max === 'number';\n  // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n  const spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  let val = value;\n  let key = null;\n  const num = typeof value === 'number';\n  const str = typeof value === 'string';\n  const arr = Array.isArray(value);\n  if (num) {\n    key = 'number';\n  } else if (str) {\n    key = 'string';\n  } else if (arr) {\n    key = 'array';\n  }\n  // if the value is not of a supported type for range validation\n  // the validation rule rule should use the\n  // type property to also test for a particular type\n  if (!key) {\n    return false;\n  }\n  if (arr) {\n    val = value.length;\n  }\n  if (str) {\n    // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n    val = value.replace(spRegexp, '_').length;\n  }\n  if (len) {\n    if (val !== rule.len) {\n      errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n    }\n  } else if (min && !max && val < rule.min) {\n    errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n  } else if (max && !min && val > rule.max) {\n    errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n  } else if (min && max && (val < rule.min || val > rule.max)) {\n    errors.push(\n      format(options.messages[key].range, rule.fullField, rule.min, rule.max),\n    );\n  }\n};\n\nexport default range;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\nconst ENUM = 'enum' as const;\n\nconst enumerable: ExecuteRule = (rule, value, source, errors, options) => {\n  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];\n  if (rule[ENUM].indexOf(value) === -1) {\n    errors.push(\n      format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')),\n    );\n  }\n};\n\nexport default enumerable;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\nconst pattern: ExecuteRule = (rule, value, source, errors, options) => {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n      if (!rule.pattern.test(value)) {\n        errors.push(\n          format(\n            options.messages.pattern.mismatch,\n            rule.fullField,\n            value,\n            rule.pattern,\n          ),\n        );\n      }\n    } else if (typeof rule.pattern === 'string') {\n      const _pattern = new RegExp(rule.pattern);\n      if (!_pattern.test(value)) {\n        errors.push(\n          format(\n            options.messages.pattern.mismatch,\n            rule.fullField,\n            value,\n            rule.pattern,\n          ),\n        );\n      }\n    }\n  }\n};\n\nexport default pattern;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst type: ExecuteValidator = (rule, value, callback, source, options) => {\n  const ruleType = rule.type;\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value, ruleType) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, ruleType);\n    if (!isEmptyValue(value, ruleType)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default type;\n","import string from './string';\nimport method from './method';\nimport number from './number';\nimport boolean from './boolean';\nimport regexp from './regexp';\nimport integer from './integer';\nimport float from './float';\nimport array from './array';\nimport object from './object';\nimport enumValidator from './enum';\nimport pattern from './pattern';\nimport date from './date';\nimport required from './required';\nimport type from './type';\nimport any from './any';\n\nexport default {\n  string,\n  method,\n  number,\n  boolean,\n  regexp,\n  integer,\n  float,\n  array,\n  object,\n  enum: enumValidator,\n  pattern,\n  date,\n  url: type,\n  hex: type,\n  email: type,\n  required,\n  any,\n};\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst string: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, 'string');\n    if (!isEmptyValue(value, 'string')) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n      rules.pattern(rule, value, source, errors, options);\n      if (rule.whitespace === true) {\n        rules.whitespace(rule, value, source, errors, options);\n      }\n    }\n  }\n  callback(errors);\n};\n\nexport default string;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst method: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default method;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst number: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (value === '') {\n      value = undefined;\n    }\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default number;\n","import { isEmptyValue } from '../util';\nimport rules from '../rule';\nimport { ExecuteValidator } from '../interface';\n\nconst boolean: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default boolean;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst regexp: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default regexp;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst integer: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default integer;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst floatFn: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default floatFn;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule/index';\n\nconst array: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if ((value === undefined || value === null) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, 'array');\n    if (value !== undefined && value !== null) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default array;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst object: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default object;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst ENUM = 'enum' as const;\n\nconst enumerable: ExecuteValidator = (\n  rule,\n  value,\n  callback,\n  source,\n  options,\n) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules[ENUM](rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default enumerable;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst pattern: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value, 'string')) {\n      rules.pattern(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default pattern;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst date: ExecuteValidator = (rule, value, callback, source, options) => {\n  // console.log('integer rule called %j', rule);\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  // console.log('validate on %s value', value);\n  if (validate) {\n    if (isEmptyValue(value, 'date') && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value, 'date')) {\n      let dateObject;\n\n      if (value instanceof Date) {\n        dateObject = value;\n      } else {\n        dateObject = new Date(value);\n      }\n\n      rules.type(rule, dateObject, source, errors, options);\n      if (dateObject) {\n        rules.range(rule, dateObject.getTime(), source, errors, options);\n      }\n    }\n  }\n  callback(errors);\n};\n\nexport default date;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\n\nconst required: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const type = Array.isArray(value) ? 'array' : typeof value;\n  rules.required(rule, value, source, errors, options, type);\n  callback(errors);\n};\n\nexport default required;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst any: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n  }\n  callback(errors);\n};\n\nexport default any;\n","import { InternalValidateMessages } from './interface';\n\nexport function newMessages(): InternalValidateMessages {\n  return {\n    default: 'Validation error on field %s',\n    required: '%s is required',\n    enum: '%s must be one of %s',\n    whitespace: '%s cannot be empty',\n    date: {\n      format: '%s date %s is invalid for format %s',\n      parse: '%s date could not be parsed, %s is invalid ',\n      invalid: '%s date %s is invalid',\n    },\n    types: {\n      string: '%s is not a %s',\n      method: '%s is not a %s (function)',\n      array: '%s is not an %s',\n      object: '%s is not an %s',\n      number: '%s is not a %s',\n      date: '%s is not a %s',\n      boolean: '%s is not a %s',\n      integer: '%s is not an %s',\n      float: '%s is not a %s',\n      regexp: '%s is not a valid %s',\n      email: '%s is not a valid %s',\n      url: '%s is not a valid %s',\n      hex: '%s is not a valid %s',\n    },\n    string: {\n      len: '%s must be exactly %s characters',\n      min: '%s must be at least %s characters',\n      max: '%s cannot be longer than %s characters',\n      range: '%s must be between %s and %s characters',\n    },\n    number: {\n      len: '%s must equal %s',\n      min: '%s cannot be less than %s',\n      max: '%s cannot be greater than %s',\n      range: '%s must be between %s and %s',\n    },\n    array: {\n      len: '%s must be exactly %s in length',\n      min: '%s cannot be less than %s in length',\n      max: '%s cannot be greater than %s in length',\n      range: '%s must be between %s and %s in length',\n    },\n    pattern: {\n      mismatch: '%s value %s does not match pattern %s',\n    },\n    clone() {\n      const cloned = JSON.parse(JSON.stringify(this));\n      cloned.clone = this.clone;\n      return cloned;\n    },\n  };\n}\n\nexport const messages = newMessages();\n","import {\n  format,\n  complementError,\n  asyncMap,\n  warning,\n  deepMerge,\n  convertFieldsError,\n} from './util';\nimport validators from './validator/index';\nimport { messages as defaultMessages, newMessages } from './messages';\nimport {\n  InternalRuleItem,\n  InternalValidateMessages,\n  Rule,\n  RuleItem,\n  Rules,\n  ValidateCallback,\n  ValidateMessages,\n  ValidateOption,\n  Values,\n  RuleValuePackage,\n  ValidateError,\n  ValidateFieldsError,\n  SyncErrorType,\n  ValidateResult,\n} from './interface';\n\nexport * from './interface';\n\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\nclass Schema {\n  // ========================= Static =========================\n  static register = function register(type: string, validator) {\n    if (typeof validator !== 'function') {\n      throw new Error(\n        'Cannot register a validator by type, validator is not a function',\n      );\n    }\n    validators[type] = validator;\n  };\n\n  static warning = warning;\n\n  static messages = defaultMessages;\n\n  static validators = validators;\n\n  // ======================== Instance ========================\n  rules: Record<string, RuleItem[]> = null;\n  _messages: InternalValidateMessages = defaultMessages;\n\n  constructor(descriptor: Rules) {\n    this.define(descriptor);\n  }\n\n  define(rules: Rules) {\n    if (!rules) {\n      throw new Error('Cannot configure a schema with no rules');\n    }\n    if (typeof rules !== 'object' || Array.isArray(rules)) {\n      throw new Error('Rules must be an object');\n    }\n    this.rules = {};\n\n    Object.keys(rules).forEach(name => {\n      const item: Rule = rules[name];\n      this.rules[name] = Array.isArray(item) ? item : [item];\n    });\n  }\n\n  messages(messages?: ValidateMessages) {\n    if (messages) {\n      this._messages = deepMerge(newMessages(), messages);\n    }\n    return this._messages;\n  }\n\n  validate(\n    source: Values,\n    option?: ValidateOption,\n    callback?: ValidateCallback,\n  ): Promise<Values>;\n  validate(source: Values, callback: ValidateCallback): Promise<Values>;\n  validate(source: Values): Promise<Values>;\n\n  validate(source_: Values, o: any = {}, oc: any = () => {}): Promise<Values> {\n    let source: Values = source_;\n    let options: ValidateOption = o;\n    let callback: ValidateCallback = oc;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback(null, source);\n      }\n      return Promise.resolve(source);\n    }\n\n    function complete(results: (ValidateError | ValidateError[])[]) {\n      let errors: ValidateError[] = [];\n      let fields: ValidateFieldsError = {};\n\n      function add(e: ValidateError | ValidateError[]) {\n        if (Array.isArray(e)) {\n          errors = errors.concat(...e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (let i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n      if (!errors.length) {\n        callback(null, source);\n      } else {\n        fields = convertFieldsError(errors);\n        (callback as (\n          errors: ValidateError[],\n          fields: ValidateFieldsError,\n        ) => void)(errors, fields);\n      }\n    }\n\n    if (options.messages) {\n      let messages = this.messages();\n      if (messages === defaultMessages) {\n        messages = newMessages();\n      }\n      deepMerge(messages, options.messages);\n      options.messages = messages;\n    } else {\n      options.messages = this.messages();\n    }\n\n    const series: Record<string, RuleValuePackage[]> = {};\n    const keys = options.keys || Object.keys(this.rules);\n    keys.forEach(z => {\n      const arr = this.rules[z];\n      let value = source[z];\n      arr.forEach(r => {\n        let rule: InternalRuleItem = r;\n        if (typeof rule.transform === 'function') {\n          if (source === source_) {\n            source = { ...source };\n          }\n          value = source[z] = rule.transform(value);\n        }\n        if (typeof rule === 'function') {\n          rule = {\n            validator: rule,\n          };\n        } else {\n          rule = { ...rule };\n        }\n\n        // Fill validator. Skip if nothing need to validate\n        rule.validator = this.getValidationMethod(rule);\n        if (!rule.validator) {\n          return;\n        }\n\n        rule.field = z;\n        rule.fullField = rule.fullField || z;\n        rule.type = this.getType(rule);\n        series[z] = series[z] || [];\n        series[z].push({\n          rule,\n          value,\n          source,\n          field: z,\n        });\n      });\n    });\n    const errorFields = {};\n    return asyncMap(\n      series,\n      options,\n      (data, doIt) => {\n        const rule = data.rule;\n        let deep =\n          (rule.type === 'object' || rule.type === 'array') &&\n          (typeof rule.fields === 'object' ||\n            typeof rule.defaultField === 'object');\n        deep = deep && (rule.required || (!rule.required && data.value));\n        rule.field = data.field;\n\n        function addFullField(key: string, schema: RuleItem) {\n          return {\n            ...schema,\n            fullField: `${rule.fullField}.${key}`,\n            fullFields: rule.fullFields ? [...rule.fullFields, key] : [key],\n          };\n        }\n\n        function cb(e: SyncErrorType | SyncErrorType[] = []) {\n          let errorList = Array.isArray(e) ? e : [e];\n          if (!options.suppressWarning && errorList.length) {\n            Schema.warning('async-validator:', errorList);\n          }\n          if (errorList.length && rule.message !== undefined) {\n            errorList = [].concat(rule.message);\n          }\n\n          // Fill error info\n          let filledErrors = errorList.map(complementError(rule, source));\n\n          if (options.first && filledErrors.length) {\n            errorFields[rule.field] = 1;\n            return doIt(filledErrors);\n          }\n          if (!deep) {\n            doIt(filledErrors);\n          } else {\n            // if rule is required but the target object\n            // does not exist fail at the rule level and don't\n            // go deeper\n            if (rule.required && !data.value) {\n              if (rule.message !== undefined) {\n                filledErrors = []\n                  .concat(rule.message)\n                  .map(complementError(rule, source));\n              } else if (options.error) {\n                filledErrors = [\n                  options.error(\n                    rule,\n                    format(options.messages.required, rule.field),\n                  ),\n                ];\n              }\n              return doIt(filledErrors);\n            }\n\n            let fieldsSchema: Record<string, Rule> = {};\n            if (rule.defaultField) {\n              Object.keys(data.value).map(key => {\n                fieldsSchema[key] = rule.defaultField;\n              });\n            }\n            fieldsSchema = {\n              ...fieldsSchema,\n              ...data.rule.fields,\n            };\n\n            const paredFieldsSchema: Record<string, RuleItem[]> = {};\n\n            Object.keys(fieldsSchema).forEach(field => {\n              const fieldSchema = fieldsSchema[field];\n              const fieldSchemaList = Array.isArray(fieldSchema)\n                ? fieldSchema\n                : [fieldSchema];\n              paredFieldsSchema[field] = fieldSchemaList.map(\n                addFullField.bind(null, field),\n              );\n            });\n            const schema = new Schema(paredFieldsSchema);\n            schema.messages(options.messages);\n            if (data.rule.options) {\n              data.rule.options.messages = options.messages;\n              data.rule.options.error = options.error;\n            }\n            schema.validate(data.value, data.rule.options || options, errs => {\n              const finalErrors = [];\n              if (filledErrors && filledErrors.length) {\n                finalErrors.push(...filledErrors);\n              }\n              if (errs && errs.length) {\n                finalErrors.push(...errs);\n              }\n              doIt(finalErrors.length ? finalErrors : null);\n            });\n          }\n        }\n\n        let res: ValidateResult;\n        if (rule.asyncValidator) {\n          res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n        } else if (rule.validator) {\n          try {\n            res = rule.validator(rule, data.value, cb, data.source, options);\n          } catch (error) {\n            console.error?.(error);\n            // rethrow to report error\n            if (!options.suppressValidatorError) {\n              setTimeout(() => {\n                throw error;\n              }, 0);\n            }\n            cb(error.message);\n          }\n          if (res === true) {\n            cb();\n          } else if (res === false) {\n            cb(\n              typeof rule.message === 'function'\n                ? rule.message(rule.fullField || rule.field)\n                : rule.message || `${rule.fullField || rule.field} fails`,\n            );\n          } else if (res instanceof Array) {\n            cb(res);\n          } else if (res instanceof Error) {\n            cb(res.message);\n          }\n        }\n        if (res && (res as Promise<void>).then) {\n          (res as Promise<void>).then(\n            () => cb(),\n            e => cb(e),\n          );\n        }\n      },\n      results => {\n        complete(results);\n      },\n      source,\n    );\n  }\n\n  getType(rule: InternalRuleItem) {\n    if (rule.type === undefined && rule.pattern instanceof RegExp) {\n      rule.type = 'pattern';\n    }\n    if (\n      typeof rule.validator !== 'function' &&\n      rule.type &&\n      !validators.hasOwnProperty(rule.type)\n    ) {\n      throw new Error(format('Unknown rule type %s', rule.type));\n    }\n    return rule.type || 'string';\n  }\n\n  getValidationMethod(rule: InternalRuleItem) {\n    if (typeof rule.validator === 'function') {\n      return rule.validator;\n    }\n    const keys = Object.keys(rule);\n    const messageIndex = keys.indexOf('message');\n    if (messageIndex !== -1) {\n      keys.splice(messageIndex, 1);\n    }\n    if (keys.length === 1 && keys[0] === 'required') {\n      return validators.required;\n    }\n    return validators[this.getType(rule)] || undefined;\n  }\n}\n\nexport default Schema;\n"],"names":["formatRegExp","convertFieldsError","errors","length","fields","forEach","error","field","push","format","template","args","arguments","i","len","apply","str","replace","x","String","Number","JSON","stringify","_","isEmptyValue","value","type","undefined","Array","isArray","isNativeStringType","asyncSerialArray","arr","func","callback","index","arrLength","next","original","AsyncValidationError","_this","_inheritsLoose","Error","asyncMap","objArr","option","source","first","pending","Promise","resolve","reject","flattenArr","ret","Object","keys","k","flattenObjArr","e","firstFields","objArrKeys","objArrLength","total","results","key","indexOf","count","a","asyncParallelArray","complementError","rule","oe","fieldValue","obj","fullFields","path","v","getValue","fullField","message","deepMerge","target","s","hasOwnProperty","urlReg","required","options","messages","pattern","types","integer","number","parseInt","array","regexp","RegExp","date","getTime","getMonth","getYear","isNaN","object","method","email","match","url","word","b","includeBoundaries","v4","v6seg","v6","trim","v46Exact","v4exact","v6exact","ip","exact","ipv4","ipv6","getUrlRegex","hex","whitespace","test","ruleType","range","min","max","val","num","enum","join","lastIndex","mismatch","rules","string","boolean","float","dateObject","Date","any","newMessages","default","parse","invalid","clone","cloned","this","Schema","descriptor","_messages","defaultMessages","define","name","item","validate","source_","o","oc","series","z","_this2","r","transform","validator","getValidationMethod","getType","errorFields","data","doIt","res","deep","defaultField","addFullField","schema","cb","errorList","suppressWarning","warning","concat","filledErrors","map","fieldsSchema","paredFieldsSchema","fieldSchema","fieldSchemaList","bind","errs","finalErrors","asyncValidator","console","suppressValidatorError","setTimeout","then","add","complete","validators","messageIndex","splice","register"],"sourceRoot":""}