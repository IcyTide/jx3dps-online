{"version":3,"file":"static/js/7646.d74de60e.js","mappings":"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","sources":["../node_modules/@antv/g2/src/geometry/area.ts","../node_modules/@antv/g2/src/geometry/edge.ts","../node_modules/@antv/g2/src/geometry/element/index.ts","../node_modules/@antv/g2/src/geometry/heatmap.ts","../node_modules/@antv/g2/src/geometry/interval.ts","../node_modules/@antv/g2/src/geometry/label/base.ts"],"sourcesContent":["import { FIELD_ORIGIN } from '../constant';\nimport { MappingDatum } from '../interface';\nimport Path, { PathCfg } from './path';\nimport './shape/area';\n\n/** Area 几何标记构造函数参数 */\nexport interface AreaCfg extends PathCfg {\n  /**\n   * 面积图是否从 0 基准线开始填充。\n   * 1. 默认值为 `true`，表现如下：\n   * ![image](https://gw.alipayobjects.com/zos/rmsportal/ZQqwUCczalrKqGgagOVp.png)\n   * 2. 当值为 `false` 时，表现如下：\n   * ![image](https://gw.alipayobjects.com/zos/rmsportal/yPswkaXvUpCYOdhocGwB.png)\n   */\n  startOnZero?: boolean;\n}\n\n/**\n * Area 几何标记类。\n * 常用于绘制面积图。\n */\nexport default class Area extends Path {\n  public readonly type: string = 'area';\n  public readonly shapeType: string = 'area';\n  /** 生成图形关键点 */\n  public readonly generatePoints: boolean = true;\n  /**\n   * 面积图是否从 0 基准线开始填充。\n   * 1. 默认值为 `true`，表现如下：\n   * ![image](https://gw.alipayobjects.com/zos/rmsportal/ZQqwUCczalrKqGgagOVp.png)\n   * 2. 当值为 `false` 时，表现如下：\n   * ![image](https://gw.alipayobjects.com/zos/rmsportal/yPswkaXvUpCYOdhocGwB.png)\n   */\n  public readonly startOnZero: boolean = true;\n\n  constructor(cfg: AreaCfg) {\n    super(cfg);\n\n    const { startOnZero = true, sortable = false, showSinglePoint = false } = cfg;\n    this.startOnZero = startOnZero; // 默认为 true\n    this.sortable = sortable; // 关闭默认的 X 轴数据排序\n    this.showSinglePoint = showSinglePoint;\n  }\n\n  /**\n   * 获取图形绘制的关键点以及数据\n   * @param mappingData 映射后的数据\n   */\n  protected getPointsAndData(mappingData: MappingDatum[]) {\n    const points = [];\n    const data = [];\n\n    for (let i = 0, len = mappingData.length; i < len; i++) {\n      const obj = mappingData[i];\n      points.push(obj.points);\n      data.push(obj[FIELD_ORIGIN]);\n    }\n\n    return {\n      points,\n      data,\n    };\n  }\n\n  /**\n   * 获取 Y 轴上的最小值\n   * @returns y 字段最小值\n   */\n  protected getYMinValue(): number {\n    if (this.startOnZero) {\n      return super.getYMinValue();\n    }\n    const yScale = this.getYScale();\n    return yScale.min;\n  }\n}\n","import Geometry from './base';\nimport './shape/edge';\n\n/**\n * Edge 几何标记，用于绘制关系图中的**边**图形，如：\n * 1. 流程图\n * 2. 树\n * 3. 弧长连接图\n * 4. 和弦图\n * 5. 桑基图\n */\nexport default class Edge extends Geometry {\n  public readonly type: string = 'edge';\n  public readonly shapeType: string = 'edge';\n  protected generatePoints: boolean = true;\n}\n","import { deepMix, each, get, isArray, isEmpty, isEqual, isFunction, isString } from '@antv/util';\n// 暂未发包\n// @ts-ignore\nimport { propagationDelegate } from '@antv/component';\nimport { doAnimate } from '../../animate';\nimport Base from '../../base';\nimport { BBox, IGroup, IShape } from '../../dependents';\nimport { AnimateOption, Datum, ShapeFactory, ShapeInfo, StateCfg } from '../../interface';\nimport { getReplaceAttrs } from '../../util/graphics';\nimport Geometry from '../base';\nimport { GEOMETRY_LIFE_CIRCLE } from '../../constant';\nimport { BACKGROUND_SHAPE } from '../shape/constant';\n\n/** Element 构造函数传入参数类型 */\ninterface ElementCfg {\n  /** 用于创建各种 shape 的工厂对象 */\n  shapeFactory: ShapeFactory;\n  /** shape 容器 */\n  container: IGroup;\n  /** element 的索引 */\n  elementIndex?: number;\n  /** 虚拟 group，用户可以不传入 */\n  offscreenGroup?: IGroup;\n  /** 是否可见 */\n  visible?: boolean;\n}\n\n/**\n * Element 图形元素。\n * 定义：在 G2 中，我们会将数据通过图形语法映射成不同的图形，比如点图，数据集中的每条数据会对应一个点，柱状图每条数据对应一个柱子，线图则是一组数据对应一条折线，Element 即一条/一组数据对应的图形元素，它代表一条数据或者一个数据集，在图形层面，它可以是单个 Shape 也可以是多个 Shape，我们称之为图形元素。\n */\nexport default class Element extends Base {\n  /** 用于创建各种 shape 的工厂对象 */\n  public shapeFactory: ShapeFactory;\n  /** shape 容器 */\n  public container: IGroup;\n  /** element 索引 */\n  public elementIndex: number;\n  /** 最后创建的图形对象 */\n  public shape: IShape | IGroup;\n  /** shape 的动画配置 */\n  public animate: AnimateOption | boolean;\n\n  // 非构造函数属性，需要外部赋值\n  /** element 对应的 Geometry 实例 */\n  public geometry: Geometry;\n  /** 保存 shape 对应的 label */\n  public labelShape: IGroup[] = [];\n\n  /** 绘制的 shape 类型 */\n  private shapeType: string;\n\n  /** shape 绘制需要的数据 */\n  private model: ShapeInfo;\n  /** 原始数据 */\n  private data: Datum;\n  // 存储当前开启的状态\n  private states: string[] = [];\n  private statesStyle;\n  // 虚拟 Group\n  private offscreenGroup: IGroup;\n\n  constructor(cfg: ElementCfg) {\n    super(cfg);\n\n    const { shapeFactory, container, offscreenGroup, elementIndex, visible = true } = cfg;\n    this.shapeFactory = shapeFactory;\n    this.container = container;\n    this.offscreenGroup = offscreenGroup;\n    this.visible = visible;\n    this.elementIndex = elementIndex;\n  }\n\n  /**\n   * 绘制图形。\n   * @param model 绘制数据。\n   * @param isUpdate 可选，是否是更新发生后的绘制。\n   */\n  public draw(model: ShapeInfo, isUpdate: boolean = false) {\n    this.model = model;\n    this.data = model.data; // 存储原始数据\n    this.shapeType = this.getShapeType(model);\n\n    // 绘制图形\n    this.drawShape(model, isUpdate);\n\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  }\n\n  /**\n   * 更新图形。\n   * @param model 更新的绘制数据。\n   */\n  public update(model: ShapeInfo) {\n    const { shapeFactory, shape } = this;\n    if (!shape) {\n      return;\n    }\n\n    // 更新数据\n    this.model = model;\n    this.data = model.data;\n    this.shapeType = this.getShapeType(model);\n\n    // step 1: 更新 shape 携带的信息\n    this.setShapeInfo(shape, model);\n\n    // step 2: 使用虚拟 Group 重新绘制 shape，然后更新当前 shape\n    const offscreenGroup = this.getOffscreenGroup();\n    const newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);\n    // @ts-ignore\n    newShape.cfg.data = this.data;\n    // @ts-ignore\n    newShape.cfg.origin = model;\n    // label 需要使用\n    newShape.cfg.element = this;\n\n    // step 3: 同步 shape 样式\n    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));\n  }\n\n  /**\n   * 销毁 element 实例。\n   */\n  public destroy() {\n    const { shapeFactory, shape } = this;\n\n    if (shape) {\n      const animateCfg = this.getAnimateCfg('leave');\n      if (animateCfg) {\n        // 指定了动画配置则执行销毁动画\n        doAnimate(shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: {\n            ...shape.attr(),\n          },\n        });\n      } else {\n        // 否则直接销毁\n        shape.remove(true);\n      }\n    }\n\n    // reset\n    this.states = [];\n    this.shapeFactory = undefined;\n    this.container = undefined;\n    this.shape = undefined;\n    this.animate = undefined;\n    this.geometry = undefined;\n    this.labelShape = [];\n    this.model = undefined;\n    this.data = undefined;\n    this.offscreenGroup = undefined;\n    this.statesStyle = undefined;\n\n    super.destroy();\n  }\n\n  /**\n   * 显示或者隐藏 element。\n   * @param visible 是否可见。\n   */\n  public changeVisible(visible: boolean) {\n    super.changeVisible(visible);\n\n    if (visible) {\n      if (this.shape) {\n        this.shape.show();\n      }\n      if (this.labelShape) {\n        this.labelShape.forEach((label: IGroup) => {\n          label.show();\n        });\n      }\n    } else {\n      if (this.shape) {\n        this.shape.hide();\n      }\n      if (this.labelShape) {\n        this.labelShape.forEach((label: IGroup) => {\n          label.hide();\n        });\n      }\n    }\n  }\n\n  /**\n   * 设置 Element 的状态。\n   *\n   * 目前 Element 开放三种状态：\n   * 1. active\n   * 2. selected\n   * 3. inactive\n   *\n   * 这三种状态相互独立，可以进行叠加。\n   *\n   * 这三种状态的样式可在 [[Theme]] 主题中或者通过 `geometry.state()` 接口进行配置。\n   *\n   * ```ts\n   * // 激活 active 状态\n   * setState('active', true);\n   * ```\n   *\n   * @param stateName 状态名\n   * @param stateStatus 是否开启状态\n   */\n  public setState(stateName: string, stateStatus: boolean) {\n    const { states, shapeFactory, model, shape, shapeType } = this;\n\n    const index = states.indexOf(stateName);\n    if (stateStatus) {\n      // 开启状态\n      if (index > -1) {\n        // 该状态已经开启，则返回\n        return;\n      }\n      states.push(stateName);\n      if (stateName === 'active' || stateName === 'selected') {\n        shape?.toFront();\n      }\n    } else {\n      if (index === -1) {\n        // 关闭状态，但是状态未设置过\n        return;\n      }\n      states.splice(index, 1);\n      if (stateName === 'active' || stateName === 'selected') {\n        const { sortZIndex, zIndexReversed } = this.geometry;\n        const idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;\n        sortZIndex ? shape.setZIndex(idx) : shape.set('zIndex', idx);\n      }\n    }\n\n    // 使用虚拟 group 重新绘制 shape，然后对这个 shape 应用状态样式后，更新当前 shape。\n    const offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());\n    if (states.length) {\n      // 应用当前状态\n      this.syncShapeStyle(shape, offscreenShape, states, null);\n    } else {\n      // 如果没有状态，则需要恢复至原始状态\n      this.syncShapeStyle(shape, offscreenShape, ['reset'], null);\n    }\n\n    offscreenShape.remove(true); // 销毁，减少内存占用\n\n    const eventObject = {\n      state: stateName,\n      stateStatus,\n      element: this,\n      target: this.container,\n    };\n    this.container.emit('statechange', eventObject);\n    // @ts-ignore\n    propagationDelegate(this.shape, 'statechange', eventObject);\n  }\n\n  /**\n   * 清空状量态，恢复至初始状态。\n   */\n  public clearStates() {\n    const states = this.states;\n\n    each(states, (state) => {\n      this.setState(state, false);\n    });\n\n    this.states = [];\n  }\n\n  /**\n   * 查询当前 Element 上是否已设置 `stateName` 对应的状态。\n   * @param stateName 状态名称。\n   * @returns true 表示存在，false 表示不存在。\n   */\n  public hasState(stateName: string): boolean {\n    return this.states.includes(stateName);\n  }\n\n  /**\n   * 获取当前 Element 上所有的状态。\n   * @returns 当前 Element 上所有的状态数组。\n   */\n  public getStates(): string[] {\n    return this.states;\n  }\n\n  /**\n   * 获取 Element 对应的原始数据。\n   * @returns 原始数据。\n   */\n  public getData(): Datum {\n    return this.data;\n  }\n\n  /**\n   * 获取 Element 对应的图形绘制数据。\n   * @returns 图形绘制数据。\n   */\n  public getModel(): ShapeInfo {\n    return this.model;\n  }\n\n  /**\n   * 返回 Element 元素整体的 bbox，包含文本及文本连线（有的话）。\n   * @returns 整体包围盒。\n   */\n  public getBBox(): BBox {\n    const { shape, labelShape } = this;\n    let bbox = {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0,\n    };\n    if (shape) {\n      bbox = shape.getCanvasBBox();\n    }\n    if (labelShape) {\n      labelShape.forEach((label: IGroup) => {\n        const labelBBox = label.getCanvasBBox();\n        bbox.x = Math.min(labelBBox.x, bbox.x);\n        bbox.y = Math.min(labelBBox.y, bbox.y);\n        bbox.minX = Math.min(labelBBox.minX, bbox.minX);\n        bbox.minY = Math.min(labelBBox.minY, bbox.minY);\n        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);\n        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);\n      });\n    }\n\n    bbox.width = bbox.maxX - bbox.minX;\n    bbox.height = bbox.maxY - bbox.minY;\n\n    return bbox;\n  }\n\n  private getStatesStyle() {\n    if (!this.statesStyle) {\n      const { shapeType, geometry, shapeFactory } = this;\n      const stateOption = geometry.stateOption;\n      const defaultShapeType = shapeFactory.defaultShapeType;\n      const stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];\n      this.statesStyle = deepMix({}, stateTheme, stateOption);\n    }\n\n    return this.statesStyle;\n  }\n\n  // 从主题中获取对应状态量的样式\n  private getStateStyle(stateName: string, shapeKey?: string): StateCfg {\n    const statesStyle = this.getStatesStyle();\n    const stateCfg = get(statesStyle, [stateName, 'style'], {});\n    const shapeStyle = stateCfg[shapeKey] || stateCfg;\n    if (isFunction(shapeStyle)) {\n      return shapeStyle(this);\n    }\n\n    return shapeStyle;\n  }\n\n  // 获取动画配置\n  private getAnimateCfg(animateType: string) {\n    const animate = this.animate;\n    if (animate) {\n      const cfg = animate[animateType];\n\n      if (cfg) {\n        // 增加动画的回调函数，如果外部传入了，则先执行外部，然后发射 geometry 的 animate 事件\n        return {\n          ...cfg,\n          callback: () => {\n            isFunction(cfg.callback) && cfg.callback();\n            this.geometry?.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);\n          },\n        };\n      }\n      return cfg;\n    }\n\n    return null;\n  }\n\n  // 绘制图形\n  private drawShape(model: ShapeInfo, isUpdate: boolean = false) {\n    const { shapeFactory, container, shapeType } = this;\n\n    // 自定义 shape 有可能返回空 shape\n    this.shape = shapeFactory.drawShape(shapeType, model, container);\n\n    if (this.shape) {\n      this.setShapeInfo(this.shape, model); // 存储绘图数据\n      // @ts-ignore\n      const name = this.shape.cfg.name;\n      // 附加 element 的 name, name 现在支持数组了，很好用了\n      if (!name) {\n        // 这个地方如果用户添加了 name, 则附加 name ，否则就添加自己的 name\n        // @ts-ignore\n        this.shape.cfg.name = ['element', this.shapeFactory.geometryType];\n      } else if (isString(name)) {\n        // @ts-ignore\n        this.shape.cfg.name = ['element', name];\n      }\n      // 执行入场动画\n      const animateType = isUpdate ? 'enter' : 'appear';\n      const animateCfg = this.getAnimateCfg(animateType);\n      if (animateCfg) {\n        // 开始执行动画的生命周期\n        this.geometry?.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n\n        doAnimate(this.shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: {\n            ...this.shape.attr(),\n          },\n        });\n      }\n    }\n  }\n\n  // 获取虚拟 Group\n  private getOffscreenGroup() {\n    if (!this.offscreenGroup) {\n      const GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n\n    return this.offscreenGroup;\n  }\n\n  // 设置 shape 上需要携带的信息\n  private setShapeInfo(shape: IShape | IGroup, data: ShapeInfo) {\n    // @ts-ignore\n    shape.cfg.origin = data;\n    // @ts-ignore\n    shape.cfg.element = this;\n    if (shape.isGroup()) {\n      const children = shape.get('children');\n      children.forEach((child) => {\n        this.setShapeInfo(child, data);\n      });\n    }\n  }\n\n  // 更新当前 shape 的样式\n  private syncShapeStyle(\n    sourceShape: IGroup | IShape,\n    targetShape: IGroup | IShape,\n    states: string[] = [],\n    animateCfg,\n    index: number = 0\n  ) {\n    if (!sourceShape || !targetShape) {\n      return;\n    }\n    // 所有的 shape 都需要同步 clip\n    const clip = sourceShape.get('clipShape');\n    const newClip = targetShape.get('clipShape');\n\n    this.syncShapeStyle(clip, newClip, states, animateCfg);\n\n    if (sourceShape.isGroup()) {\n      const children = sourceShape.get('children');\n      const newChildren = targetShape.get('children');\n      for (let i = 0; i < children.length; i++) {\n        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);\n      }\n    } else {\n      if (!isEmpty(states) && !isEqual(states, ['reset'])) {\n        let name = sourceShape.get('name');\n        if (isArray(name)) {\n          // 会附加 element 的 name\n          name = name[1];\n        }\n\n        each(states, (state) => {\n          // background shape 不进行状态样式设置\n          if (targetShape.get('name') !== BACKGROUND_SHAPE) {\n            const style = this.getStateStyle(state, name || index); // 如果用户没有设置 name，则默认根据索引值\n            targetShape.attr(style);\n          }\n        });\n      }\n      const newAttrs = getReplaceAttrs(sourceShape as IShape, targetShape as IShape);\n\n      if (this.animate) {\n        if (animateCfg) {\n          this.geometry?.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n          // 需要进行动画\n          doAnimate(sourceShape, animateCfg, {\n            coordinate: this.shapeFactory.coordinate,\n            toAttrs: newAttrs,\n            shapeModel: this.model,\n          });\n        } else if (!isEmpty(states)) {\n          sourceShape.stopAnimate();\n          sourceShape.animate(newAttrs, {\n            duration: 300,\n          });\n        } else {\n          sourceShape.attr(newAttrs);\n        }\n      } else {\n        sourceShape.attr(newAttrs);\n      }\n    }\n  }\n\n  private getShapeType(model: ShapeInfo) {\n    const shape = get(model, 'shape');\n    return isArray(shape) ? shape[0] : shape;\n  }\n}\n","import ColorUtil from '@antv/color-util';\nimport { get, isNumber } from '@antv/util';\nimport { FIELD_ORIGIN } from '../constant';\nimport { Color, IShape } from '../dependents';\nimport { Data, Datum, MappingDatum, ShapeInfo, AttributeOption, ColorAttrCallback } from '../interface';\nimport Geometry from './base';\n\n/**\n * 用于绘制热力图。\n */\nexport default class Heatmap extends Geometry {\n  public readonly type: string = 'heatmap';\n\n  private paletteCache: Record<number, number> = {};\n  private grayScaleBlurredCanvas: HTMLCanvasElement;\n  private shadowCanvas: HTMLCanvasElement;\n  private imageShape: IShape;\n\n  protected updateElements(mappingDataArray: MappingDatum[][], isUpdate: boolean = false) {\n    for (let i = 0; i < mappingDataArray.length; i++) {\n      const mappingData = mappingDataArray[i];\n      const range = this.prepareRange(mappingData);\n      const radius = this.prepareSize();\n\n      let blur = get(this.styleOption, ['cfg', 'shadowBlur']);\n      if (!isNumber(blur)) {\n        blur = radius / 2;\n      }\n\n      this.prepareGreyScaleBlurredCircle(radius, blur);\n      this.drawWithRange(mappingData, range, radius, blur);\n    }\n  }\n\n  /** 热力图暂时不支持 callback 回调（文档需要说明下） */\n  public color(field: AttributeOption | string, cfg?: string | string[] | ColorAttrCallback): Geometry {\n    this.createAttrOption('color', field, typeof cfg !== 'function' ? cfg : '');\n\n    return this;\n  }\n\n  /**\n   * clear\n   */\n  public clear() {\n    super.clear();\n    this.clearShadowCanvasCtx();\n    this.paletteCache = {};\n  }\n\n  private prepareRange(data: MappingDatum[]) {\n    const colorAttr = this.getAttribute('color');\n    const colorField = colorAttr.getFields()[0];\n\n    let min = Infinity;\n    let max = -Infinity;\n    data.forEach((row) => {\n      const value = row[FIELD_ORIGIN][colorField];\n      if (value > max) {\n        max = value;\n      }\n      if (value < min) {\n        min = value;\n      }\n    });\n\n    if (min === max) {\n      min = max - 1;\n    }\n\n    return [min, max];\n  }\n\n  private prepareSize() {\n    let radius = this.getDefaultValue('size');\n    if (!isNumber(radius)) {\n      radius = this.getDefaultSize();\n    }\n\n    return radius;\n  }\n\n  private prepareGreyScaleBlurredCircle(radius: number, blur: number) {\n    const grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();\n    const r2 = radius + blur;\n    const ctx = grayScaleBlurredCanvas.getContext('2d');\n    grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;\n    ctx.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);\n    ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n    ctx.shadowBlur = blur;\n    ctx.shadowColor = 'black';\n\n    ctx.beginPath();\n    ctx.arc(-r2, -r2, radius, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private drawWithRange(data: MappingDatum[], range: number[], radius: number, blur: number) {\n    // canvas size\n    const { start, end } = this.coordinate;\n    const width = this.coordinate.getWidth();\n    const height = this.coordinate.getHeight();\n\n    // value, range, etc\n    const colorAttr = this.getAttribute('color');\n    const valueField = colorAttr.getFields()[0];\n\n    // prepare shadow canvas context\n    this.clearShadowCanvasCtx();\n    const ctx = this.getShadowCanvasCtx();\n    // filter data\n    if (range) {\n      data = data.filter((row) => {\n        return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];\n      });\n    }\n\n    // step1. draw points with shadow\n    const scale = this.scales[valueField];\n    for (const obj of data) {\n      const { x, y } = this.getDrawCfg(obj);\n      const alpha = scale.scale(obj[FIELD_ORIGIN][valueField]);\n      this.drawGrayScaleBlurredCircle((x as number) - start.x, (y as number) - end.y, radius + blur, alpha, ctx);\n    }\n\n    // step2. convert pixels\n    const colored = ctx.getImageData(0, 0, width, height);\n    this.clearShadowCanvasCtx();\n    this.colorize(colored);\n    ctx.putImageData(colored, 0, 0);\n    const imageShape = this.getImageShape();\n    imageShape.attr('x', start.x);\n    imageShape.attr('y', end.y);\n    imageShape.attr('width', width);\n    imageShape.attr('height', height);\n    imageShape.attr('img', ctx.canvas);\n    imageShape.set('origin', this.getShapeInfo(data)); // 存储绘图信息数据\n  }\n\n  private getDefaultSize() {\n    const position = this.getAttribute('position');\n    const coordinate = this.coordinate;\n    return Math.min(\n      coordinate.getWidth() / (position.scales[0].ticks.length * 4),\n      coordinate.getHeight() / (position.scales[1].ticks.length * 4)\n    );\n  }\n\n  private clearShadowCanvasCtx() {\n    const ctx = this.getShadowCanvasCtx();\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  }\n\n  private getShadowCanvasCtx() {\n    let canvas = this.shadowCanvas;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      this.shadowCanvas = canvas;\n    }\n    canvas.width = this.coordinate.getWidth();\n    canvas.height = this.coordinate.getHeight();\n    return canvas.getContext('2d');\n  }\n\n  private getGrayScaleBlurredCanvas() {\n    if (!this.grayScaleBlurredCanvas) {\n      this.grayScaleBlurredCanvas = document.createElement('canvas');\n    }\n\n    return this.grayScaleBlurredCanvas;\n  }\n\n  private drawGrayScaleBlurredCircle(x: number, y: number, r: number, alpha: number, ctx: CanvasRenderingContext2D) {\n    const grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();\n    ctx.globalAlpha = alpha;\n    ctx.drawImage(grayScaleBlurredCanvas, x - r, y - r);\n  }\n\n  private colorize(img: ImageData) {\n    const colorAttr = this.getAttribute('color') as Color;\n    const pixels = img.data;\n    const paletteCache = this.paletteCache;\n    for (let i = 3; i < pixels.length; i += 4) {\n      const alpha = pixels[i]; // get gradient color from opacity value\n      if (isNumber(alpha)) {\n        const palette = paletteCache[alpha] ? paletteCache[alpha] : ColorUtil.rgb2arr(colorAttr.gradient(alpha / 256));\n        pixels[i - 3] = palette[0];\n        pixels[i - 2] = palette[1];\n        pixels[i - 1] = palette[2];\n        pixels[i] = alpha;\n      }\n    }\n  }\n\n  private getImageShape() {\n    let imageShape = this.imageShape;\n    if (imageShape) {\n      return imageShape;\n    }\n    const container = this.container;\n    imageShape = container.addShape({\n      type: 'image',\n      attrs: {},\n    });\n    this.imageShape = imageShape;\n    return imageShape;\n  }\n\n  private getShapeInfo(mappingData: MappingDatum[]): ShapeInfo {\n    const shapeCfg = this.getDrawCfg(mappingData[0]);\n\n    const data = mappingData.map((obj: Datum) => {\n      return obj[FIELD_ORIGIN];\n    });\n\n    return {\n      ...shapeCfg,\n      mappingData,\n      data,\n    };\n  }\n}\n","import { get } from '@antv/util';\nimport { Datum, MappingDatum, ShapeInfo, LooseObject } from '../interface';\nimport { ShapeAttrs } from '../dependents';\nimport { getXDimensionLength } from '../util/coordinate';\nimport Geometry, { GeometryCfg } from './base';\n/** 引入对应的 ShapeFactory */\nimport './shape/interval';\nimport { getDefaultSize } from './util/shape-size';\nimport { getMaxScale } from '../util/scale';\n\n/** Path 构造函数参数类型 */\nexport interface IntervalCfg extends GeometryCfg {\n  /** shape 背景，只对 Interval Geometry 生效，目前只对 interval-rect shape 生效。 */\n  background?: { style?: ShapeAttrs };\n}\n\n/**\n * Interval 几何标记。\n * 用于绘制柱状图、饼图、条形图、玫瑰图等。\n */\nexport default class Interval extends Geometry {\n  public readonly type: string = 'interval';\n  public readonly shapeType: string = 'interval';\n  /** shape 背景。目前只对 interval-rect shape 生效。 */\n  protected background?: { style?: ShapeAttrs };\n  protected generatePoints: boolean = true;\n\n  constructor(cfg: IntervalCfg) {\n    super(cfg);\n\n    const { background } = cfg;\n    this.background = background;\n  }\n\n  /**\n   * 获取每条数据的 Shape 绘制信息\n   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n   * @returns\n   */\n  protected createShapePointsCfg(obj: Datum) {\n    const cfg = super.createShapePointsCfg(obj);\n\n    // 计算每个 shape 的 size\n    let size;\n    const sizeAttr = this.getAttribute('size');\n    if (sizeAttr) {\n      size = this.getAttributeValues(sizeAttr, obj)[0];\n      // 归一化\n      const coordinate = this.coordinate;\n      const coordinateWidth = getXDimensionLength(coordinate);\n      size = size / coordinateWidth;\n    } else {\n      if (!this.defaultSize) {\n        this.defaultSize = getDefaultSize(this);\n      }\n      size = this.defaultSize;\n    }\n    cfg.size = size;\n\n    return cfg;\n  }\n\n  /**\n   * 调整 y 轴的 scale 范围。\n   * 对于 Y 轴为数值轴柱状图，默认从 0 开始 生长。\n   */\n  protected adjustScale() {\n    super.adjustScale();\n    const yScale = this.getYScale();\n    // 特殊逻辑：饼图需要填充满整个空间\n    if (this.coordinate.type === 'theta') {\n      yScale.change({\n        nice: false,\n        min: 0,\n        // 发生过 stack 调整，yScale 的 max 被调整过，this.updateStackRange()\n        max: getMaxScale(yScale),\n      });\n    } else {\n      // 柱状图数值轴默认从 0 开始\n      const scaleDefs = this.scaleDefs;\n      const { field, min, max, type } = yScale;\n      if (type !== 'time') {\n        // time 类型不做调整\n        // 柱状图的 Y 轴要从 0 开始生长，但是如果用户设置了则以用户的为准\n        if (min > 0 && !get(scaleDefs, [field, 'min'])) {\n          yScale.change({\n            min: 0,\n          });\n        }\n        // 柱当柱状图全为负值时也需要从 0 开始生长，但是如果用户设置了则以用户的为准\n        if (max <= 0 && !get(scaleDefs, [field, 'max'])) {\n          yScale.change({\n            max: 0,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  protected getDrawCfg(mappingData: MappingDatum): ShapeInfo {\n    const shapeCfg = super.getDrawCfg(mappingData);\n    shapeCfg.background = this.background;\n\n    return shapeCfg;\n  }\n}\n","import { deepMix, each, get, isArray, isFunction, isNil, isNumber, isString, isUndefined } from '@antv/util';\n\nimport { FIELD_ORIGIN } from '../../constant';\nimport { Scale } from '../../dependents';\nimport { Datum, LabelOption, MappingDatum, Point } from '../../interface';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\n\nimport Labels from '../../component/labels';\nimport Geometry from '../base';\nimport Element from '../element';\n\nexport type GeometryLabelConstructor = new (cfg: any) => GeometryLabel;\n\nfunction avg(arr: number[]) {\n  let sum = 0;\n  each(arr, (value: number) => {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nexport default class GeometryLabel {\n  /** geometry 实例 */\n  public readonly geometry: Geometry;\n  public labelsRenderer: Labels;\n  /** 默认的布局 */\n  public defaultLayout: string;\n\n  constructor(geometry: Geometry) {\n    this.geometry = geometry;\n  }\n\n  public getLabelItems(mapppingArray: MappingDatum[]): LabelItem[] {\n    const items = [];\n    const labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      const labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      const total = labelContent.length;\n      each(labelContent, (content, subIndex) => {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        const item = {\n          ...labelCfg,\n          ...this.getLabelPoint(labelCfg, mappingData, subIndex),\n        };\n        if (!item.textAlign) {\n          item.textAlign = this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  }\n\n  public async render(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    const labelItems = this.getLabelItems(mappingArray);\n    const labelsRenderer = this.getLabelsRenderer();\n    const shapes = this.getGeometryShapes();\n    // 渲染文本\n    await labelsRenderer.render(labelItems, shapes, isUpdate);\n  }\n\n  public clear() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  }\n\n  public destroy() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  }\n\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  public getCoordinate() {\n    return this.geometry.coordinate;\n  }\n\n  /**\n   * 获取 label 的默认配置\n   */\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const geometry = this.geometry;\n    const { type, theme } = geometry;\n\n    if (\n      type === 'polygon' ||\n      (type === 'interval' && position === 'middle') ||\n      (offset < 0 && !['line', 'point', 'path'].includes(type))\n    ) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n\n    return get(theme, 'labels', {});\n  }\n\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { type, theme } = geometry;\n    let themedLabelCfg;\n\n    if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n\n    return themedLabelCfg;\n  }\n\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  protected setLabelPosition(\n    labelPointCfg: LabelPointCfg,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {}\n\n  /**\n   * @desc 获取 label offset\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    const vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  }\n\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number): Point {\n    const offset = labelCfg.offset;\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    const offsetPoint = {\n      x: 0,\n      y: 0,\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  }\n\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    const coordinate = this.getCoordinate();\n    const total = labelCfg.content.length;\n\n    function getDimValue(value: number | number[], idx: number, isAvg = false) {\n      let v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[(value as number[]).length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n\n    const label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: { x: 0, y: 0 },\n      color: '#fff',\n    };\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    const isFunnel = shape === 'funnel' || shape === 'pyramid';\n\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      const centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(nextPoints[1] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(points[2] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    const offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = { x: label.x, y: label.y };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  }\n\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelAlign(item: LabelItem, index: number, total: number): TextAlign {\n    let align: TextAlign = 'center';\n    const coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      const offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  }\n\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  protected getLabelId(mappingData: MappingDatum) {\n    const geometry = this.geometry;\n    const type = geometry.type;\n    const xScale = geometry.getXScale();\n    const yScale = geometry.getYScale();\n    const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    let labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += ` ${origin[xScale.field]}`;\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += ` ${origin[xScale.field]}-${origin[yScale.field]}`;\n    }\n\n    return labelId;\n  }\n\n  // 获取 labels 组件\n  private getLabelsRenderer() {\n    const { labelsContainer, labelOption, canvasRegion, animateOption } = this.geometry;\n    const coordinate = this.geometry.coordinate;\n\n    let labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout,\n        }),\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n\n    return labelsRenderer;\n  }\n\n  private getLabelCfgs(mapppingArray: MappingDatum[]): LabelCfg[] {\n    const geometry = this.geometry;\n    const { labelOption, scales, coordinate } = geometry;\n    const { fields, callback, cfg } = labelOption as LabelOption;\n    const labelScales = fields.map((field: string) => {\n      return scales[field];\n    });\n\n    const labelCfgs: LabelCfg[] = [];\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      const originText = this.getLabelText(origin, labelScales);\n      let callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        const originValues = fields.map((field: string) => origin[field]);\n        callbackCfg = callback(...originValues);\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      let labelCfg = {\n        id: this.getLabelId(mappingData), // 进行 ID 标记\n        elementId: this.geometry.getElementId(mappingData), // label 对应 Element 的 ID\n        data: origin, // 存储原始数据\n        mappingData, // 存储映射后的数据,\n        coordinate, // 坐标系\n        ...cfg,\n        ...callbackCfg,\n      };\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      const offset = this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      const defaultLabelCfg = this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = this.getLabelOffset(labelCfg.offset || 0);\n\n      const content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n\n    return labelCfgs;\n  }\n\n  private getLabelText(origin: Datum, scales: Scale[]) {\n    const labelTexts = [];\n    each(scales, (scale: Scale) => {\n      let value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map((subVal) => {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  }\n\n  private getOffsetVector(offset: number | string = 0) {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  }\n\n  private getGeometryShapes() {\n    const geometry = this.geometry;\n    const shapes = {};\n    each(geometry.elementsMap, (element: Element, id: string) => {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), (child) => {\n      const id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n\n    return shapes;\n  }\n}\n"],"names":["cfg","_super","_this","startOnZero","_a","_b","sortable","_c","showSinglePoint","__extends","Area","mappingData","points","data","i","len","length","obj","push","FIELD_ORIGIN","this","getYMinValue","call","getYScale","min","Path","Geometry","shapeFactory","container","offscreenGroup","elementIndex","visible","Element","model","isUpdate","shapeType","getShapeType","drawShape","changeVisible","shape","setShapeInfo","getOffscreenGroup","newShape","origin","element","syncShapeStyle","getStates","getAnimateCfg","animateCfg","doAnimate","coordinate","toAttrs","attr","remove","states","undefined","animate","geometry","labelShape","statesStyle","destroy","show","forEach","label","hide","stateName","stateStatus","index","indexOf","toFront","splice","sortZIndex","idx","elements","setZIndex","set","offscreenShape","eventObject","state","target","emit","propagationDelegate","each","setState","includes","bbox","x","y","minX","minY","maxX","maxY","width","height","getCanvasBBox","labelBBox","Math","max","stateOption","defaultShapeType","stateTheme","theme","deepMix","shapeKey","getStatesStyle","stateCfg","get","shapeStyle","isFunction","animateType","cfg_1","callback","GEOMETRY_LIFE_CIRCLE","name_1","name","isString","geometryType","GroupCtor","getGroupBase","isGroup","child","sourceShape","targetShape","clip","newClip","children","newChildren","isEmpty","isEqual","name_2","isArray","BACKGROUND_SHAPE","style","getStateStyle","newAttrs","getReplaceAttrs","shapeModel","stopAnimate","duration","Base","Heatmap","mappingDataArray","range","prepareRange","radius","prepareSize","blur_1","styleOption","isNumber","prepareGreyScaleBlurredCircle","drawWithRange","field","createAttrOption","clear","clearShadowCanvasCtx","paletteCache","colorField","getAttribute","getFields","Infinity","row","value","getDefaultValue","getDefaultSize","blur","grayScaleBlurredCanvas","getGrayScaleBlurredCanvas","r2","ctx","getContext","clearRect","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","beginPath","arc","PI","closePath","fill","start","end","getWidth","getHeight","valueField","getShadowCanvasCtx","filter","scale","scales","data_1_1","getDrawCfg","alpha","drawGrayScaleBlurredCircle","colored","getImageData","colorize","putImageData","imageShape","getImageShape","canvas","getShapeInfo","position","ticks","shadowCanvas","document","createElement","r","globalAlpha","drawImage","img","colorAttr","pixels","palette","ColorUtil","gradient","addShape","type","attrs","shapeCfg","map","background","Interval","size","createShapePointsCfg","sizeAttr","getAttributeValues","getXDimensionLength","defaultSize","adjustScale","yScale","change","nice","getMaxScale","scaleDefs","avg","arr","sum","GeometryLabel","mapppingArray","items","labelCfgs","getLabelCfgs","labelCfg","isNil","labelContent","content","total","subIndex","item","getLabelPoint","textAlign","getLabelAlign","offset","labelLine","mappingArray","labelItems","getLabelItems","labelsRenderer","getLabelsRenderer","shapes","getGeometryShapes","render","defaultLabelCfg","getDefaultLabelCfg","innerLabels","labels","labelPointCfg","getCoordinate","vector","getOffsetVector","isTransposed","transposed","dim","factor","offsetPoint","getDimValue","isAvg","v","color","isFunnel","centroid","getPolygonCentroid","nextPoints","point1","convert","point2","setLabelPosition","getLabelOffsetPoint","align","xScale","getXScale","labelId","getElementId","concat","labelsContainer","labelOption","canvasRegion","animateOption","Labels","layout","defaultLayout","region","getDefaultAnimateCfg","fields","labelScales","callbackCfg","originText","getLabelText","originValues","__spreadArray","id","getLabelId","elementId","getLabelOffset","isUndefined","labelTexts","subVal","getText","actualOffset","applyMatrix","elementsMap","getChildren"],"sourceRoot":""}