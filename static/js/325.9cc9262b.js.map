{"version":3,"file":"static/js/325.9cc9262b.js","mappings":"yLAiEA,SAASA,EAAyBC,EAAgBC,GAChD,IAAMC,GAASC,EAAAA,EAAAA,IAAcH,EAAIE,OAAQF,EAAII,aAAcJ,EAAIK,iBAC3DC,EAAO,GAMX,OALAC,EAAAA,EAAAA,IAAKL,GAAQ,SAACM,GACZ,IAAMC,EAzBV,SAA8BP,EAAiBD,GAC7C,IAAIS,EAAS,GASb,OARAH,EAAAA,EAAAA,IAAKL,GAAQ,SAACS,EAAcC,GAC1B,IAAMC,EAAYX,EAAOU,EAAQ,GAEjC,GADAF,EAAOI,KAAKH,GACRE,EAAW,CACb,IAAME,EAzCgB,SAACJ,EAAcE,EAAkBZ,GAC3D,IAIIS,EAJEM,EAAIL,EAAMK,EACVC,EAAIN,EAAMM,EACVC,EAAQL,EAAUG,EAClBG,EAAQN,EAAUI,EAGxB,OAAQhB,GACN,IAAK,KACHS,EAAS,CAAC,CAAEM,EAAGE,EAAOD,EAAC,IACvB,MACF,IAAK,KACHP,EAAS,CAAC,CAAEM,EAAC,EAAEC,EAAGE,IAClB,MACF,IAAK,MACH,IAAMC,GAAWF,EAAQF,GAAK,EAC9BN,EAAS,CACP,CAAEM,EAAGI,EAASH,EAAC,GACf,CAAED,EAAGI,EAASH,EAAGE,IAEnB,MACF,IAAK,MACH,IAAME,GAAWJ,EAAIE,GAAS,EAC9BT,EAAS,CACP,CAAEM,EAAC,EAAEC,EAAGI,GACR,CAAEL,EAAGE,EAAOD,EAAGI,IAOrB,OAAOX,CACR,CAQ8BY,CAAoBX,EAAOE,EAAWZ,GAC/DS,EAASA,EAAOa,OAAOR,EACxB,CACF,IACML,CACR,CAc6Bc,CAAqBhB,EAAgBP,GAC/DK,EAAOA,EAAKiB,OAZhB,SAA4BrB,GAC1B,OAAOA,EAAOuB,KAAI,SAACd,EAAOC,GACxB,OAAiB,IAAVA,EAAc,CAAC,IAAKD,EAAMK,EAAGL,EAAMM,GAAK,CAAC,IAAKN,EAAMK,EAAGL,EAAMM,EACrE,GACF,CAQsBS,CAAmBjB,GACvC,KAEM,qBACFkB,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,EAAO,cAAY,CAC1CM,KAAI,GAEP,EAGDC,EAAAA,EAAAA,IAAK,CAAC,KAAM,KAAM,MAAO,QAAQ,SAACN,IAChC2B,EAAAA,EAAAA,IAAc,OAAQ3B,EAAW,CAC/B4B,KAAA,SAAK7B,EAAgB8B,GACnB,IAAMC,EAAQhC,EAAyBC,EAAKC,GAO5C,OANc6B,EAAUE,SAAS,CAC/BC,KAAM,OACNF,MAAK,EACLG,KAAM,QAIT,EACDC,UAAA,SAAUC,GACR,OAAOC,EAAAA,EAAAA,GAAcD,EAAWnC,EACjC,GAEJ,G,wDC9FD,IAAMqC,EAAc,CAClBC,KAAM,SAACvB,EAAWC,EAAWuB,GAC3B,MAAO,CACL,CAAC,IAAKxB,EAAIwB,EAAGvB,GACb,CAAC,IAAKD,EAAIwB,EAAGvB,GAEhB,EACDwB,IAAK,SAACzB,EAAWC,EAAWuB,GAC1B,MAAO,CACL,CAAC,IAAKxB,EAAIwB,EAAGvB,GACb,CAAC,IAAKD,EAAIwB,EAAGvB,GAEhB,EACDyB,KAAM,SAAC1B,EAAWC,EAAWuB,GAC3B,MAAO,CACL,CAAC,IAAKxB,EAAIwB,EAAGvB,GACb,CAAC,IAAKD,EAAIwB,EAAGvB,GAEhB,EACD0B,OAAQ,SAAC3B,EAAWC,EAAWuB,GAC7B,MAAO,CACL,CAAC,IAAKxB,EAAIwB,EAAGvB,GACb,CAAC,IAAKuB,EAAI,EAAGA,EAAI,EAAG,EAAG,EAAG,EAAGxB,EAAGC,GAChC,CAAC,IAAKuB,EAAI,EAAGA,EAAI,EAAG,EAAG,EAAG,EAAGxB,EAAIwB,EAAGvB,GAEvC,EACD2B,GAAI,SAAC5B,EAAWC,EAAWuB,GACzB,MAAO,CACL,CAAC,IAAKxB,EAAIwB,EAAI,EAAGvB,EAAI,KACrB,CAAC,IAAKD,EAAGC,EAAI,KACb,CAAC,IAAKD,EAAGC,EAAI,KACb,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KAExB,EACD4B,GAAI,SAAC7B,EAAWC,EAAWuB,GACzB,MAAO,CACL,CAAC,IAAKxB,EAAIwB,EAAI,EAAGvB,EAAI,KACrB,CAAC,IAAKD,EAAGC,EAAI,KACb,CAAC,IAAKD,EAAGC,EAAI,KACb,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KAExB,EACD6B,IAAK,SAAC9B,EAAWC,EAAWuB,GAC1B,MAAO,CACL,CAAC,IAAKxB,GAAKwB,EAAI,GAAIvB,EAAI,KACvB,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KACrB,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KACrB,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KACrB,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KACrB,CAAC,IAAKD,EAAIwB,EAAI,EAAGvB,EAAI,KAExB,EACD8B,IAAK,SAAC/B,EAAWC,GAEf,MAAO,CACL,CAAC,IAAKD,EAAI,EAAGC,EAAI,KACjB,CAAC,IAAKD,EAAI,EAAGC,GACb,CAAC,IAAKD,EAAGC,GACT,CAAC,IAAKD,EAAGC,EAAI,GACb,CAAC,IAAKD,EAAGC,EAAI,GACb,CAAC,IAAKD,EAAI,IAAKC,EAAI,GAEtB,GAUG,SAAUoB,EAAcD,EAA2BnC,GAC/C,IAAA+C,EAAUZ,EAAS,MAC3B,MAAO,CACLa,OAAQX,EAAYrC,GACpBiD,MAAO,CACLC,UAAW,EACXX,EAAG,EACHY,OAAQJ,GAGb,C,wEC3EDzC,EAAAA,EAAAA,IAAK8C,EAAAA,IAAe,SAACC,IACnB1B,EAAAA,EAAAA,IAAc,QAAS0B,EAAW,CAChCzB,KAAA,SAAK7B,EAAgB8B,GACnB,OAAOyB,EAAAA,EAAAA,IAAWC,KAAMxD,EAAK8B,EAAWwB,GAAW,EACpD,EACDnB,UAAA,SAAUC,GACA,IAAAY,EAAUZ,EAAS,MAC3B,MAAO,CACLa,OAAQQ,EAAAA,EAAcH,GACtBJ,MAAO,CACLV,EAAG,IACHY,OAAQJ,EACRU,KAAM,MAGX,GAEJ,G,6DCpBD9B,EAAAA,EAAAA,IAAc,QAAS,QAAS,CAC9BC,KAAA,SAAK7B,EAAgB8B,G,QACR6B,GAAShC,EAAAA,EAAAA,GAAS3B,GAAK,GAAO,EAAO,KAAIwC,EAC9CtC,EAASsD,KAAKI,YAAY5D,EAAIE,QAChC2D,EAAgB3D,EAAO,GAC3B,GAAIF,EAAI8D,QACND,EAAgB3D,EAAO,QAClB,GAAIA,EAAO6D,OAAS,EAAG,CAC5B,IAAMC,EAAQlC,EAAUmC,W,IACxB,IAAoB,eAAA/D,GAAMgE,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAAvB,IAAMvD,EAAK,QACdqD,EAAMhC,SAAS,QAAS,CACtBD,MAAO,CACLf,EAAIL,EAAMK,EAAe2C,EAAO,EAChC1C,EAAIN,EAAMM,EAAe0C,EACzBQ,MAAOR,EACPS,OAAQT,EACRU,IAAKrE,EAAIsE,MAAM,KAGpB,C,kGAED,OAAON,CACR,CAED,OAAOlC,EAAUE,SAAS,QAAS,CACjCD,MAAO,CACLf,EAAI6C,EAAc7C,EAAe2C,EAAO,EACxC1C,EAAI4C,EAAc5C,EAAe0C,EACjCQ,MAAOR,EACPS,OAAQT,EACRU,IAAKrE,EAAIsE,MAAM,KAGpB,EACDnC,UAAA,SAAUC,GAER,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLV,EAAG,IACHkB,KALctB,EAAS,OAQ5B,G,mFCxCuBmC,EAAAA,EAAAA,IAAqB,QAAS,CACtDC,iBAAkB,gBAClBC,iBAAA,SAAiBC,GACf,OAAOC,EAAAA,EAAAA,GAAYD,EACpB,KAGHnE,EAAAA,EAAAA,IAAKqE,EAAAA,IAAQ,SAACtB,IAEZ1B,EAAAA,EAAAA,IAAc,QAAS,iBAAU0B,GAAa,CAC5CzB,KAAA,SAAK7B,EAAgB8B,GACnB,OAAOyB,EAAAA,EAAAA,IAAWC,KAAMxD,EAAK8B,EAAWwB,GAAW,EACpD,EACDnB,UAAA,SAAUC,GACA,IAAAY,EAAUZ,EAAS,MAC3B,MAAO,CACLa,OAAQQ,EAAAA,EAAcH,IAAcA,EACpCJ,MAAO,CACLV,EAAG,IACHY,OAAQJ,EACRU,KAAM,MAGX,GAEJ,G,wECzBDnD,EAAAA,EAAAA,IAAKqE,EAAAA,IAAQ,SAACtB,IACZ1B,EAAAA,EAAAA,IAAc,QAAS0B,EAAW,CAChCzB,KAAA,SAAK7B,EAAgB8B,GACnB,OAAOyB,EAAAA,EAAAA,IAAWC,KAAMxD,EAAK8B,EAAWwB,GAAW,EACpD,EACDnB,UAAA,SAAUC,GACA,IAAAY,EAAUZ,EAAS,MAC3B,MAAO,CACLa,OAAQQ,EAAAA,EAAcH,IAAcA,EACpCJ,MAAO,CACLV,EAAG,IACHkB,KAAMV,GAGX,GAEJ,G,8ICpBY4B,EAAS,CAAC,SAAU,SAAU,SAAU,UAAW,UAAW,WAAY,iBAC1EvB,EAAgB,CAAC,QAAS,OAAQ,OAAQ,SAAU,QAY3D,SAAUE,EACde,EACAtE,EACA8B,EACAwB,EACAuB,G,QAEM3B,GAAQvB,EAAAA,EAAAA,GAAS3B,EAAK6E,GAAWA,EAAU,KAC3C3E,EAASoE,EAAMV,YAAY5D,EAAIE,QACjC2D,EAAgB3D,EAAO,GAC3B,GAAIF,EAAI8D,QACND,EAAgB3D,EAAO,QAClB,GAAIA,EAAO6D,OAAS,EAAG,CAC5B,IAAMC,EAAQlC,EAAUmC,W,IACxB,IAAoB,eAAA/D,GAAMgE,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAAvB,IAAMvD,EAAK,QACdqD,EAAMhC,SAAS,CACbC,KAAM,SACNF,OAAO,6BACFmB,GAAK,CACRD,OAAQQ,EAAAA,EAAcH,IAAcA,IACjC3C,IAGR,C,kGACD,OAAOqD,CACR,CAED,OAAOlC,EAAUE,SAAS,CACxBC,KAAM,SACNF,OAAO,6BACFmB,GAAK,CACRD,OAAQQ,EAAAA,EAAcH,IAAcA,IACjCO,IAGR,C,wECjB2BU,EAAAA,EAAAA,IAAqB,UAAW,CAC1DC,iBAAkB,UAClBC,iBAAA,SAAiBC,GACf,IAAMxE,EAAS,GAQf,OAPAK,EAAAA,EAAAA,IAAKmE,EAAU1D,GAAe,SAAC8D,EAAMlE,GACnC,IAAMmE,EAAOL,EAAUzD,EAAEL,GACzBV,EAAOY,KAAK,CACVE,EAAG8D,EACH7D,EAAG8D,GAEN,IACM7E,CACR,KAGH0B,EAAAA,EAAAA,IAAc,UAAW,UAAW,CAClCC,KAAA,SAAK7B,EAAgB8B,GACnB,KAAKkD,EAAAA,EAAAA,IAAQhF,EAAIE,QAAS,CACxB,IAAM+E,GAAatD,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GACjCM,EAAOkD,KAAK0B,UAhDxB,SAAiBhF,GAMf,IALA,IAAIiF,EAAYjF,EAAO,GACnBkF,EAAI,EAEF9E,EAAO,CAAC,CAAC,IAAK6E,EAAKnE,EAAGmE,EAAKlE,IAE1BmE,EAAIlF,EAAO6D,QAAQ,CACxB,IAAMsB,EAASnF,EAAOkF,GAClBC,EAAErE,IAAMd,EAAOkF,EAAI,GAAGpE,GAAKqE,EAAEpE,IAAMf,EAAOkF,EAAI,GAAGnE,IACnDX,EAAKQ,KAAK,CAAC,IAAKuE,EAAErE,EAAGqE,EAAEpE,IACnBoE,EAAErE,IAAMmE,EAAKnE,GAAKqE,EAAEpE,IAAMkE,EAAKlE,GAAKmE,EAAIlF,EAAO6D,OAAS,IAC1DoB,EAAOjF,EAAOkF,EAAI,GAClB9E,EAAKQ,KAAK,CAAC,MACXR,EAAKQ,KAAK,CAAC,IAAKqE,EAAKnE,EAAGmE,EAAKlE,IAC7BmE,MAGJA,GACD,CAQD,OANKE,EAAAA,EAAAA,KAAQC,EAAAA,EAAAA,IAAKjF,GAAO6E,IACvB7E,EAAKQ,KAAK,CAAC,IAAKqE,EAAKnE,EAAGmE,EAAKlE,IAG/BX,EAAKQ,KAAK,CAAC,MAEJR,CACR,CAqBiCkF,CAAQxF,EAAIE,SACxC,OAAO4B,EAAUE,SAAS,OAAQ,CAChCD,OAAO,oBACFkD,GAAU,CACb3E,KAAI,IAEN4B,KAAM,WAET,CACF,EACDC,UAAA,SAAUC,GAER,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLV,EAAG,EACHkB,KALctB,EAAS,OAQ5B,G,uECnEH,SAASqD,EAAavF,EAAeyD,GACnC,IAAMQ,EAAQuB,KAAKC,IAAIzF,EAAO,GAAGc,EAAId,EAAO,GAAGc,GACzCoD,EAASsB,KAAKC,IAAIzF,EAAO,GAAGe,EAAIf,EAAO,GAAGe,GAE5C2E,EAAMF,KAAKG,IAAI1B,EAAOC,GAQ1B,OAPIT,IACFiC,GAAME,EAAAA,EAAAA,IAAMnC,EAAM,EAAG+B,KAAKG,IAAI1B,EAAOC,KAEvCwB,GAAY,EAIL,CACL5E,GAJed,EAAO,GAAGc,EAAId,EAAO,GAAGc,GAAK,EAI/B4E,EACb3E,GAJef,EAAO,GAAGe,EAAIf,EAAO,GAAGe,GAAK,EAI/B2E,EACbzB,MAAa,EAANyB,EACPxB,OAAc,EAANwB,EAEX,EAEDhE,EAAAA,EAAAA,IAAc,UAAW,SAAU,CACjCC,KAAA,SAAK7B,EAAgB8B,GACnB,KAAKkD,EAAAA,EAAAA,IAAQhF,EAAIE,QAAS,CACxB,IAAM+E,GAAatD,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GACjCE,EAASsD,KAAKI,YAAY5D,EAAIE,QACpC,OAAO4B,EAAUE,SAAS,OAAQ,CAChCD,OAAO,oBACFkD,GACAQ,EAAavF,EAAQF,EAAI2D,OAE9BzB,KAAM,WAET,CACF,EACDC,UAAA,SAAUC,GAER,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLV,EAAG,EACHkB,KALctB,EAAS,OAQ5B,G,uEC3CH,SAAS2D,EAAWC,GAClB,IAAMC,GAASC,EAAAA,EAAAA,IAAQF,GAAmBA,EAAV,CAACA,GAE3BH,EAAMI,EAAM,GACZE,EAAMF,EAAMA,EAAMlC,OAAS,GAC3BqC,EAAOH,EAAMlC,OAAS,EAAIkC,EAAM,GAAKJ,EAI3C,MAAO,CACLA,IAAG,EACHM,IAAG,EACHC,KAAI,EACJC,KAPWJ,EAAMlC,OAAS,EAAIkC,EAAM,GAAKE,EAQzCG,OAPaL,EAAMlC,OAAS,EAAIkC,EAAM,GAAKG,EAS9C,CAED,SAASG,EAAavF,EAAsBC,EAAsB0C,GAChE,IACI6C,EADEC,EAAW9C,EAAO,EAExB,IAAIuC,EAAAA,EAAAA,IAAQjF,GAAI,CAER,MAAmC8E,EAAW9E,GAA5C4E,EAAG,MAAEM,EAAG,MAAEG,EAAM,SAAEF,EAAI,OACxBM,EAAQ1F,EAAeyF,EACvBE,EAAQ3F,EAAeyF,EAC7BD,EAAc,CACZ,CAACE,EAAMP,GACP,CAACQ,EAAMR,GACP,CAACnF,EAAamF,GACd,CAACnF,EAP6BqF,EAAI,QAQlC,CAACK,EAAMN,GACP,CAACM,EAAML,GACP,CAACM,EAAMN,GACP,CAACM,EAAMP,GACP,CAACpF,EAAaoF,GACd,CAACpF,EAAa6E,GACd,CAACa,EAAMb,GACP,CAACc,EAAMd,GACP,CAACa,EAAMJ,GACP,CAACK,EAAML,GAEV,KAAM,CAELrF,GAAI2F,EAAAA,EAAAA,IAAM3F,GAAK,GAAMA,EACf,IAA0BoF,EAA1B,EAAmCN,EAAW/E,GAC9C6F,GADEhB,EAAG,MAAEM,EAAG,MAAEG,EAAM,SACXrF,EAAIwF,GACXK,EAAO7F,EAAIwF,EACjBD,EAAc,CACZ,CAACX,EAAKgB,GACN,CAAChB,EAAKiB,GACN,CAACjB,EAAK5E,GACN,CAPwBmF,EAAI,OAOrBnF,GACP,CAACmF,EAAMS,GACP,CAACT,EAAMU,GACP,CAV8BT,EAAI,OAU3BS,GACP,CAACT,EAAMQ,GACP,CAACR,EAAMpF,GACP,CAACkF,EAAKlF,GACN,CAACkF,EAAKU,GACN,CAACV,EAAKW,GACN,CAACR,EAAQO,GACT,CAACP,EAAQQ,GAEZ,CAED,OAAON,EAAY/E,KAAI,SAACsF,GACtB,MAAO,CACL/F,EAAG+F,EAAI,GACP9F,EAAG8F,EAAI,GAEV,GACF,EAwBDnF,EAAAA,EAAAA,IAAc,SAAU,MAAO,CAC7BoF,UAAA,SAAUC,GAER,OAAOV,EADgBU,EAAU,EAAVA,EAAU,EAAVA,EAAU,KAElC,EACDpF,KAAA,SAAK7B,EAAgB8B,GACnB,IA5BgB5B,EA4BVgD,GAAQvB,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GAC5BM,EAAOkD,KAAK0B,UA5Bb,CACL,CAAC,KAFehF,EA6BuBF,EAAIE,QA3B9B,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,KACD,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,IAAIc,EAAGd,EAAO,IAAIe,GAC/B,CAAC,IAAKf,EAAO,IAAIc,EAAGd,EAAO,IAAIe,GAC/B,CAAC,IAAKf,EAAO,IAAIc,EAAGd,EAAO,IAAIe,GAC/B,CAAC,IAAKf,EAAO,IAAIc,EAAGd,EAAO,IAAIe,KAqB/B,OARca,EAAUE,SAAS,OAAQ,CACvCD,OAAO,oBACFmB,GAAK,CACR5C,KAAI,EACJ4B,KAAM,YAKX,EACDC,UAAA,SAAUC,GAER,MAAO,CACLa,OAAA,SAAOjC,EAAWC,EAAWuB,GAC3B,IACMtC,EAASqG,EAAavF,EADZ,CAACC,EAAI,EAAGA,EAAI,EAAGA,EAAGA,EAAI,EAAGA,EAAI,GACLuB,GACxC,MAAO,CACL,CAAC,IAAKtC,EAAO,GAAGc,EAAI,EAAGd,EAAO,GAAGe,GACjC,CAAC,IAAKf,EAAO,GAAGc,EAAI,EAAGd,EAAO,GAAGe,GACjC,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,KACD,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,IAAIc,EAAI,EAAGd,EAAO,IAAIe,GACnC,CAAC,IAAKf,EAAO,IAAIc,EAAI,EAAGd,EAAO,IAAIe,GACnC,CAAC,IAAKf,EAAO,IAAIc,EAAGd,EAAO,IAAIe,GAC/B,CAAC,IAAKf,EAAO,IAAIc,EAAGd,EAAO,IAAIe,GAElC,EACDiC,MAAO,CACLV,EAAG,EACHW,UAAW,EACXC,OA3BchB,EAAS,OA8B5B,G,kFCxIH,SAAS8E,EAAgBlG,EAAWC,EAAa0C,GAC/C,IAAMwD,EATR,SAA0BnB,GACxB,IAEMoB,IAFSlB,EAAAA,EAAAA,IAAQF,GAAmBA,EAAV,CAACA,IAEZqB,MAAK,SAACC,EAAGC,GAAM,OAAAA,EAAID,CAAC,IACzC,OAAOE,EAAAA,EAAAA,IAAOJ,EAAQ,EAAGA,EAAOA,EAAOrD,OAAS,GACjD,CAIiB0D,CAAiBxG,GACjC,MAAO,CACL,CAAED,EAAC,EAAEC,EAAGkG,EAAQ,IAChB,CAAEnG,EAAC,EAAEC,EAAGkG,EAAQ,IAChB,CAAEnG,EAAGA,EAAI2C,EAAO,EAAG1C,EAAGkG,EAAQ,IAC9B,CAAEnG,EAAGA,EAAI2C,EAAO,EAAG1C,EAAGkG,EAAQ,IAC9B,CAAEnG,EAAGA,EAAI2C,EAAO,EAAG1C,EAAGkG,EAAQ,IAC9B,CAAEnG,EAAGA,EAAI2C,EAAO,EAAG1C,EAAGkG,EAAQ,IAC9B,CAAEnG,EAAC,EAAEC,EAAGkG,EAAQ,IAChB,CAAEnG,EAAC,EAAEC,EAAGkG,EAAQ,IAEnB,EAiBDvF,EAAAA,EAAAA,IAAc,SAAU,SAAU,CAChCoF,UAAA,SAAUC,GAER,OAAOC,EADgBD,EAAU,EAAVA,EAAU,EAAVA,EAAU,KAElC,EACDpF,KAAA,SAAK7B,EAAgB8B,GACnB,IArBmB5B,EAqBbgD,GAAQvB,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GAC5BM,EAAOkD,KAAK0B,UArBb,CACL,CAAC,KAFkBhF,EAsBuBF,EAAIE,QApBjC,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,KACD,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,KAqB7B,OARca,EAAUE,SAAS,OAAQ,CACvCD,OAAO,oBACFmB,GAAK,CACR5C,KAAI,EACJ4B,KAAM,YAKX,EACDC,UAAA,SAAUC,GACA,IAAAY,EAAUZ,EAAS,MAC3B,MAAO,CACLa,OAAA,SAAOjC,EAAWC,EAAWuB,GAC3B,IACMtC,EAASgH,EAAgBlG,EADf,CAACC,EAAI,IAAKA,EAAI,EAAGA,EAAI,EAAGA,EAAI,KACDuB,GAC3C,MAAO,CACL,CAAC,IAAKtC,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,KACD,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAC7B,CAAC,IAAKf,EAAO,GAAGc,EAAGd,EAAO,GAAGe,GAEhC,EACDiC,MAAO,CACLC,UAAW,EACXC,OAAQJ,EACRU,KAAMV,EACNR,EAAG,GAGR,G,yBCtFwB+B,E,QAAAA,IAAqB,SAAU,CACxDC,iBAAkB,I,mICEpB,SAASkD,EAAa1B,GACpB,OAAIA,IAGa,OAAVA,QAA4B2B,IAAV3B,GAAuB4B,MAAM5B,GACvD,CAED,SAAS6B,EAAOlH,GACd,IAAIuF,EAAAA,EAAAA,IAAQvF,GAEV,OAAO+G,EAAa/G,EAAM,GAAGM,GAE/B,IAAM+E,EAAQrF,EAAMM,EACpB,OAAOiF,EAAAA,EAAAA,IAAQF,GAAS0B,EAAa1B,EAAM,IAAM0B,EAAa1B,EAC/D,CAyBK,SAAU7F,EAAcD,EAAuBE,EAA+BC,GAClF,QADmD,IAAAD,IAAAA,GAAAA,QAA+B,IAAAC,IAAAA,GAAAA,IAC7EH,EAAO6D,QAA6B,IAAlB7D,EAAO6D,SAAiB1D,EAE7C,MAAO,GAGT,GAAID,EAAc,CAGhB,IADA,IAAM0H,EAAW,GACR1C,EAAI,EAAGQ,EAAM1F,EAAO6D,OAAQqB,EAAIQ,EAAKR,IAAK,CAE5CyC,EADClH,EAAQT,EAAOkF,KAEnB0C,EAAShH,KAAKH,EAEjB,CACD,MAAO,CAACmH,EACT,CAED,IAAMpH,EAAS,GACXqH,EAAM,GACV,IAAS3C,EAAI,EAAGQ,EAAM1F,EAAO6D,OAAQqB,EAAIQ,EAAKR,IAAK,CACjD,IAAMzE,EACFkH,EADElH,EAAQT,EAAOkF,IAEf2C,EAAIhE,UACe,IAAfgE,EAAIhE,QAAiB1D,IAEzBK,EAAOI,KAAKiH,GAEdA,EAAM,IAGRA,EAAIjH,KAAKH,EAEZ,CAKD,OAHIoH,EAAIhE,QACNrD,EAAOI,KAAKiH,GAEPrH,CACR,CAOK,SAAUsH,EAAc9H,GAE5B,IADA,IAAMI,EAAO,GACJ8E,EAAI,EAAGA,EAAIlF,EAAO6D,OAAQqB,IAAK,CACtC,IAAMzE,EAAQT,EAAOkF,GACrB,GAAIzE,EAAO,CACT,IAAMsH,EAAe,IAAN7C,EAAU,IAAM,IAC/B9E,EAAKQ,KAAK,CAACmH,EAAQtH,EAAMK,EAAGL,EAAMM,GACnC,CACF,CACD,IAAMiH,EAAQhI,EAAO,GAKrB,OAJIgI,IACF5H,EAAKQ,KAAK,CAAC,IAAKoH,EAAMlH,EAAGkH,EAAMjH,IAC/BX,EAAKQ,KAAK,CAAC,OAENR,CACR,CAOK,SAAU6H,EAAoBjI,GAIlC,IAHA,IAAMkI,EAAOlI,EAAO6D,OAAS,EACvBsE,EAAa,GACbC,EAAc,GACXlD,EAAI,EAAGA,EAAIlF,EAAO6D,OAAQqB,IAC7BA,EAAIgD,EACNC,EAAWvH,KAAKZ,EAAOkF,IAEvBkD,EAAYxH,KAAKZ,EAAOkF,IAG5B,IAAMmD,GAAWC,EAAAA,EAAAA,IAAcH,GAAY,GACrCI,GAAYD,EAAAA,EAAAA,IAAcF,GAAa,GACzCA,EAAYvE,QACdwE,EAASzH,KAAK,CAAC,IAAKwH,EAAY,GAAGtH,EAAGsH,EAAY,GAAGrH,IAEvDwH,EAAUC,QACV,IAAMpI,EAAOiI,EAAShH,OAAOkH,GAK7B,OAJIJ,EAAWtE,QACbzD,EAAKQ,KAAK,CAAC,IAAKuH,EAAW,GAAGrH,EAAGqH,EAAW,GAAGpH,IAEjDX,EAAKQ,KAAK,CAAC,MACJR,CACR,C,yGC3HK,SAAUqB,EAAS3B,EAAgB6E,EAAmB8D,EAAiBC,QAAA,IAAAA,IAAAA,EAAAA,IACnE,MAA0C5I,EAAG,MAA7CkD,OAAK,IAAG,GAAC,EAAC2F,EAAEC,EAA8B9I,EAAG,aAAnBgD,EAAgBhD,EAAG,MAAZ2D,EAAS3D,EAAG,KAC/C+B,GAAQ,oBACT+G,GACA5F,GAsBL,OApBIF,IACE6B,IACG3B,EAAME,SAETrB,EAAMqB,OAASJ,IAIf2F,IACGzF,EAAMQ,OAET3B,EAAM2B,KAAOV,KAIf4F,IAAYhC,EAAAA,EAAAA,IAAM1D,EAAM0F,OAAehC,EAAAA,EAAAA,IAAMjD,KAE/C5B,EAAM6G,GAAYjF,GAGb5B,CACR,CAMK,SAAUgH,EAAuB/I,GACrC,OAAOgJ,EAAAA,EAAAA,IACL,CAAC,EACD,CAEEtF,KAAM,UACNuF,YAAa,KAEfC,EAAAA,EAAAA,IAAIlJ,EAAK,CAAC,aAAc,UAE3B,C,yMChCD,SAASmJ,EAAYpC,EAAeqC,GAElC,IADA,IAAMrB,EAAM,CAAChB,EAAI,IACR3B,EAAI,EAAGQ,EAAMmB,EAAIhD,OAAQqB,EAAIQ,EAAKR,GAAQ,EAAG,CACpD,IAAMzE,EAAQyI,EAAMC,QAAQ,CAC1BrI,EAAG+F,EAAI3B,GACPnE,EAAG8F,EAAI3B,EAAI,KAEb2C,EAAIjH,KAAKH,EAAMK,EAAGL,EAAMM,EACzB,CACD,OAAO8G,CACR,CACD,SAASuB,EAAgBhJ,EAAmB8I,GAClC,IAAAG,EAAiBH,EAAK,aACxB5G,EAAIlC,EAAK,GACTU,EAAIV,EAAK,GACTW,EAAIX,EAAK,GACTK,EAAQyI,EAAMC,QAAQ,CAAErI,EAAC,EAAEC,EAAC,IAElC,MAAO,CAAC,IAAKuB,EAAGA,EAAG,EAAG,EADJ+G,EAAe,EAAI,EACD5I,EAAMK,EAAGL,EAAMM,EACpD,CAqKK,SAAUuI,EAAkBC,EAAeC,EAAYC,GAG3D,IAFA,IAAMC,IAAWF,EACXG,EAAY,GACTzE,EAAI,EAAG0E,EAAIL,EAAI1F,OAAQqB,EAAI0E,EAAG1E,GAAK,EAC1CyE,EAAU/I,KAAK,CAAC2I,EAAIrE,GAAIqE,EAAIrE,EAAI,KAGlC,IAII2E,EACAC,EACAC,EANEC,EA1GoB,SAC1BhK,EACAyC,EACAiH,EACAD,G,MAKIQ,EACAtJ,EACAgF,EACAM,EACAiE,EACAL,EACAM,EATEC,EAAM,GACNC,IAAkBZ,EAUxB,GAAIY,EAAe,CAChB1E,GAADgD,GAAAA,EAAAA,EAAAA,IAAac,EAAU,IAAnB,GAAExD,EAAG,KACT,IAAK,IAAIf,EAAI,EAAG0E,EAAI5J,EAAO6D,OAAQqB,EAAI0E,EAAG1E,IAAK,CAC7C,IAAMzE,EAAQT,EAAOkF,GACrBS,EAAM2E,EAAAA,GAAS,CAAC,EAAG,GAAI3E,EAAKlF,GAC5BwF,EAAMqE,EAAAA,GAAS,CAAC,EAAG,GAAIrE,EAAKxF,EAC7B,CACF,CAEQyE,EAAI,EAAb,IAAK,IAAWQ,EAAM1F,EAAO6D,OAAQqB,EAAIQ,EAAKR,IAE5C,GADMzE,EAAQT,EAAOkF,GACX,IAANA,GAAYwE,EAET,GAAIxE,IAAMQ,EAAM,GAAMgE,EAItB,CACLO,EAAYjK,EAAO0J,EAAUxE,EAAIA,EAAI,EAAIQ,EAAM,EAAKR,EAAI,GACxDvE,EAAYX,EAAO0J,GAAUxE,EAAI,GAAKQ,EAAMR,EAAI,GAEhD,IAAIqF,EAAsB,CAAC,EAAG,GAC9BA,EAAID,EAAAA,GAASC,EAAG5J,EAAWsJ,GAC3BM,EAAID,EAAAA,GAAWC,EAAGA,EAAG9H,GAErB,IAAI+H,EAAKF,EAAAA,GAAc7J,EAAOwJ,GAC1BQ,EAAKH,EAAAA,GAAc7J,EAAOE,GAExB+J,EAAMF,EAAKC,EACL,IAARC,IACFF,GAAME,EACND,GAAMC,GAGR,IAAIC,EAAKL,EAAAA,GAAW,CAAC,EAAG,GAAIC,GAAIC,GAC5BI,EAAKN,EAAAA,GAAW,CAAC,EAAG,GAAIC,EAAGE,GAE/BZ,EAAMS,EAAAA,GAAS,CAAC,EAAG,GAAI7J,EAAOkK,GAC9BT,EAAUI,EAAAA,GAAS,CAAC,EAAG,GAAI7J,EAAOmK,GAGlCV,EAAUI,EAAAA,GAAS,CAAC,EAAG,GAAIJ,EAASI,EAAAA,GAAS,CAAC,EAAG,GAAI3J,EAAWF,IAChEyJ,EAAUI,EAAAA,GAAS,CAAC,EAAG,GAAIJ,EAASI,EAAAA,GAAS,CAAC,EAAG,GAAI3J,EAAWF,IAGhEkK,EAAKL,EAAAA,GAAS,CAAC,EAAG,GAAIJ,EAASzJ,GAC/BkK,EAAKL,EAAAA,GAAW,CAAC,EAAG,GAAIK,GAAKH,EAAKC,GAClCZ,EAAMS,EAAAA,GAAS,CAAC,EAAG,GAAI7J,EAAOkK,GAG9Bd,EAAMS,EAAAA,GAAS,CAAC,EAAG,GAAIT,EAAKS,EAAAA,GAAS,CAAC,EAAG,GAAIL,EAAWxJ,IACxDoJ,EAAMS,EAAAA,GAAS,CAAC,EAAG,GAAIT,EAAKS,EAAAA,GAAS,CAAC,EAAG,GAAIL,EAAWxJ,IAGxDmK,EAAKN,EAAAA,GAAS,CAAC,EAAG,GAAI7J,EAAOoJ,GAC7Be,EAAKN,EAAAA,GAAW,CAAC,EAAG,GAAIM,EAAIH,EAAKD,GACjCN,EAAUI,EAAAA,GAAS,CAAC,EAAG,GAAI7J,EAAOmK,GAE9BP,IACFR,EAAMS,EAAAA,GAAS,CAAC,EAAG,GAAIT,EAAKlE,GAC5BkE,EAAMS,EAAAA,GAAS,CAAC,EAAG,GAAIT,EAAK5D,GAC5BiE,EAAUI,EAAAA,GAAS,CAAC,EAAG,GAAIJ,EAASvE,GACpCuE,EAAUI,EAAAA,GAAS,CAAC,EAAG,GAAIJ,EAASjE,IAGtCmE,EAAIxJ,KAAKuJ,GACTC,EAAIxJ,KAAKiJ,GACTM,EAAMD,CACP,MAtDCL,EAAMpJ,EACN2J,EAAIxJ,KAAKuJ,GACTC,EAAIxJ,KAAKiJ,QAJTM,EAAM1J,EA+DV,OAJIiJ,GACFU,EAAIxJ,KAAKwJ,EAAI5B,SAGR4B,CACR,CAa0BS,CAAalB,EAAW,GAAKD,EAAQD,GACxD/D,EAAMiE,EAAU9F,OAChB4G,EAAK,GAMX,IAASvF,EAAI,EAAGA,EAAIQ,EAAM,EAAGR,IAC3B2E,EAAMG,EAAqB,EAAJ9E,GACvB4E,EAAME,EAAqB,EAAJ9E,EAAQ,GAC/B6E,EAAIJ,EAAUzE,EAAI,GAElBuF,EAAG7J,KAAK,CAAC,IAAKiJ,EAAI,GAAIA,EAAI,GAAIC,EAAI,GAAIA,EAAI,GAAIC,EAAE,GAAIA,EAAE,KAUxD,OAPIL,IACFG,EAAMG,EAAiBtE,GACvBoE,EAAME,EAAiBtE,EAAM,GAC7BqE,EAAIJ,EAAU,GAEdc,EAAG7J,KAAK,CAAC,IAAKiJ,EAAI,GAAIA,EAAI,GAAIC,EAAI,GAAIA,EAAI,GAAIC,EAAE,GAAIA,EAAE,MAEjDU,CACR,CAMK,SAAUK,EAAY9K,EAAiB+K,GAC3C,OA/OF,SAAsB/K,EAAiB+K,GACrC,IAAM3K,EAAO,GACb,GAAIJ,EAAO6D,OAAQ,CACjBzD,EAAKQ,KAAK,CAAC,IAAKZ,EAAO,GAAGc,EAAGd,EAAO,GAAGe,IACvC,IAAK,IAAImE,EAAI,EAAG8F,EAAShL,EAAO6D,OAAQqB,EAAI8F,EAAQ9F,GAAK,EAAG,CAC1D,IAAM+F,EAAOjL,EAAOkF,GACpB9E,EAAKQ,KAAK,CAAC,IAAKqK,EAAKnK,EAAGmK,EAAKlK,GAC9B,CAEGgK,GACF3K,EAAKQ,KAAK,CAAC,KAEd,CAED,OAAOR,CACR,CAgOQ8K,CAAalL,EAAQ+K,EAC7B,CAMK,SAAUzC,EAActI,EAAiB+K,EAAsBI,GACnE,IAAMC,EAAO,GACPpD,EAAQhI,EAAO,GACjBqL,EAAW,KACf,GAAIrL,EAAO6D,QAAU,EAEnB,OAAOiH,EAAY9K,EAAQ+K,GAE7B,IAAK,IAAI7F,EAAI,EAAGQ,EAAM1F,EAAO6D,OAAQqB,EAAIQ,EAAKR,IAAK,CACjD,IAAMzE,EAAQT,EAAOkF,GAChBmG,GAAcA,EAASvK,IAAML,EAAMK,GAAKuK,EAAStK,IAAMN,EAAMM,IAChEqK,EAAKxK,KAAKH,EAAMK,GAChBsK,EAAKxK,KAAKH,EAAMM,GAChBsK,EAAW5K,EAEd,CACD,IAKM6K,EAAahC,EAAkB8B,EAAML,EALxBI,GAAa,CAE9B,CAAC,EAAG,GACJ,CAAC,EAAG,KAIN,OADAG,EAAWC,QAAQ,CAAC,IAAKvD,EAAMlH,EAAGkH,EAAMjH,IACjCuK,CACR,CAMK,SAAUE,EAAkBtC,EAAO9I,GACvC,IAAMyH,EAAM,GAkBZ,OAjBAxH,EAAAA,EAAAA,IAAKD,GAAM,SAACqL,GAEV,OADeA,EAAQ,GACRC,eACb,IAAK,IACL,IAAK,IACL,IAAK,IACH7D,EAAIjH,KAAKqI,EAAYwC,EAASvC,IAC9B,MACF,IAAK,IACHrB,EAAIjH,KAAKwI,EAAgBqC,EAASvC,IAClC,MAEF,QACErB,EAAIjH,KAAK6K,GAGd,IACM5D,CACR,CAMK,SAAU8D,EAAiBzC,EAAO9I,GACtC,IACIwL,EACAC,EACAC,EAHAjE,EAAM,GAqCV,OAhCAxH,EAAAA,EAAAA,IAAKD,GAAM,SAACqL,EAAS/K,GAGnB,OAFe+K,EAAQ,GAERC,eACb,IAAK,IACL,IAAK,IACL,IAAK,IACH7D,EAAIjH,KAAKqI,EAAYwC,EAASvC,IAC9B,MACF,IAAK,IACH0C,EAAMxL,EAAKM,EAAQ,GACnBmL,EAAMJ,EACNK,EAAa5C,EAAMG,cAEVyC,EAAaF,EAAIA,EAAI/H,OAAS,KAAOgI,EAAI,GAAKD,EAAIA,EAAI/H,OAAS,KAAOgI,EAAI,IAEjFhE,EAAMA,EAAIxG,OA9RpB,SAA2BuK,EAAkBC,EAAkB3C,GACrD,IAAAG,EAAuCH,EAAK,aAA9B6C,EAAyB7C,EAAK,WAAlB8C,EAAa9C,EAAK,SAC9CmC,EACqB,MAAzBO,EAAI,GAAGF,cACH,CACE5K,EAAG8K,EAAI,GACP7K,EAAG6K,EAAI,IAET,CACE9K,EAAG8K,EAAI,GACP7K,EAAG6K,EAAI,IAETK,EAAW,CACfnL,EAAG+K,EAAI,GACP9K,EAAG8K,EAAI,IAEHK,EAAM,GACNC,EAAO9C,EAAe,IAAM,IAC5B+C,EAAa5G,KAAKC,IAAIwG,EAASE,GAAQd,EAASc,KAAUH,EAAWD,GACrEM,EAAYJ,EAASE,IAASd,EAASc,GAAQ,EAAI,EACnDlH,EAAOmH,EAAa5G,KAAK8G,GAAK,EAAI,EAClCC,EAAerD,EAAMC,QAAQ8C,GAC7B3J,GAAIkK,EAAAA,EAAAA,IAAoBtD,EAAOqD,GACrC,GAAIjK,GAAK,GAEP,GAAI8J,IAAyB,EAAV5G,KAAK8G,GAAQ,CAC9B,IAAMG,EAAc,CAClB3L,GAAImL,EAASnL,EAAIuK,EAASvK,GAAK,EAC/BC,GAAIkL,EAASlL,EAAIsK,EAAStK,GAAK,GAE3B2L,EAAqBxD,EAAMC,QAAQsD,GACzCP,EAAItL,KAAK,CAAC,IAAK0B,EAAGA,EAAG,EAAG2C,EAAMoH,EAAWK,EAAmB5L,EAAG4L,EAAmB3L,IAClFmL,EAAItL,KAAK,CAAC,IAAK0B,EAAGA,EAAG,EAAG2C,EAAMoH,EAAWE,EAAazL,EAAGyL,EAAaxL,GACvE,MACCmL,EAAItL,KAAK,CAAC,IAAK0B,EAAGA,EAAG,EAAG2C,EAAMoH,EAAWE,EAAazL,EAAGyL,EAAaxL,IAG1E,OAAOmL,CACR,CAwP0BS,CAAkBf,EAAKC,EAAK3C,IAG7CrB,EAAIjH,KAAKqI,EAAYwC,EAASvC,IAEhC,MACF,IAAK,IACHrB,EAAIjH,KAAKwI,EAAgBqC,EAASvC,IAClC,MAEF,QACErB,EAAIjH,KAAK6K,GAGd,IAnQH,SAA8BrL,IAC5BC,EAAAA,EAAAA,IAAKD,GAAM,SAACqL,EAAS/K,GAEnB,GAA6B,MADjB+K,EACJ,GAAGC,cAAuB,CAChC,IAAME,EAAMxL,EAAKM,EAAQ,GACnBkM,EAAOxM,EAAKM,EAAQ,GACtBkM,GAAkC,MAA1BA,EAAK,GAAGlB,cACdE,GAAgC,MAAzBA,EAAI,GAAGF,gBAChBE,EAAI,GAAK,KAEFA,GAAgC,MAAzBA,EAAI,GAAGF,eACnBkB,GAAkC,MAA1BA,EAAK,GAAGlB,gBAClBkB,EAAK,GAAK,IAGf,CACF,GACF,CAmPCC,CAAqBhF,GACdA,CACR,C,uEC7UK,SAAUpD,EAAYqI,GAE1B,IAAMhM,EAAIgM,EAAIhM,EAGd,QAFUkF,EAAAA,EAAAA,IAAQ8G,EAAI/L,GAAK+L,EAAI/L,EAAI,CAAC+L,EAAI/L,IAE/BQ,KAAI,SAACwL,EAAOrM,GACnB,MAAO,CACLI,GAAGkF,EAAAA,EAAAA,IAAQlF,GAAKA,EAAEJ,GAASI,EAC3BC,EAAGgM,EAEN,GACF,C,wEChBDrL,EAAAA,EAAAA,IAAc,SAAU,SAAU,CAChCC,KAAA,SAAK7B,EAAgB8B,GACnB,IAAMC,GAAQJ,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GAC5BM,EAAOkD,KAAK0B,WAAU8C,EAAAA,EAAAA,IAAchI,EAAIE,SAC9C,OAAO4B,EAAUE,SAAS,OAAQ,CAChCD,OAAO,oBACFA,GAAK,CACRzB,KAAI,KAGT,EACD6B,UAAA,SAAUC,GAER,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLV,EAAG,EACHkB,KAAM,KACNN,OANchB,EAAS,OAS5B,KAMHR,EAAAA,EAAAA,IAAc,SAAU,gBAAiB,CACvCC,KAAA,SAAK7B,EAAgB8B,GACnB,IAAMC,GAAQJ,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GAC5BM,EAAOkD,KAAK0B,WAAUiD,EAAAA,EAAAA,IAAoBnI,EAAIE,SACpD,OAAO4B,EAAUE,SAAS,OAAQ,CAChCD,OAAO,oBACFA,GAAK,CACRzB,KAAI,KAGT,EACD6B,UAAA,SAAUC,GAER,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLV,EAAG,EACHkB,KAAM,KACNN,OANchB,EAAS,OAS5B,G,wEChDHR,EAAAA,EAAAA,IAAc,SAAU,SAAU,CAChCC,KAAA,SAAK7B,EAAgB8B,GACnB,IAAMC,GAAQJ,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GAC5BM,EAAOkD,KAAK0B,WAAUiD,EAAAA,EAAAA,IAAoBnI,EAAIE,SACpD,OAAO4B,EAAUE,SAAS,OAAQ,CAChCD,OAAO,oBACFA,GAAK,CACRzB,KAAI,KAGT,EACD6B,UAAA,SAAUC,GAER,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLE,OAAQ,KACRZ,EAAG,EACHkB,KANctB,EAAS,OAS5B,G,wBCxBG,SAAU8K,EAAKC,EAA8BC,GAMjD,IALA,IAAMC,EAAQ,GACRC,EAAU,GACVC,EAAU,GACVC,EAAc,IAAIC,IAEfrI,EAAI,EAAGA,EAAIgI,EAAKrJ,OAAQqB,IAAK,CACpC,IAAMsI,EAAMN,EAAKhI,GACb+H,EAAQO,GAAMJ,EAAQxM,KAAK4M,GAC1BL,EAAMvM,KAAK4M,GAChBF,EAAYG,IAAID,GAAK,EACtB,CAMD,OAJAE,OAAOR,KAAKD,GAASU,SAAQ,SAACH,GACvBF,EAAYM,IAAIJ,IAAMH,EAAQzM,KAAK4M,EACzC,IAEM,CACLL,MAAK,EACLC,QAAO,EACPC,QAAO,EAEV,C,iHCxBK,SAAUvJ,EAAMsH,EAAYyC,EAAkBC,G,QAClD,QADkD,IAAAA,IAAAA,EAAAA,CAAAA,IAC7CD,EACH,MAAO,CAACzC,GAEV,IAAM2C,GAASC,EAAAA,EAAAA,IAAW5C,EAAMyC,GAC1B9H,EAAQ,GACd,GAAsB,IAAlB8H,EAAOhK,QAAgBiK,EAAiBD,EAAO,IAAK,CACtD,IAAMI,EAASH,EAAiBD,EAAO,I,IACvC,IAAoB,eAAAI,GAAMC,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAAvB,IAAMpI,EAAK,QACRe,EAAMkH,EAAO,WAAIjI,IACnBe,GAEFd,EAAMnF,KAAKiG,EAEd,C,kGACF,MACC,IAAK,IAAMsH,KAAKJ,EACd,GAAIA,EAAOK,eAAeD,GAAI,CAC5B,IAAME,EAAYN,EAAOI,GACzBpI,EAAMnF,KAAKyN,EACZ,CAIL,OAAOtI,CACR,C,uECnBK,SAAUuI,EAAcC,EAAyBC,GACrD,OAAOC,EAAAA,EAAAA,GACL,CAAC,QAAS,QAAS,OAAQ,IAAK,IAAK,aAAc,OAAQ,QAAS,eAAgB,SAAU,gBAC9F,SAACjB,GACC,QAAQpI,EAAAA,EAAAA,IAAQmJ,EAAaf,GAAMgB,EAAShB,GAC7C,GAEJ,C,uECdK,SAAUkB,EAAYC,GAC1B,OAAI3I,EAAAA,EAAAA,IAAQ2I,GACHA,EAGFA,EAAMC,MAAM,IACpB,C,kFCyBK,SAAUC,EAAeC,GAC7B,IAAMC,EAAQD,EAASC,MACjBC,EAAaF,EAASE,WACtBC,EAASH,EAASI,YAClBC,EAAUF,EAAOhB,OACjBmB,EAAYN,EAASO,kBACvBC,EAAgBH,EAAQtL,OACtB0L,GAAmBC,EAAAA,EAAAA,IAAoBV,EAASE,YAE9CS,EAAkCX,EAAQ,gBAAzBY,EAAiBZ,EAAQ,aAE5Ca,EAAiBb,EAASa,gBAAkBZ,EAAMY,eAClDC,EAAiBd,EAASc,gBAAkBb,EAAMa,eAClDC,EAAmBf,EAASe,kBAAoBd,EAAMc,iBACtDC,EAAwBhB,EAASgB,uBAAyBf,EAAMe,sBAChEC,EAAiBjB,EAASiB,gBAAkBhB,EAAMgB,eAGxD,GAAId,EAAOe,UAAYb,EAAQtL,OAAS,EAAG,CAEzCsL,EAAQhI,OACR,IAAM8I,EAnDV,SAAyBpJ,EAAKqJ,GAC5B,IAAMZ,EAAQzI,EAAIhD,OACdsM,EAAYtJ,GACZuJ,EAAAA,EAAAA,IAASD,EAAU,MAErBA,EAAYtJ,EAAItF,KAAI,SAACgJ,GACnB,OAAO2F,EAAMG,UAAU9F,EACxB,KAGH,IADA,IAAI+F,EAAWH,EAAU,GAAKA,EAAU,GAC/BjL,EAAI,EAAGA,EAAIoK,EAAOpK,IAAK,CAC9B,IAAM2C,EAAMsI,EAAUjL,GAAKiL,EAAUjL,EAAI,GACrCoL,EAAWzI,IACbyI,EAAWzI,EAEd,CACD,OAAOyI,CACR,CAkCoBC,CAAgBpB,EAASF,GAC1CK,GAASL,EAAOhJ,IAAMgJ,EAAOtJ,KAAOsK,EAChCd,EAAQtL,OAASyL,IACnBA,EAAQH,EAAQtL,OAEnB,CAED,IAAM2M,EAAQvB,EAAOuB,MACjBC,EAAiB,EAAInB,EACrBoB,EAAK,GACL1B,EAAW2B,QAIXD,EAFE1B,EAAW3F,cAAgBiG,EAAQ,EAEhCQ,EAEAC,GAIHd,EAAOe,WACTS,GAAkBD,EAAM,GAAKA,EAAM,IAErCE,EAAKb,KAIFnJ,EAAAA,EAAAA,IAAM+I,IAAoBA,GAAmB,GAGhDgB,GAAkB,GAAKnB,EAAQ,IADGG,EAAkBF,IACaD,EAGjEmB,GAAkBC,EAGpB,GAAI5B,EAAS8B,UAAU,SAAU,CAC/B,IAEMC,EAvEV,SAAuBzB,EAAW0B,GAChC,GAAIA,EAAS,CACX,IAAMC,GAAYC,EAAAA,EAAAA,IAAQ5B,GAE1B,OADe6B,EAAAA,EAAAA,GAAYF,EAAWD,GACxBjN,MACf,CAED,OAAOuL,EAAUvL,MAClB,CA+DsBqN,CAAc9B,EAFbN,EAAS8B,UAAU,SACXE,SAE5B,KAAKpK,EAAAA,EAAAA,IAAMgJ,IAAiBA,GAAgB,EAG1Ce,GAAkBA,EADaf,EAAeH,GACesB,EAAa,IAAMA,QACtEnK,EAAAA,EAAAA,IAAM+I,IAAoBA,GAAmB,GAEvDgB,GAAkBC,EAClBD,GAAkCI,GAGlCJ,GAAkCI,EAEpCJ,EAAiBA,GAAkB,EAAIA,EAAiB,CACzD,CAGD,KAAK/J,EAAAA,EAAAA,IAAMiJ,IAAmBA,GAAkB,EAAG,CACjD,IAAMwB,EAA2BxB,EAAiBJ,EAC9CkB,EAAiBU,IACnBV,EAAiBU,EAEpB,CAGD,KAAKzK,EAAAA,EAAAA,IAAMkJ,IAAmBA,GAAkB,EAAG,CACjD,IAAMwB,EAA2BxB,EAAiBL,EAC9CkB,EAAiBW,IACnBX,EAAiBW,EAEpB,CAED,OAAOX,CACR,C,+JChH0BpM,EAAAA,EAAAA,IAAqB,SAAU,CACxDC,iBAAkB,SAClBC,iBAAA,SAAiBC,GACf,IAAM6M,EAAS7M,EAAUf,KAAO,EAC1BzD,EAAS,GACTsR,EAbV,SAAuBzK,GACrB,KAAKb,EAAAA,EAAAA,IAAQa,GACX,MAAO,GAET,IAAM0K,GAAWtL,EAAAA,EAAAA,IAAIY,GACrB,OAAOtF,EAAAA,EAAAA,IAAIsF,GAAK,SAAC2K,GAAQ,OAAAA,EAAMD,CAAQ,GACxC,CAOmBE,CAAcjN,EAAUkN,OAmBxC,OAjBArR,EAAAA,EAAAA,IAAKmE,EAAUzD,GAAe,SAACA,EAAGL,GAChC,IAAMiR,EAASL,EAAQ5Q,GAAS2Q,EAC1BO,EAAkB,IAAVlR,EACRmR,EAAQnR,IAAW8D,EAAUzD,EAAe8C,OAAS,EAC3D7D,EAAOY,KAAK,CACVgR,MAAK,EACLC,MAAK,EACL/Q,EAAI0D,EAAU1D,EAAe6Q,EAC7B5Q,EAAC,IAEHf,EAAOuL,QAAQ,CACbqG,MAAK,EACLC,MAAK,EACL/Q,EAAI0D,EAAU1D,EAAe6Q,EAC7B5Q,EAAC,GAEJ,IACMf,CACR,KAGH0B,EAAAA,EAAAA,IAAc,SAAU,SAAU,CAChCC,KAAA,SAAK7B,EAAgB8B,GACnB,IAAMmD,GAAatD,EAAAA,EAAAA,GAAS3B,GAAK,GAAM,GACjCM,EAAOkD,KAAK0B,WAAU8C,EAAAA,EAAAA,IAAchI,EAAIE,SAC9C,OAAO4B,EAAUE,SAAS,OAAQ,CAChCD,OAAO,oBACFkD,GAAU,CACb3E,KAAI,IAEN4B,KAAM,UAET,EACDC,UAAA,SAAUC,GAGR,MAAO,CACLa,OAAQ,SACRC,MAAO,CACLV,EAAG,EACHkB,KANctB,EAAS,OAS5B,IAGH,ICvDA,yE,OACkB4P,EAAAA,KAAe,SACfA,EAAAA,UAAoB,SAC1BA,EAAAA,gBAA0B,E,CA+CrC,CAAD,OAlDoCC,EAAAA,EAAAA,IAAAA,EAAAA,GAYxBC,EAAAA,UAAAA,qBAAV,SAA+BC,GAC7B,IAGIxO,EAHE3D,EAAMoS,EAAAA,UAAMC,qBAAoBC,KAAA,KAACH,GAIjCI,EAAW/O,KAAKgP,aAAa,QACnC,GAAID,EAAU,CACZ5O,EAAOH,KAAKiP,mBAAmBF,EAAUJ,GAAQ,GAEjD,IAAMjD,EAAa1L,KAAK0L,WAExBvL,IADwB+L,EAAAA,EAAAA,IAAoBR,EAE7C,MACM1L,KAAKkP,cACRlP,KAAKkP,aAAc3D,EAAAA,EAAAA,GAAevL,OAEpCG,EAAOH,KAAKkP,YAId,OAFA1S,EAAI2D,KAAOA,EACX3D,EAAI4R,OAAQ1I,EAAAA,EAAAA,IAAIiJ,EAAOQ,EAAAA,IAAe,CAACnP,KAAKoP,aACrC5S,CACR,EAKSkS,EAAAA,UAAAA,eAAV,WACU,IAAAW,EAAoBrP,KAAIqP,gBAC1BC,EAAYD,EAAgBlP,KAC9BkP,EAAgBlP,KAAKoK,OAAO,GAC5BvK,KAAKoP,WACLpP,KAAKoP,WACL,OACJpP,KAAKoP,WAAaE,SAEXD,EAAgBlP,KACvByO,EAAAA,UAAMW,eAAcT,KAAA,KACrB,EACH,CAAC,CAlDD,CAAoCU,EAAAA,G","sources":["../node_modules/@antv/g2/src/geometry/shape/line/step.ts","../node_modules/@antv/g2/src/geometry/shape/line/util.ts","../node_modules/@antv/g2/src/geometry/shape/point/hollow.ts","../node_modules/@antv/g2/src/geometry/shape/point/image.ts","../node_modules/@antv/g2/src/geometry/shape/point/index.ts","../node_modules/@antv/g2/src/geometry/shape/point/solid.ts","../node_modules/@antv/g2/src/geometry/shape/point/util.ts","../node_modules/@antv/g2/src/geometry/shape/polygon/index.ts","../node_modules/@antv/g2/src/geometry/shape/polygon/square.ts","../node_modules/@antv/g2/src/geometry/shape/schema/box.ts","../node_modules/@antv/g2/src/geometry/shape/schema/candle.ts","../node_modules/@antv/g2/src/geometry/shape/schema/index.ts","../node_modules/@antv/g2/src/geometry/shape/util/get-path-points.ts","../node_modules/@antv/g2/src/geometry/shape/util/get-style.ts","../node_modules/@antv/g2/src/geometry/shape/util/path.ts","../node_modules/@antv/g2/src/geometry/shape/util/split-points.ts","../node_modules/@antv/g2/src/geometry/shape/violin/hollow.ts","../node_modules/@antv/g2/src/geometry/shape/violin/smooth.ts","../node_modules/@antv/g2/src/geometry/util/diff.ts","../node_modules/@antv/g2/src/geometry/util/group-data.ts","../node_modules/@antv/g2/src/geometry/util/is-model-change.ts","../node_modules/@antv/g2/src/geometry/util/parse-fields.ts","../node_modules/@antv/g2/src/geometry/util/shape-size.ts","../node_modules/@antv/g2/src/geometry/shape/violin/index.ts","../node_modules/@antv/g2/src/geometry/violin.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLineMarker } from './util';\n\nconst interpolateCallback = (point: Point, nextPoint: Point, shapeType: string) => {\n  const x = point.x as number;\n  const y = point.y as number;\n  const nextX = nextPoint.x as number;\n  const nextY = nextPoint.y as number;\n  let result;\n\n  switch (shapeType) {\n    case 'hv':\n      result = [{ x: nextX, y }];\n      break;\n    case 'vh':\n      result = [{ x, y: nextY }];\n      break;\n    case 'hvh':\n      const middleX = (nextX + x) / 2;\n      result = [\n        { x: middleX, y },\n        { x: middleX, y: nextY },\n      ];\n      break;\n    case 'vhv':\n      const middleY = (y + nextY) / 2;\n      result = [\n        { x, y: middleY },\n        { x: nextX, y: middleY },\n      ];\n      break;\n    default:\n      break;\n  }\n\n  return result;\n};\n\nfunction getInterpolatePoints(points: Point[], shapeType: string) {\n  let result = [];\n  each(points, (point: Point, index) => {\n    const nextPoint = points[index + 1];\n    result.push(point);\n    if (nextPoint) {\n      const interpolatePoint = interpolateCallback(point, nextPoint, shapeType);\n      result = result.concat(interpolatePoint);\n    }\n  });\n  return result;\n}\n\n// 插值的图形path，不考虑null\nfunction getInterpolatePath(points: Point[]) {\n  return points.map((point, index) => {\n    return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];\n  });\n}\n\n// 插值的图形\nfunction getInterpolateShapeAttrs(cfg: ShapeInfo, shapeType: string) {\n  const points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint); // 根据 connectNulls 值处理 points\n  let path = [];\n  each(points, (eachLinePoints) => {\n    const interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);\n    path = path.concat(getInterpolatePath(interpolatePoints));\n  });\n\n  return {\n    ...getStyle(cfg, true, false, 'lineWidth'),\n    path,\n  };\n}\n\n// step line\neach(['hv', 'vh', 'hvh', 'vhv'], (shapeType) => {\n  registerShape('line', shapeType, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      const attrs = getInterpolateShapeAttrs(cfg, shapeType);\n      const shape = container.addShape({\n        type: 'path',\n        attrs,\n        name: 'line',\n      });\n\n      return shape;\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    },\n  });\n});\n","import { ShapeMarkerCfg } from '../../../interface';\n\nconst LineSymbols = {\n  line: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y],\n      ['L', x + r, y],\n    ];\n  },\n  dot: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y],\n      ['L', x + r, y],\n    ];\n  },\n  dash: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y],\n      ['L', x + r, y],\n    ];\n  },\n  smooth: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y],\n      ['A', r / 2, r / 2, 0, 1, 1, x, y],\n      ['A', r / 2, r / 2, 0, 1, 0, x + r, y],\n    ];\n  },\n  hv: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r - 1, y - 2.5],\n      ['L', x, y - 2.5],\n      ['L', x, y + 2.5],\n      ['L', x + r + 1, y + 2.5],\n    ];\n  },\n  vh: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r - 1, y + 2.5],\n      ['L', x, y + 2.5],\n      ['L', x, y - 2.5],\n      ['L', x + r + 1, y - 2.5],\n    ];\n  },\n  hvh: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - (r + 1), y + 2.5],\n      ['L', x - r / 2, y + 2.5],\n      ['L', x - r / 2, y - 2.5],\n      ['L', x + r / 2, y - 2.5],\n      ['L', x + r / 2, y + 2.5],\n      ['L', x + r + 1, y + 2.5],\n    ];\n  },\n  vhv: (x: number, y: number) => {\n    // 宽 13px，高 8px\n    return [\n      ['M', x - 5, y + 2.5],\n      ['L', x - 5, y],\n      ['L', x, y],\n      ['L', x, y - 3],\n      ['L', x, y + 3],\n      ['L', x + 6.5, y + 3],\n    ];\n  },\n};\n\n/**\n * Gets line marker\n * @ignore\n * @param markerCfg\n * @param shapeType\n * @returns 返回 Line 的 marker 配置\n */\nexport function getLineMarker(markerCfg: ShapeMarkerCfg, shapeType: string) {\n  const { color } = markerCfg;\n  return {\n    symbol: LineSymbols[shapeType],\n    style: {\n      lineWidth: 2,\n      r: 6,\n      stroke: color,\n    },\n  };\n}\n","import { each } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { MarkerSymbols } from '../../../util/marker';\nimport { registerShape } from '../base';\nimport { drawPoints, HOLLOW_SHAPES } from './util';\n\n// 添加 hollowShape\neach(HOLLOW_SHAPES, (shapeName: string) => {\n  registerShape('point', shapeName, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      return drawPoints(this, cfg, container, shapeName, true);\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      const { color } = markerCfg;\n      return {\n        symbol: MarkerSymbols[shapeName],\n        style: {\n          r: 4.5,\n          stroke: color,\n          fill: null,\n        },\n      };\n    },\n  });\n});\n","import { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\n\nregisterShape('point', 'image', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const { r: size } = getStyle(cfg, false, false, 'r');\n    const points = this.parsePoints(cfg.points);\n    let pointPosition = points[0];\n    if (cfg.isStack) {\n      pointPosition = points[1];\n    } else if (points.length > 1) {\n      const group = container.addGroup();\n      for (const point of points) {\n        group.addShape('image', {\n          attrs: {\n            x: (point.x as number) - size / 2,\n            y: (point.y as number) - size,\n            width: size,\n            height: size,\n            img: cfg.shape[1],\n          },\n        });\n      }\n\n      return group;\n    }\n\n    return container.addShape('image', {\n      attrs: {\n        x: (pointPosition.x as number) - size / 2,\n        y: (pointPosition.y as number) - size,\n        width: size,\n        height: size,\n        img: cfg.shape[1],\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4.5,\n        fill: color,\n      },\n    };\n  },\n});\n","import { each } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { MarkerSymbols } from '../../../util/marker';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { splitPoints } from '../util/split-points';\nimport { drawPoints, SHAPES } from './util';\n\nconst PointShapeFactory = registerShapeFactory('point', {\n  defaultShapeType: 'hollow-circle',\n  getDefaultPoints(pointInfo: ShapePoint): Point[] {\n    return splitPoints(pointInfo);\n  },\n});\n\neach(SHAPES, (shapeName: string) => {\n  // 添加该 shape 对应的 hollow-shape\n  registerShape('point', `hollow-${shapeName}`, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      return drawPoints(this, cfg, container, shapeName, true);\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      const { color } = markerCfg;\n      return {\n        symbol: MarkerSymbols[shapeName] || shapeName,\n        style: {\n          r: 4.5,\n          stroke: color,\n          fill: null,\n        },\n      };\n    },\n  });\n});\n\nexport default PointShapeFactory;\n","import { each } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { MarkerSymbols } from '../../../util/marker';\nimport { registerShape } from '../base';\nimport { drawPoints, SHAPES } from './util';\n\n// 所有的 SHAPES 都注册一下\neach(SHAPES, (shapeName: string) => {\n  registerShape('point', shapeName, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      return drawPoints(this, cfg, container, shapeName, false);\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      const { color } = markerCfg;\n      return {\n        symbol: MarkerSymbols[shapeName] || shapeName,\n        style: {\n          r: 4.5,\n          fill: color,\n        },\n      };\n    },\n  });\n});\n","import { IGroup, IShape } from '../../../dependents';\nimport { ShapeInfo } from '../../../interface';\nimport { MarkerSymbols } from '../../../util/marker';\nimport { getStyle } from '../util/get-style';\n\nexport const SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];\nexport const HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line'];\n\n/**\n * @ignore\n * Draws points\n * @param shape\n * @param cfg\n * @param container\n * @param shapeName\n * @param isStroke\n * @returns points\n */\nexport function drawPoints(\n  shape,\n  cfg: ShapeInfo,\n  container: IGroup,\n  shapeName: string,\n  isStroke: boolean\n): IShape | IGroup {\n  const style = getStyle(cfg, isStroke, !isStroke, 'r');\n  const points = shape.parsePoints(cfg.points);\n  let pointPosition = points[0];\n  if (cfg.isStack) {\n    pointPosition = points[1];\n  } else if (points.length > 1) {\n    const group = container.addGroup();\n    for (const point of points) {\n      group.addShape({\n        type: 'marker',\n        attrs: {\n          ...style,\n          symbol: MarkerSymbols[shapeName] || shapeName,\n          ...point,\n        },\n      });\n    }\n    return group;\n  }\n\n  return container.addShape({\n    type: 'marker',\n    attrs: {\n      ...style,\n      symbol: MarkerSymbols[shapeName] || shapeName,\n      ...pointPosition,\n    },\n  });\n}\n","import { each, isEmpty, isEqual, last } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getStyle } from '../util/get-style';\n\nfunction getPath(points: any[]) {\n  let flag: any = points[0];\n  let i = 1;\n\n  const path = [['M', flag.x, flag.y]];\n\n  while (i < points.length) {\n    const c: any = points[i];\n    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {\n      path.push(['L', c.x, c.y]);\n      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {\n        flag = points[i + 1];\n        path.push(['Z']);\n        path.push(['M', flag.x, flag.y]);\n        i++;\n      }\n    }\n    i++;\n  }\n\n  if (!isEqual(last(path), flag)) {\n    path.push(['L', flag.x, flag.y]);\n  }\n\n  path.push(['Z']);\n\n  return path;\n}\n\nconst PolygonShapeFactory = registerShapeFactory('polygon', {\n  defaultShapeType: 'polygon',\n  getDefaultPoints(pointInfo: ShapePoint) {\n    const points = [];\n    each(pointInfo.x as number[], (subX, index) => {\n      const subY = pointInfo.y[index];\n      points.push({\n        x: subX,\n        y: subY,\n      });\n    });\n    return points;\n  },\n});\n\nregisterShape('polygon', 'polygon', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    if (!isEmpty(cfg.points)) {\n      const shapeAttrs = getStyle(cfg, true, true);\n      const path = this.parsePath(getPath(cfg.points));\n      return container.addShape('path', {\n        attrs: {\n          ...shapeAttrs,\n          path,\n        },\n        name: 'polygon',\n      });\n    }\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'square',\n      style: {\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n\nexport default PolygonShapeFactory;\n","import { isEmpty, clamp } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\n\nfunction getRectAttrs(points: any[], size: number) {\n  const width = Math.abs(points[0].x - points[2].x);\n  const height = Math.abs(points[0].y - points[2].y);\n\n  let len = Math.min(width, height);\n  if (size) {\n    len = clamp(size, 0, Math.min(width, height));\n  }\n  len = len / 2;\n  const centerX = (points[0].x + points[2].x) / 2;\n  const centerY = (points[0].y + points[2].y) / 2;\n\n  return {\n    x: centerX - len,\n    y: centerY - len,\n    width: len * 2,\n    height: len * 2,\n  };\n}\n\nregisterShape('polygon', 'square', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    if (!isEmpty(cfg.points)) {\n      const shapeAttrs = getStyle(cfg, true, true);\n      const points = this.parsePoints(cfg.points); // 转换为画布坐标\n      return container.addShape('rect', {\n        attrs: {\n          ...shapeAttrs,\n          ...getRectAttrs(points, cfg.size), // 获取 rect 绘图信息\n        },\n        name: 'polygon',\n      });\n    }\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'square',\n      style: {\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n","import { isArray, isNil } from '@antv/util';\nimport { IGroup, PathCommand } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\n\nfunction parseValue(value: number[]) {\n  const array = !isArray(value) ? [value] : value;\n\n  const min = array[0]; // 最小值\n  const max = array[array.length - 1]; // 最大值\n  const min1 = array.length > 1 ? array[1] : min;\n  const max1 = array.length > 3 ? array[3] : max;\n  const median = array.length > 2 ? array[2] : min1;\n\n  return {\n    min, // 最小值\n    max, // 最大值\n    min1,\n    max1,\n    median,\n  };\n}\n\nfunction getBoxPoints(x: number | number[], y: number | number[], size: number): Point[] {\n  const halfSize = size / 2;\n  let pointsArray;\n  if (isArray(y)) {\n    // 2维\n    const { min, max, median, min1, max1 } = parseValue(y);\n    const minX = (x as number) - halfSize;\n    const maxX = (x as number) + halfSize;\n    pointsArray = [\n      [minX, max],\n      [maxX, max],\n      [x as number, max],\n      [x as number, max1],\n      [minX, min1],\n      [minX, max1],\n      [maxX, max1],\n      [maxX, min1],\n      [x as number, min1],\n      [x as number, min],\n      [minX, min],\n      [maxX, min],\n      [minX, median],\n      [maxX, median],\n    ];\n  } else {\n    // 只有一个维度\n    y = isNil(y) ? 0.5 : y;\n    const { min, max, median, min1, max1 } = parseValue(x as number[]);\n    const minY = y - halfSize;\n    const maxY = y + halfSize;\n    pointsArray = [\n      [min, minY],\n      [min, maxY],\n      [min, y],\n      [min1, y],\n      [min1, minY],\n      [min1, maxY],\n      [max1, maxY],\n      [max1, minY],\n      [max1, y],\n      [max, y],\n      [max, minY],\n      [max, maxY],\n      [median, minY],\n      [median, maxY],\n    ];\n  }\n\n  return pointsArray.map((arr) => {\n    return {\n      x: arr[0],\n      y: arr[1],\n    };\n  });\n}\n\nfunction getBoxPath(points): PathCommand[] {\n  return [\n    ['M', points[0].x, points[0].y],\n    ['L', points[1].x, points[1].y],\n    ['M', points[2].x, points[2].y],\n    ['L', points[3].x, points[3].y],\n    ['M', points[4].x, points[4].y],\n    ['L', points[5].x, points[5].y],\n    ['L', points[6].x, points[6].y],\n    ['L', points[7].x, points[7].y],\n    ['L', points[4].x, points[4].y], // 封闭 z\n    ['Z'],\n    ['M', points[8].x, points[8].y],\n    ['L', points[9].x, points[9].y],\n    ['M', points[10].x, points[10].y],\n    ['L', points[11].x, points[11].y],\n    ['M', points[12].x, points[12].y],\n    ['L', points[13].x, points[13].y],\n  ];\n}\n\n// box shape\nregisterShape('schema', 'box', {\n  getPoints(shapePoint: ShapePoint) {\n    const { x, y, size } = shapePoint;\n    return getBoxPoints(x as number, y as number[], size);\n  },\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false);\n    const path = this.parsePath(getBoxPath(cfg.points));\n    const shape = container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n        name: 'schema',\n      },\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol(x: number, y: number, r: number) {\n        const yValues = [y - 6, y - 3, y, y + 3, y + 6];\n        const points = getBoxPoints(x, yValues, r);\n        return [\n          ['M', points[0].x + 1, points[0].y],\n          ['L', points[1].x - 1, points[1].y],\n          ['M', points[2].x, points[2].y],\n          ['L', points[3].x, points[3].y],\n          ['M', points[4].x, points[4].y],\n          ['L', points[5].x, points[5].y],\n          ['L', points[6].x, points[6].y],\n          ['L', points[7].x, points[7].y],\n          ['L', points[4].x, points[4].y],\n          ['Z'],\n          ['M', points[8].x, points[8].y],\n          ['L', points[9].x, points[9].y],\n          ['M', points[10].x + 1, points[10].y],\n          ['L', points[11].x - 1, points[11].y],\n          ['M', points[12].x, points[12].y],\n          ['L', points[13].x, points[13].y],\n        ];\n      },\n      style: {\n        r: 6,\n        lineWidth: 1,\n        stroke: color,\n      },\n    };\n  },\n});\n","import { isArray } from '@antv/util';\nimport { IGroup, PathCommand } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { padEnd } from '../../../util/helper';\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\n\nfunction getCandleYValues(value: number | number[]) {\n  const array = !isArray(value) ? [value] : value;\n  // 从大到小排序\n  const sorted = array.sort((a, b) => b - a);\n  return padEnd(sorted, 4, sorted[sorted.length - 1]);\n}\n\n// get candle shape's key points\nfunction getCandlePoints(x: number, y: number[], size: number): Point[] {\n  const yValues = getCandleYValues(y);\n  return [\n    { x, y: yValues[0] },\n    { x, y: yValues[1] },\n    { x: x - size / 2, y: yValues[2] },\n    { x: x - size / 2, y: yValues[1] },\n    { x: x + size / 2, y: yValues[1] },\n    { x: x + size / 2, y: yValues[2] },\n    { x, y: yValues[2] },\n    { x, y: yValues[3] },\n  ];\n}\n\nfunction getCandlePath(points): PathCommand[] {\n  return [\n    ['M', points[0].x, points[0].y],\n    ['L', points[1].x, points[1].y],\n    ['M', points[2].x, points[2].y],\n    ['L', points[3].x, points[3].y],\n    ['L', points[4].x, points[4].y],\n    ['L', points[5].x, points[5].y],\n    ['Z'],\n    ['M', points[6].x, points[6].y],\n    ['L', points[7].x, points[7].y],\n  ];\n}\n\n// k line shape\nregisterShape('schema', 'candle', {\n  getPoints(shapePoint: ShapePoint) {\n    const { x, y, size } = shapePoint;\n    return getCandlePoints(x as number, y as number[], size);\n  },\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, true);\n    const path = this.parsePath(getCandlePath(cfg.points));\n    const shape = container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n        name: 'schema',\n      },\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol(x: number, y: number, r: number) {\n        const yValues = [y + 7.5, y + 3, y - 3, y - 7.5];\n        const points = getCandlePoints(x, yValues, r);\n        return [\n          ['M', points[0].x, points[0].y],\n          ['L', points[1].x, points[1].y],\n          ['M', points[2].x, points[2].y],\n          ['L', points[3].x, points[3].y],\n          ['L', points[4].x, points[4].y],\n          ['L', points[5].x, points[5].y],\n          ['Z'],\n          ['M', points[6].x, points[6].y],\n          ['L', points[7].x, points[7].y],\n        ];\n      },\n      style: {\n        lineWidth: 1,\n        stroke: color,\n        fill: color,\n        r: 6,\n      },\n    };\n  },\n});\n","import { registerShapeFactory } from '../base';\n\nconst SchemaShapeFactory = registerShapeFactory('schema', {\n  defaultShapeType: '', // 'schema' is for some custom shapes, so will not specify defaultShapeType\n});\n\nexport default SchemaShapeFactory;\n","import { isArray } from '@antv/util';\nimport { PathCommand } from '../../../dependents';\nimport { Point, RangePoint, ShapeVertices } from '../../../interface';\nimport { getSplinePath } from './path';\n\nfunction isValueEmpty(value) {\n  if (value) {\n    return false;\n  }\n  return value === null || value === undefined || isNaN(value);\n}\n\nfunction isYNil(point: Point[] | RangePoint) {\n  if (isArray(point)) {\n    // 特殊处理 area 的关键点数据，其关键点结构为 [{x: 0, y: 1}, {x: 0, y: 2}]\n    return isValueEmpty(point[1].y);\n  }\n  const value = point.y;\n  return isArray(value) ? isValueEmpty(value[0]) : isValueEmpty(value);\n}\n\n/**\n * @ignore\n * 分割数据，用于处理在一组点数据中，y 对应的数值存在 null/undefined/NaN 的情况\n * 应用于折线图、区域图以及路径图\n *\n * ```typescript\n * // return [[{x: 1, y: 2}, {x: 3, y: 3}]]\n * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], true);\n * // return [[{x: 1, y: 2}], [{x: 3, y: 3}]]\n * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], false);\n * // return [[[{ x: 1, y: 10 }, { x: 2, y: 2 }], [{ x: 9, y: 34 }, { x: 1, y: 1 }]]]\n * getPathPoints([\n *   [{ x: 1, y: 10 }, { x: 2, y: 2 }],\n *   [{ x: 4, y: 2 }, { x: 8, y: NaN }],\n *   [{ x: 9, y: 34 }, { x: 1, y: 1 }],\n * ], true);\n * ```\n *\n * @param points 要进行处理点集合\n * @param connectNulls 是否连接空值数据\n * @param showSinglePoint 是否展示孤立点\n * @returns 返回处理后的点集合\n */\nexport function getPathPoints(points: ShapeVertices, connectNulls: boolean = false, showSinglePoint: boolean = true) {\n  if (!points.length || (points.length === 1 && !showSinglePoint)) {\n    // 空或者只有一个点并配置不展示时\n    return [];\n  }\n\n  if (connectNulls) {\n    // 即 y 值为空的场景\n    const filtered = [];\n    for (let i = 0, len = points.length; i < len; i++) {\n      const point = points[i];\n      if (!isYNil(point)) {\n        filtered.push(point);\n      }\n    }\n    return [filtered];\n  }\n\n  const result = [];\n  let tmp = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (isYNil(point)) {\n      if (tmp.length) {\n        if (!(tmp.length === 1 && !showSinglePoint)) {\n          // 如果前段数据只有一个字段并且不需要展示时则不加入\n          result.push(tmp);\n        }\n        tmp = [];\n      }\n    } else {\n      tmp.push(point);\n    }\n  }\n\n  if (tmp.length) {\n    result.push(tmp);\n  }\n  return result;\n}\n\n/**\n * 获取小提琴图的边界 path\n * @param points\n * @returns\n */\nexport function getViolinPath(points: ShapeVertices): PathCommand[] {\n  const path = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i] as Point;\n    if (point) {\n      const action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n  const first = points[0] as Point;\n  if (first) {\n    path.push(['L', first.x, first.y]);\n    path.push(['z']);\n  }\n  return path;\n}\n\n/**\n * 获取小提琴图 平滑的边界 path\n * @param points\n * @returns\n */\nexport function getSmoothViolinPath(points: ShapeVertices): PathCommand[] {\n  const half = points.length / 2;\n  const leftPoints = [];\n  const rightPoints = [];\n  for (let i = 0; i < points.length; i++) {\n    if (i < half) {\n      leftPoints.push(points[i]);\n    } else {\n      rightPoints.push(points[i]);\n    }\n  }\n  const leftPath = getSplinePath(leftPoints, false);\n  const rightPath = getSplinePath(rightPoints, false);\n  if (rightPoints.length) {\n    leftPath.push(['L', rightPoints[0].x, rightPoints[0].y]);\n  }\n  rightPath.shift();\n  const path = leftPath.concat(rightPath);\n  if (leftPoints.length) {\n    path.push(['L', leftPoints[0].x, leftPoints[0].y]);\n  }\n  path.push(['z']);\n  return path;\n}\n","import { deepMix, isNil, get } from '@antv/util';\nimport { ShapeInfo } from '../../../interface';\n\n/**\n * @ignore\n * 获取 Shape 的图形属性\n * @param cfg\n * @param isStroke 是否需要描边\n * @param isFill 是否需要填充\n * @param [sizeName] 可选，表示图形大小的属性，lineWidth 或者 r\n * @returns\n */\nexport function getStyle(cfg: ShapeInfo, isStroke: boolean, isFill: boolean, sizeName: string = '') {\n  const { style = {}, defaultStyle, color, size } = cfg;\n  const attrs = {\n    ...defaultStyle,\n    ...style,\n  };\n  if (color) {\n    if (isStroke) {\n      if (!style.stroke) {\n        // 如果用户在 style() 中配置了 stroke，则以用户配置的为准\n        attrs.stroke = color;\n      }\n    }\n\n    if (isFill) {\n      if (!style.fill) {\n        // 如果用户在 style() 中配置了 fill\n        attrs.fill = color;\n      }\n    }\n  }\n  if (sizeName && isNil(style[sizeName]) && !isNil(size)) {\n    // 如果用户在 style() 中配置了 lineWidth 或者 r 属性\n    attrs[sizeName] = size;\n  }\n\n  return attrs;\n}\n\n/**\n * 获取 矩形背景 的样式\n * @param cfg\n */\nexport function getBackgroundRectStyle(cfg?: ShapeInfo) {\n  return deepMix(\n    {},\n    {\n      // 默认背景色，copy from active-region\n      fill: '#CCD6EC',\n      fillOpacity: 0.3,\n    },\n    get(cfg, ['background', 'style'])\n  );\n}\n","import { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position } from '../../../interface';\nimport { getDistanceToCenter } from '../../../util/coordinate';\n\nfunction _points2path(points: Point[], isInCircle: boolean): PathCommand[] {\n  const path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (let i = 1, length = points.length; i < length; i += 1) {\n      const item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n\nfunction _convertArr(arr: number[], coord: Coordinate): any[] {\n  const tmp = [arr[0]];\n  for (let i = 1, len = arr.length; i < len; i = i + 2) {\n    const point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1],\n    });\n    tmp.push(point.x, point.y);\n  }\n  return tmp;\n}\nfunction _convertArcPath(path: PathCommand, coord: Coordinate): any[] {\n  const { isTransposed } = coord;\n  const r = path[1];\n  const x = path[6];\n  const y = path[7];\n  const point = coord.convert({ x, y });\n  const direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\n\nfunction _convertPolarPath(pre: PathCommand, cur: PathCommand, coord: Coordinate): PathCommand[] {\n  const { isTransposed, startAngle, endAngle } = coord;\n  const prePoint =\n    pre[0].toLowerCase() === 'a'\n      ? {\n          x: pre[6],\n          y: pre[7],\n        }\n      : {\n          x: pre[1],\n          y: pre[2],\n        };\n  const curPoint = {\n    x: cur[1],\n    y: cur[2],\n  };\n  const rst = [];\n  const xDim = isTransposed ? 'y' : 'x';\n  const angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  const direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n  const flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n  const convertPoint = coord.convert(curPoint);\n  const r = getDistanceToCenter(coord, convertPoint);\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      const middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2,\n      };\n      const middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n  return rst;\n}\n\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path: PathCommand[]) {\n  each(path, (subPath, index) => {\n    const cur = subPath;\n    if (cur[0].toLowerCase() === 'a') {\n      const pre = path[index - 1];\n      const next = path[index + 1];\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport const smoothBezier = (\n  points: Position[],\n  smooth: number,\n  isLoop: boolean,\n  constraint: Position[]\n): Position[] => {\n  const cps = [];\n  const hasConstraint = !!constraint;\n\n  let prevPoint: Position;\n  let nextPoint: Position;\n  let min: Position;\n  let max: Position;\n  let nextCp0: Position;\n  let cp1: Position;\n  let cp0: Position;\n\n  if (hasConstraint) {\n    [min, max] = constraint;\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      min = vec2.min([0, 0], min, point) as [number, number];\n      max = vec2.max([0, 0], max, point) as [number, number];\n    }\n  }\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      prevPoint = points[isLoop ? (i ? i - 1 : len - 1) : i - 1];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n\n      let v: [number, number] = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint) as [number, number];\n      v = vec2.scale(v, v, smooth) as [number, number];\n\n      let d0 = vec2.distance(point, prevPoint);\n      let d1 = vec2.distance(point, nextPoint);\n\n      const sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n\n      let v1 = vec2.scale([0, 0], v, -d0);\n      let v2 = vec2.scale([0, 0], v, d1);\n\n      cp1 = vec2.add([0, 0], point, v1) as Position;\n      nextCp0 = vec2.add([0, 0], point, v2) as Position;\n\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point)) as Position;\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point)) as Position;\n\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1) as Position;\n\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point)) as Position;\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point)) as Position;\n\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2) as Position;\n\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min) as Position;\n        cp1 = vec2.min([0, 0], cp1, max) as Position;\n        nextCp0 = vec2.max([0, 0], nextCp0, min) as Position;\n        nextCp0 = vec2.min([0, 0], nextCp0, max) as Position;\n      }\n\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n};\n\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp: number[], z: boolean, constraint: Position[]): PathCommand[] {\n  const isLoop = !!z;\n  const pointList = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1 = [];\n\n  let cp1: Position;\n  let cp2: Position;\n  let p: Position;\n\n  for (let i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\n/**\n * @ignore\n * 将点连接成路径 path\n */\nexport function getLinePath(points: Point[], isInCircle?: boolean): PathCommand[] {\n  return _points2path(points, isInCircle);\n}\n\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points: Point[], isInCircle?: boolean, constaint?: Position[]): PathCommand[] {\n  const data = [];\n  const first = points[0];\n  let prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  const constraint = constaint || [\n    // 范围\n    [0, 0],\n    [1, 1],\n  ];\n  const splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\nexport function convertNormalPath(coord, path: PathCommand[]): PathCommand[] {\n  const tmp = [];\n  each(path, (subPath) => {\n    const action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\nexport function convertPolarPath(coord, path: PathCommand[]): PathCommand[] {\n  let tmp = [];\n  let pre: PathCommand;\n  let cur: PathCommand;\n  let transposed: boolean;\n  let equals: boolean;\n  each(path, (subPath, index) => {\n    const action = subPath[0];\n\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed;\n        // 是否半径相同，转换成圆弧\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n  return tmp;\n}\n","import { isArray } from '@antv/util';\nimport { Point, RangePoint } from '../../../interface';\n\n/**\n * @ignore\n * 拆分点数据\n * @example\n * // result: [{x: 20, y: 20}, {x: 20, y: 30}]\n * splitPoints({x: 20,y: [20, 30]});\n * @example\n * // result: [{x: 20, y: 20}, {x: 30, y: 30}]\n * splitPoints({x: [20, 30],y: [20, 30]});\n * @param obj\n */\nexport function splitPoints(obj: RangePoint): Point[] {\n  // y 有可能是数组，对应原始数据中 y 为一个区间数据，如 [19, 30]，为了统一也将 x 转换为数组\n  const x = obj.x;\n  const y = isArray(obj.y) ? obj.y : [obj.y];\n\n  return y.map((eachY, index) => {\n    return {\n      x: isArray(x) ? x[index] : x,\n      y: eachY,\n    };\n  });\n}\n","import { IGroup, Point } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\nimport { registerShape } from '../base';\nimport { getSmoothViolinPath, getViolinPath } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\n\n/**\n * 空心小提琴图\n */\nregisterShape('violin', 'hollow', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const attrs = getStyle(cfg, true, false);\n    const path = this.parsePath(getViolinPath(cfg.points));\n    return container.addShape('path', {\n      attrs: {\n        ...attrs,\n        path,\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4,\n        fill: null,\n        stroke: color,\n      },\n    };\n  },\n});\n\n/**\n * 平滑边界的空心小提琴图\n */\nregisterShape('violin', 'hollow-smooth', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const attrs = getStyle(cfg, true, false);\n    const path = this.parsePath(getSmoothViolinPath(cfg.points));\n    return container.addShape('path', {\n      attrs: {\n        ...attrs,\n        path,\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4,\n        fill: null,\n        stroke: color,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\nimport { registerShape } from '../base';\nimport { getSmoothViolinPath } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\n\n/**\n * 平滑边界的小提琴图\n */\nregisterShape('violin', 'smooth', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const attrs = getStyle(cfg, true, true);\n    const path = this.parsePath(getSmoothViolinPath(cfg.points));\n    return container.addShape('path', {\n      attrs: {\n        ...attrs,\n        path,\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'circle',\n      style: {\n        stroke: null,\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n","/**\n * 对比当前元素和之前的元素，返回 added, updated, removed\n * @param keyItem 之前的元素的，按照 key-item 的 object 的形式存储\n * @param keys 现在的元素，按照 array 的形式存储\n * @returns 由 added, updated, removed array 构成的 object\n */\nexport function diff(keyItem: Record<string, any>, keys: string[]) {\n  const added = [];\n  const updated = [];\n  const removed = [];\n  const keyIncluded = new Map<string, boolean>();\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (keyItem[key]) updated.push(key);\n    else added.push(key);\n    keyIncluded.set(key, true);\n  }\n\n  Object.keys(keyItem).forEach((key) => {\n    if (!keyIncluded.has(key)) removed.push(key);\n  });\n\n  return {\n    added,\n    updated,\n    removed,\n  };\n}\n","import { groupToMap } from '@antv/util';\nimport { Data } from '../../interface';\n\n/** @ignore */\nexport function group(data: Data, fields: string[], appendConditions: Record<string, any[]> = {}) {\n  if (!fields) {\n    return [data];\n  }\n  const groups = groupToMap(data, fields);\n  const array = [];\n  if (fields.length === 1 && appendConditions[fields[0]]) {\n    const values = appendConditions[fields[0]];\n    for (const value of values) {\n      const arr = groups[`_${value}`];\n      if (arr) {\n        // 可能存在用户设置 values ，但是数据中没有对应的字段，则这时候 arr 就为 null\n        array.push(arr);\n      }\n    }\n  } else {\n    for (const k in groups) {\n      if (groups.hasOwnProperty(k)) {\n        const eachGroup = groups[k];\n        array.push(eachGroup);\n      }\n    }\n  }\n\n  return array;\n}\n","import { isEqual, some } from '@antv/util';\nimport { ShapeInfo } from '../../interface';\n\n/**\n * @ignore\n * Determines whether model is change\n * @param currentModel\n * @param preModel\n * @returns\n */\nexport function isModelChange(currentModel: ShapeInfo, preModel: ShapeInfo) {\n  return some(\n    ['color', 'shape', 'size', 'x', 'y', 'isInCircle', 'data', 'style', 'defaultStyle', 'points', 'mappingData'],\n    (key: string) => {\n      return !isEqual(currentModel[key], preModel[key]);\n    }\n  );\n}\n","import { isArray } from '@antv/util';\n\n/** @ignore */\nexport function parseFields(field: string | string[]): string[] {\n  if (isArray(field)) {\n    return field;\n  }\n\n  return field.split('*');\n}\n","import { flatten, isString, valuesOfKey, isNil } from '@antv/util';\nimport { getXDimensionLength } from '../../util/coordinate';\n\n// 已经排序后的数据查找距离最小的\nfunction findMinDistance(arr, scale) {\n  const count = arr.length;\n  let sourceArr = arr;\n  if (isString(sourceArr[0])) {\n    // 日期类型的 values 经常上文本类型，所以需要转换一下\n    sourceArr = arr.map((v: string) => {\n      return scale.translate(v);\n    });\n  }\n  let distance = sourceArr[1] - sourceArr[0];\n  for (let i = 2; i < count; i++) {\n    const tmp = sourceArr[i] - sourceArr[i - 1];\n    if (distance > tmp) {\n      distance = tmp;\n    }\n  }\n  return distance;\n}\n\nfunction getDodgeCount(dataArray, dodgeBy) {\n  if (dodgeBy) {\n    const mergeData = flatten(dataArray);\n    const values = valuesOfKey(mergeData, dodgeBy);\n    return values.length;\n  }\n\n  return dataArray.length;\n}\n\n/** @ignore */\nexport function getDefaultSize(geometry): number {\n  const theme = geometry.theme;\n  const coordinate = geometry.coordinate;\n  const xScale = geometry.getXScale();\n  const xValues = xScale.values;\n  const dataArray = geometry.beforeMappingData;\n  let count: number = xValues.length;\n  const xDimensionLength = getXDimensionLength(geometry.coordinate);\n  // 获取柱宽相关配置项\n  const { intervalPadding, dodgePadding } = geometry;\n  // 兼容theme配置\n  const maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;\n  const minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;\n  const columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;\n  const multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;\n  const roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio;\n\n  // 线性情况下count值\n  if (xScale.isLinear && xValues.length > 1) {\n    // Linear 类型用户有可能设置了 min, max 范围所以需要根据数据最小区间计算 count\n    xValues.sort();\n    const interval = findMinDistance(xValues, xScale);\n    count = (xScale.max - xScale.min) / interval;\n    if (xValues.length > count) {\n      count = xValues.length;\n    }\n  }\n\n  const range = xScale.range;\n  let normalizedSize = 1 / count;\n  let wr = 1;\n  if (coordinate.isPolar) {\n    // 极坐标场景\n    if (coordinate.isTransposed && count > 1) {\n      // 极坐标下多层环图\n      wr = multiplePieWidthRatio;\n    } else {\n      wr = roseWidthRatio;\n    }\n  } else {\n    // 非极坐标场景\n    if (xScale.isLinear) {\n      normalizedSize *= range[1] - range[0];\n    }\n    wr = columnWidthRatio;\n  }\n\n  // 基础柱状图\n  if (!isNil(intervalPadding) && intervalPadding >= 0) {\n    // 配置组间距情况\n    const normalizedIntervalPadding = intervalPadding / xDimensionLength;\n    normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;\n  } else {\n    // 默认情况\n    normalizedSize *= wr;\n  }\n  // 分组柱状图\n  if (geometry.getAdjust('dodge')) {\n    const dodgeAdjust = geometry.getAdjust('dodge');\n    const dodgeBy = dodgeAdjust.dodgeBy;\n    const dodgeCount = getDodgeCount(dataArray, dodgeBy);\n    if (!isNil(dodgePadding) && dodgePadding >= 0) {\n      // 仅配置组内间距情况\n      const normalizedDodgePadding = dodgePadding / xDimensionLength;\n      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;\n    } else if (!isNil(intervalPadding) && intervalPadding >= 0) {\n      // 设置组间距但未设置组内间距情况，避免组间距过小导致图形重叠，需乘以wr\n      normalizedSize *= wr;\n      normalizedSize = normalizedSize / dodgeCount;\n    } else {\n      // 组间距和组内间距均未配置\n      normalizedSize = normalizedSize / dodgeCount;\n    }\n    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;\n  }\n\n  // 最大和最小限制\n  if (!isNil(maxColumnWidth) && maxColumnWidth >= 0) {\n    const normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;\n    if (normalizedSize > normalizedMaxColumnWidth) {\n      normalizedSize = normalizedMaxColumnWidth;\n    }\n  }\n\n  // \bminColumnWidth可能设置为0\n  if (!isNil(minColumnWidth) && minColumnWidth >= 0) {\n    const normalizedMinColumnWidth = minColumnWidth / xDimensionLength;\n    if (normalizedSize < normalizedMinColumnWidth) {\n      normalizedSize = normalizedMinColumnWidth;\n    }\n  }\n\n  return normalizedSize;\n}\n","import { each, max, map, isArray } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg, ViolinShapePoint } from '../../../interface';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getViolinPath } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\n\nfunction normalizeSize(arr: number[]) {\n  if (!isArray(arr)) {\n    return [];\n  }\n  const maxValue = max(arr);\n  return map(arr, (num) => num / maxValue);\n}\n\nconst ViolinShapeFactory = registerShapeFactory('violin', {\n  defaultShapeType: 'violin',\n  getDefaultPoints(pointInfo: ViolinShapePoint) {\n    const radius = pointInfo.size / 2;\n    const points = [];\n    const sizeArr = normalizeSize(pointInfo._size);\n\n    each(pointInfo.y as number[], (y, index) => {\n      const offset = sizeArr[index] * radius;\n      const isMin = index === 0;\n      const isMax = index === (pointInfo.y as number[]).length - 1;\n      points.push({\n        isMin,\n        isMax,\n        x: (pointInfo.x as number) - offset,\n        y,\n      });\n      points.unshift({\n        isMin,\n        isMax,\n        x: (pointInfo.x as number) + offset,\n        y,\n      });\n    });\n    return points;\n  },\n});\n\nregisterShape('violin', 'violin', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const shapeAttrs = getStyle(cfg, true, true);\n    const path = this.parsePath(getViolinPath(cfg.points));\n    return container.addShape('path', {\n      attrs: {\n        ...shapeAttrs,\n        path,\n      },\n      name: 'violin',\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n\nexport default ViolinShapeFactory;\n","import { get } from '@antv/util';\nimport { FIELD_ORIGIN } from '../constant';\nimport { Datum, ViolinShapePoint } from '../interface';\nimport { getXDimensionLength } from '../util/coordinate';\nimport { getDefaultSize } from './util/shape-size';\nimport Geometry from './base';\n/** 引入 Path 对应的 ShapeFactory */\nimport './shape/violin';\n\n/**\n * Violin 几何标记。\n * 用于绘制小提琴图。\n */\nexport default class Violin extends Geometry<ViolinShapePoint> {\n  public readonly type: string = 'violin';\n  public readonly shapeType: string = 'violin';\n  protected generatePoints: boolean = true;\n  /** size 私有映射字段 */\n  private _sizeField: string;\n\n  /**\n   * 获取 Shape 的关键点数据。\n   * @param record\n   * @returns\n   */\n  protected createShapePointsCfg(record: Datum) {\n    const cfg = super.createShapePointsCfg(record);\n\n    // 计算每个 shape 的 size\n    let size;\n    const sizeAttr = this.getAttribute('size');\n    if (sizeAttr) {\n      size = this.getAttributeValues(sizeAttr, record)[0];\n      // 归一化\n      const coordinate = this.coordinate;\n      const coordinateWidth = getXDimensionLength(coordinate);\n      size = size / coordinateWidth;\n    } else {\n      if (!this.defaultSize) {\n        this.defaultSize = getDefaultSize(this);\n      }\n      size = this.defaultSize;\n    }\n    cfg.size = size;\n    cfg._size = get(record[FIELD_ORIGIN], [this._sizeField]);\n    return cfg;\n  }\n\n  /**\n   * @override\n   */\n  protected initAttributes() {\n    const { attributeOption } = this;\n    const sizeField = attributeOption.size\n      ? attributeOption.size.fields[0]\n      : this._sizeField\n      ? this._sizeField\n      : 'size';\n    this._sizeField = sizeField;\n    // fixme 干啥要删掉\n    delete attributeOption.size;\n    super.initAttributes();\n  }\n}\n"],"names":["getInterpolateShapeAttrs","cfg","shapeType","points","getPathPoints","connectNulls","showSinglePoint","path","each","eachLinePoints","interpolatePoints","result","point","index","nextPoint","push","interpolatePoint","x","y","nextX","nextY","middleX","middleY","interpolateCallback","concat","getInterpolatePoints","map","getInterpolatePath","getStyle","registerShape","draw","container","attrs","addShape","type","name","getMarker","markerCfg","getLineMarker","LineSymbols","line","r","dot","dash","smooth","hv","vh","hvh","vhv","color","symbol","style","lineWidth","stroke","HOLLOW_SHAPES","shapeName","drawPoints","this","MarkerSymbols","fill","size","parsePoints","pointPosition","isStack","length","group","addGroup","points_1_1","width","height","img","shape","registerShapeFactory","defaultShapeType","getDefaultPoints","pointInfo","splitPoints","SHAPES","isStroke","subX","subY","isEmpty","shapeAttrs","parsePath","flag","i","c","isEqual","last","getPath","getRectAttrs","Math","abs","len","min","clamp","parseValue","value","array","isArray","max","min1","max1","median","getBoxPoints","pointsArray","halfSize","minX","maxX","isNil","minY","maxY","arr","getPoints","shapePoint","getCandlePoints","yValues","sorted","sort","a","b","padEnd","getCandleYValues","isValueEmpty","undefined","isNaN","isYNil","filtered","tmp","getViolinPath","action","first","getSmoothViolinPath","half","leftPoints","rightPoints","leftPath","getSplinePath","rightPath","shift","isFill","sizeName","_a","defaultStyle","getBackgroundRectStyle","deepMix","fillOpacity","get","_convertArr","coord","convert","_convertArcPath","isTransposed","catmullRom2bezier","crp","z","constraint","isLoop","pointList","l","cp1","cp2","p","controlPointList","prevPoint","nextCp0","cp0","cps","hasConstraint","vec2","v","d0","d1","sum","v1","v2","smoothBezier","getLinePath","isInCircle","length_1","item","_points2path","constaint","data","prePoint","splinePath","unshift","convertNormalPath","subPath","toLowerCase","convertPolarPath","pre","cur","transposed","startAngle","endAngle","curPoint","rst","xDim","angleRange","direction","PI","convertPoint","getDistanceToCenter","middlePoint","middleConvertPoint","_convertPolarPath","next","_filterFullCirleLine","obj","eachY","diff","keyItem","keys","added","updated","removed","keyIncluded","Map","key","set","Object","forEach","has","fields","appendConditions","groups","groupToMap","values","values_1_1","k","hasOwnProperty","eachGroup","isModelChange","currentModel","preModel","some","parseFields","field","split","getDefaultSize","geometry","theme","coordinate","xScale","getXScale","xValues","dataArray","beforeMappingData","count","xDimensionLength","getXDimensionLength","intervalPadding","dodgePadding","maxColumnWidth","minColumnWidth","columnWidthRatio","multiplePieWidthRatio","roseWidthRatio","isLinear","interval","scale","sourceArr","isString","translate","distance","findMinDistance","range","normalizedSize","wr","isPolar","getAdjust","dodgeCount","dodgeBy","mergeData","flatten","valuesOfKey","getDodgeCount","normalizedMaxColumnWidth","normalizedMinColumnWidth","radius","sizeArr","maxValue","num","normalizeSize","_size","offset","isMin","isMax","_this","__extends","Violin","record","_super","createShapePointsCfg","call","sizeAttr","getAttribute","getAttributeValues","defaultSize","FIELD_ORIGIN","_sizeField","attributeOption","sizeField","initAttributes","Geometry"],"sourceRoot":""}