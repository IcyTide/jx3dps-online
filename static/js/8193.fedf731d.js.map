{"version":3,"file":"static/js/8193.fedf731d.js","mappings":"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","sources":["../node_modules/@antv/g2/src/util/annotation.ts","../node_modules/@antv/g2/src/util/attr.ts","../node_modules/@antv/g2/src/util/axis.ts","../node_modules/@antv/g2/src/util/bbox.ts","../node_modules/@antv/g2/src/util/collision-detect.ts","../node_modules/@antv/g2/src/util/color.ts","../node_modules/@antv/g2/src/util/context.ts","../node_modules/@antv/g2/src/util/coordinate.ts","../node_modules/@antv/g2/src/util/direction.ts","../node_modules/@antv/g2/src/util/dom.ts"],"sourcesContent":["import { getMedian, getMean } from './stat';\nimport { Scale } from '../dependents';\n\n/**\n * parse the value position\n * @param val\n * @param scale\n */\nexport function getNormalizedValue(val: number | string, scale: Scale) {\n  if (!scale) {\n    return null;\n  }\n  let scaled: number;\n\n  switch (val) {\n    case 'start':\n      return 0;\n    case 'center':\n      return 0.5;\n    case 'end':\n      return 1;\n    case 'median': {\n      scaled = scale.isCategory ? getMedian(scale.values.map((_, idx: number) => idx)) : getMedian(scale.values);\n      break;\n    }\n    case 'mean': {\n      scaled = scale.isCategory ? (scale.values.length - 1) / 2 : getMean(scale.values);\n      break;\n    }\n    case 'min':\n      scaled = scale.isCategory ? 0 : scale[val];\n      break;\n    case 'max':\n      scaled = scale.isCategory ? scale.values.length - 1 : scale[val];\n      break;\n    default:\n      scaled = val as number;\n      break;\n  }\n\n  return scale.scale(scaled);\n}\n","import { Attribute } from '../dependents';\n\n/**\n * @ignore\n * get the mapping value by attribute, if mapping value is nil, return def\n * @param attr\n * @param value\n * @param def\n * @returns get mapping value\n */\nexport function getMappingValue(attr: Attribute, value: any, def: string): string {\n  if (!attr) {\n    return def;\n  }\n\n  let r;\n  // 多参数映射，阻止程序报错\n  if (attr.callback && attr.callback.length > 1) {\n    const restArgs = Array(attr.callback.length - 1).fill('');\n    r = attr.mapping(value, ...restArgs).join('');\n  } else {\n    r = attr.mapping(value).join('');\n  }\n\n  return r || def;\n}\n","import { deepMix, get, isBoolean } from '@antv/util';\nimport { DIRECTION } from '../constant';\nimport { Coordinate, Scale } from '../dependents';\nimport { AxisCfg, AxisOption, Point, Region } from '../interface';\nimport { getName } from './scale';\nimport { vec2 } from '@antv/matrix-util';\n\n/**\n * @ignore\n * get axis relative region ( 0 ~ 1) by direction when coordinate is rect\n * @param direction\n * @returns axis coordinate region\n */\nexport function getLineAxisRelativeRegion(direction: DIRECTION): Region {\n  let start;\n  let end;\n\n  switch (direction) {\n    case DIRECTION.TOP:\n      start = { x: 0, y: 1 };\n      end = { x: 1, y: 1 };\n      break;\n    case DIRECTION.RIGHT:\n      start = { x: 1, y: 0 };\n      end = { x: 1, y: 1 };\n      break;\n    case DIRECTION.BOTTOM:\n      start = { x: 0, y: 0 };\n      end = { x: 1, y: 0 };\n      break;\n    case DIRECTION.LEFT:\n      start = { x: 0, y: 0 };\n      end = { x: 0, y: 1 };\n      break;\n    default:\n      start = end = { x: 0, y: 0 };\n  }\n\n  return { start, end };\n}\n\n/**\n * @ignore\n * get axis relative region ( 0 ~ 1) by direction when coordinate is polar\n * @param coordinate\n * @returns axis coordinate region\n */\nexport function getCircleAxisRelativeRegion(coordinate: Coordinate) {\n  let start;\n  let end;\n  if (coordinate.isTransposed) {\n    start = {\n      x: 0,\n      y: 0,\n    };\n    end = {\n      x: 1,\n      y: 0,\n    };\n  } else {\n    start = {\n      x: 0,\n      y: 0,\n    };\n    end = {\n      x: 0,\n      y: 1,\n    };\n  }\n\n  return { start, end };\n}\n\n/**\n * @ignore\n * get the axis region from coordinate\n * @param coordinate\n * @param direction\n * @returns the axis region (start point, end point)\n */\nexport function getAxisRegion(coordinate: Coordinate, direction: DIRECTION): Region {\n  let region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };\n  if (coordinate.isRect) {\n    region = getLineAxisRelativeRegion(direction);\n  } else if (coordinate.isPolar) {\n    region = getCircleAxisRelativeRegion(coordinate);\n  }\n\n  const { start, end } = region;\n  return {\n    start: coordinate.convert(start),\n    end: coordinate.convert(end),\n  };\n}\n\n/**\n * @ignore\n * get axis factor\n * @param coordinate\n * @param direction\n * @returns factor\n */\nexport function getAxisFactor(coordinate: Coordinate, direction: DIRECTION): number {\n  // rect coordinate, by direction\n  if (coordinate.isRect) {\n    return coordinate.isTransposed\n      ? [DIRECTION.RIGHT, DIRECTION.BOTTOM].includes(direction)\n        ? 1\n        : -1\n      : [DIRECTION.BOTTOM, DIRECTION.RIGHT].includes(direction)\n      ? -1\n      : 1;\n  }\n\n  // polar y axis, by angle\n  if (coordinate.isPolar) {\n    const startAngle = coordinate.x.start;\n    return startAngle < 0 ? -1 : 1;\n  }\n\n  return 1;\n}\n\n/**\n * @ignore\n * whether the axis isVertical\n * @param region\n * @returns isVertical\n */\nexport function isVertical(region: Region): boolean {\n  const { start, end } = region;\n\n  return start.x === end.x;\n}\n\n/**\n * @ignore\n * get factor by region (real position)\n * @param region\n * @param center\n * @returns factor\n */\nexport function getAxisFactorByRegion(region: Region, center: Point): number {\n  const { start, end } = region;\n\n  const isAxisVertical = isVertical(region);\n\n  // 垂直\n  if (isAxisVertical) {\n    // 左方,从下到上、右方,从上到下\n    if ((start.y - end.y) * (center.x - start.x) > 0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  } else {\n    // 下方,从左到右、上方,从右到做\n    if ((end.x - start.x) * (start.y - center.y) > 0) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\n/**\n * @ignore\n * get the axis cfg from theme, will mix the common cfg of legend theme\n *\n * @param theme view theme object\n * @param direction axis direction\n * @returns axis theme cfg\n */\nexport function getAxisThemeCfg(theme: object, direction: string): object {\n  const axisTheme = get(theme, ['components', 'axis'], {});\n  return deepMix({}, get(axisTheme, ['common'], {}), deepMix({}, get(axisTheme, [direction], {})));\n}\n\n/**\n * get the options of axis title，mix the cfg from theme, avoid common themeCfg not work\n * @param theme\n * @param direction\n * @param axisOptions\n * @returns axis title options\n */\nexport function getAxisTitleOptions(theme: object, direction: string, axisOptions?: object): object {\n  const axisTheme = get(theme, ['components', 'axis'], {});\n  return deepMix(\n    {},\n    get(axisTheme, ['common', 'title'], {}),\n    deepMix({}, get(axisTheme, [direction, 'title'], {})),\n    axisOptions\n  );\n}\n\n/**\n * @ignore\n * get circle axis center and radius\n * @param coordinate\n */\nexport function getCircleAxisCenterRadius(coordinate: Coordinate) {\n  // @ts-ignore\n  const { x, y, circleCenter: center } = coordinate;\n  const isReflectY = y.start > y.end;\n  const start = coordinate.isTransposed\n    ? coordinate.convert({\n        x: isReflectY ? 0 : 1,\n        y: 0,\n      })\n    : coordinate.convert({\n        x: 0,\n        y: isReflectY ? 0 : 1,\n      });\n\n  const startVector: [number, number] = [start.x - center.x, start.y - center.y];\n  const normalVector: [number, number] = [1, 0];\n  const startAngle =\n    start.y > center.y ? vec2.angle(startVector, normalVector) : vec2.angle(startVector, normalVector) * -1;\n  const endAngle = startAngle + (x.end - x.start);\n  const radius = Math.sqrt((start.x - center.x) ** 2 + (start.y - center.y) ** 2);\n\n  return {\n    center,\n    radius,\n    startAngle,\n    endAngle,\n  };\n}\n\n/**\n * @ignore\n * 从配置中获取单个字段的 axis 配置\n * @param axes\n * @param field\n * @returns the axis option of field\n */\nexport function getAxisOption(axes: Record<string, AxisOption> | boolean, field: string) {\n  if (isBoolean(axes)) {\n    return axes === false ? false : {};\n  }\n  return get(axes, [field]);\n}\n\n/**\n * @ignore\n * 如果配置了 position，则使用配置\n * @param axisOption\n * @param def\n */\nexport function getAxisDirection(axisOption: AxisOption, def: DIRECTION): DIRECTION {\n  return get(axisOption, 'position', def);\n}\n\n/**\n * 获取 axis 的 title 文本\n * @param scale\n * @param axisOption\n */\nexport function getAxisTitleText(scale: Scale, axisOption: AxisCfg): string {\n  return get(axisOption, ['title', 'text'], getName(scale));\n}\n","import { each } from '@antv/util';\nimport { DIRECTION } from '../constant';\nimport { Padding, Point, Region } from '../interface';\nimport { BBox as BBoxObject } from '../dependents';\n\n/**\n * 用于包围盒计算。\n */\nexport class BBox {\n  /** x 轴坐标系 */\n  public x: number;\n  /** y 轴坐标系 */\n  public y: number;\n  /** 包围盒高度 */\n  public height: number;\n  /** 包围盒宽度 */\n  public width: number;\n\n  public static fromRange(minX: number, minY: number, maxX: number, maxY: number) {\n    return new BBox(minX, minY, maxX - minX, maxY - minY);\n  }\n\n  public static fromObject(bbox: BBoxObject) {\n    return new BBox(bbox.minX, bbox.minY, bbox.width, bbox.height);\n  }\n\n  constructor(x: number = 0, y: number = 0, width: number = 0, height: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.height = height;\n    this.width = width;\n  }\n\n  public get minX(): number {\n    return this.x;\n  }\n\n  public get maxX(): number {\n    return this.x + this.width;\n  }\n\n  public get minY(): number {\n    return this.y;\n  }\n\n  public get maxY(): number {\n    return this.y + this.height;\n  }\n\n  public get tl(): Point {\n    return { x: this.x, y: this.y };\n  }\n\n  public get tr(): Point {\n    return { x: this.maxX, y: this.y };\n  }\n\n  public get bl(): Point {\n    return { x: this.x, y: this.maxY };\n  }\n\n  public get br(): Point {\n    return { x: this.maxX, y: this.maxY };\n  }\n\n  public get top(): Point {\n    return {\n      x: this.x + this.width / 2,\n      y: this.minY,\n    };\n  }\n\n  public get right(): Point {\n    return {\n      x: this.maxX,\n      y: this.y + this.height / 2,\n    };\n  }\n  public get bottom(): Point {\n    return {\n      x: this.x + this.width / 2,\n      y: this.maxY,\n    };\n  }\n  public get left(): Point {\n    return {\n      x: this.minX,\n      y: this.y + this.height / 2,\n    };\n  }\n  // end 计算属性\n\n  /**\n   * 包围盒是否相等\n   * @param {BBox} bbox 包围盒\n   * @returns      包围盒是否相等\n   */\n  public isEqual(bbox: BBox): boolean {\n    return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;\n  }\n\n  /**\n   * 是否包含了另一个包围盒\n   * @param child\n   */\n  public contains(child: BBox): boolean {\n    return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;\n  }\n\n  /**\n   * 克隆包围盒\n   * @returns 包围盒\n   */\n  public clone(): BBox {\n    return new BBox(this.x, this.y, this.width, this.height);\n  }\n\n  /**\n   * 取并集\n   * @param subBBox\n   */\n  public add(...subBBox: BBox[]): BBox {\n    const bbox = this.clone();\n    each(subBBox, (b: BBox) => {\n      bbox.x = Math.min(b.x, bbox.x);\n      bbox.y = Math.min(b.y, bbox.y);\n      bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;\n      bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;\n    });\n\n    return bbox;\n  }\n\n  /**\n   * 取交集\n   * @param subBBox\n   */\n  public merge(...subBBox: BBox[]): BBox {\n    const bbox = this.clone();\n    each(subBBox, (b: BBox) => {\n      bbox.x = Math.max(b.x, bbox.x);\n      bbox.y = Math.max(b.y, bbox.y);\n      bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;\n      bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;\n    });\n\n    return bbox;\n  }\n\n  /**\n   * bbox 剪裁\n   * @param subBBox\n   * @param direction\n   */\n  public cut(subBBox: BBox, direction: DIRECTION): BBox {\n    const width = subBBox.width;\n    const height = subBBox.height;\n\n    switch (direction) {\n      case DIRECTION.TOP:\n      case DIRECTION.TOP_LEFT:\n      case DIRECTION.TOP_RIGHT:\n        return BBox.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);\n\n      case DIRECTION.RIGHT:\n      case DIRECTION.RIGHT_TOP:\n      case DIRECTION.RIGHT_BOTTOM:\n        return BBox.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);\n\n      case DIRECTION.BOTTOM:\n      case DIRECTION.BOTTOM_LEFT:\n      case DIRECTION.BOTTOM_RIGHT:\n        return BBox.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);\n\n      case DIRECTION.LEFT:\n      case DIRECTION.LEFT_TOP:\n      case DIRECTION.LEFT_BOTTOM:\n        return BBox.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);\n      default:\n        // 其他情况不裁剪，原样返回\n        return this;\n    }\n  }\n\n  /**\n   * 收缩形成新的\n   * @param gap\n   */\n  public shrink(gap: Padding): BBox {\n    const [top, right, bottom, left] = gap;\n\n    return new BBox(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);\n  }\n\n  /**\n   * 扩张形成新的\n   * @param gap\n   */\n  public expand(gap: Padding): BBox {\n    const [top, right, bottom, left] = gap;\n\n    return new BBox(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);\n  }\n\n  /**\n   * get the gap of two bbox, if not exceed, then 0\n   * @param bbox\n   * @returns [top, right, bottom, left]\n   */\n  public exceed(bbox: BBox): Padding {\n    return [\n      Math.max(-this.minY + bbox.minY, 0),\n      Math.max(this.maxX - bbox.maxX, 0),\n      Math.max(this.maxY - bbox.maxY, 0),\n      Math.max(-this.minX + bbox.minX, 0),\n    ];\n  }\n\n  /**\n   * 是否碰撞\n   * @param bbox\n   */\n  public collide(bbox: BBox): boolean {\n    return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;\n  }\n\n  /**\n   * 获取包围盒大小\n   * @returns 包围盒大小\n   */\n  public size(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * 点是否在 bbox 中\n   * @param p\n   */\n  public isPointIn(p: Point) {\n    return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;\n  }\n}\n\n/**\n * 从一个 bbox 的 region 获取 bbox\n * @param bbox\n * @param region\n */\nexport const getRegionBBox = (bbox: BBox, region: Region): BBox => {\n  const { start, end } = region;\n\n  return new BBox(\n    bbox.x + bbox.width * start.x,\n    bbox.y + bbox.height * start.y,\n    bbox.width * Math.abs(end.x - start.x),\n    bbox.height * Math.abs(end.y - start.y)\n  );\n};\n\n/**\n * 将 bbox 转换成 points\n * @param bbox\n */\nexport function toPoints(bbox: Partial<BBox>): any[] {\n  return [\n    [bbox.minX, bbox.minY],\n    [bbox.maxX, bbox.minY],\n    [bbox.maxX, bbox.maxY],\n    [bbox.minX, bbox.maxY],\n  ];\n}\n","import { isNumber } from '@antv/util';\nimport { Point } from '../dependents';\n\ntype Vec2 = [number, number];\n\ntype Item = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  visible?: boolean;\n};\n/**\n * 定义投影对象\n */\ntype Projection = { min: number; max: number };\n\nfunction dot(a, b) {\n  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n}\n\n/**\n * @private\n * 1. 获取投影轴\n */\nfunction getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  }\n  // 获取向量\n  const vector = (start: Point, end: Point): Vec2 => {\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n  const AB = vector(points[0], points[1]);\n  const BC = vector(points[1], points[2]);\n\n  return [AB, BC];\n}\n\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\nfunction rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n  const { x, y } = point;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n  };\n}\n\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\nfunction getRectPoints(box: Item): Point[] {\n  const points = [\n    { x: box.x, y: box.y },\n    { x: box.x + box.width, y: box.y },\n    { x: box.x + box.width, y: box.y + box.height },\n    { x: box.x, y: box.y + box.height },\n  ];\n\n  const rotation = box.rotation;\n  if (rotation) {\n    return [\n      rotateAtPoint(points[0], rotation, points[0]),\n      rotateAtPoint(points[1], rotation, points[0]),\n      rotateAtPoint(points[2], rotation, points[0]),\n      rotateAtPoint(points[3], rotation, points[0]),\n    ];\n  }\n\n  return points;\n}\n\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\nfunction getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return { min: 0, max: 0 };\n  }\n\n  const scalars = [];\n  points.forEach((point) => {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n\n  return { min: Math.min(...scalars), max: Math.max(...scalars) };\n}\n\nfunction isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\n\nfunction isValidNumber(d: number) {\n  return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n}\n\nfunction isValidBox(box: Item) {\n  return ['x', 'y', 'width', 'height'].every(attr => isValidNumber(box[attr]))\n}\n\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\nexport function isIntersectRect(box1: Item, box2: Item, margin: number = 0): boolean {\n  return !(\n    box2.x > box1.x + box1.width + margin ||\n    box2.x + box2.width < box1.x - margin ||\n    box2.y > box1.y + box1.height + margin ||\n    box2.y + box2.height < box1.y - margin\n  );\n}\n\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\nexport function intersect(box1: Item, box2: Item, margin: number = 0) {\n  // 如果两个 box 中有一个是不合法的 box，也就是不会被渲染出来的，那么它们就不相交。\n  if (!isValidBox(box1) || !isValidBox(box2)) return false;\n\n  // 如果两个矩形没有旋转，使用快速判断\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2, margin);\n  }\n\n  // 分别获取 4 个关键点\n  const rect1Points = getRectPoints(box1);\n  const rect2Points = getRectPoints(box2);\n\n  // 获取所有投影轴\n  const axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n  for (let i = 0; i < axes.length; i++) {\n    const axis = axes[i];\n    const projection1 = getProjection(rect1Points, axis);\n    const projection2 = getProjection(rect2Points, axis);\n\n    // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n    if (!isProjectionOverlap(projection1, projection2)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import colorUtil from '@antv/color-util';\n\n// 内置的一些特殊设置\nconst preset = {\n  '#5B8FF9': true,\n};\n\n// 根据YIQ亮度判断指定颜色取反色是不是白色\n// http://24ways.org/2010/calculating-color-contrast\n// http://www.w3.org/TR/AERT#color-contrast\nexport const isContrastColorWhite = (color: string): boolean => {\n  const rgb = colorUtil.toRGB(color).toUpperCase();\n  if (preset[rgb]) {\n    return preset[rgb];\n  }\n\n  const [r, g, b] = colorUtil.rgb2arr(rgb);\n  const isDark = (r * 299 + g * 587 + b * 114) / 1000 < 128;\n\n  return isDark;\n};\n","let ctx: CanvasRenderingContext2D;\n\n/**\n * 获取 canvas context\n */\nexport function getCanvasContext() {\n  if (!ctx) {\n    ctx = document.createElement('canvas').getContext('2d');\n  }\n\n  return ctx;\n}\n","import { Coordinate } from '../dependents';\nimport { Point } from '../interface';\nimport { getSectorPath } from './graphics';\nimport { isBetween } from './helper';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * Gets x dimension length\n * @param coordinate\n * @returns x dimension length\n */\nexport function getXDimensionLength(coordinate): number {\n  if (coordinate.isPolar && !coordinate.isTransposed) {\n    // 极坐标系下 width 为弧长\n    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();\n  }\n\n  // 直角坐标系\n  const start = coordinate.convert({ x: 0, y: 0 });\n  const end = coordinate.convert({ x: 1, y: 0 });\n  // 坐标系有可能发生 transpose 等变换，所有通过两点之间的距离进行计算\n  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n}\n\n/**\n * @ignore\n * Determines whether full circle is\n * @param coordinate\n * @returns true if full circle\n */\nexport function isFullCircle(coordinate: Coordinate): boolean {\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    return endAngle - startAngle === Math.PI * 2;\n  }\n  return false;\n}\n\n/**\n * @ignore\n * 获取当前点到坐标系圆心的距离\n * @param coordinate 坐标系\n * @param point 当前点\n * @returns distance to center\n */\nexport function getDistanceToCenter(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter() as Point;\n  return Math.sqrt((point.x - center.x) ** 2 + (point.y - center.y) ** 2);\n}\n\n/**\n * @ignore\n * 坐标点是否在坐标系中\n * @param coordinate\n * @param point\n */\nexport function isPointInCoordinate(coordinate: Coordinate, point: Point) {\n  let result = false;\n\n  if (coordinate) {\n    if (coordinate.type === 'theta') {\n      const { start, end } = coordinate;\n      result = isBetween(point.x, start.x, end.x) && isBetween(point.y, start.y, end.y);\n    } else {\n      const invertPoint = coordinate.invert(point);\n    \n      result = isBetween(invertPoint.x, 0, 1) && isBetween(invertPoint.y, 0, 1);\n    }\n  }\n\n  return result;\n}\n\n/**\n * @ignore\n * 获取点到圆心的连线与水平方向的夹角\n */\nexport function getAngleByPoint(coordinate: Coordinate, point: Point): number {\n  const center = coordinate.getCenter();\n  return Math.atan2(point.y - center.y, point.x - center.x);\n}\n\n/**\n * @ignore\n * 获取同坐标系范围相同的剪切区域\n * @param coordinate\n * @returns\n */\nexport function getCoordinateClipCfg(coordinate: Coordinate, margin: number = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n\n  if (coordinate.isPolar) {\n    const { startAngle, endAngle } = coordinate;\n    const center = coordinate.getCenter();\n    const radius = coordinate.getRadius();\n\n    return {\n      type: 'path',\n      startState: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, startAngle),\n      },\n      endState: (ratio) => {\n        const diff = (endAngle - startAngle) * ratio + startAngle;\n        const path = getSectorPath(center.x, center.y, radius + margin, startAngle, diff);\n        return {\n          path,\n        };\n      },\n      attrs: {\n        path: getSectorPath(center.x, center.y, radius + margin, startAngle, endAngle),\n      },\n    };\n  }\n\n  let endState;\n  if (coordinate.isTransposed) {\n    endState = {\n      height: height + margin * 2,\n    };\n  } else {\n    endState = {\n      width: width + margin * 2,\n    };\n  }\n\n  return {\n    type: 'rect',\n    startState: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: coordinate.isTransposed ? width + margin * 2 : 0,\n      height: coordinate.isTransposed ? 0 : height + margin * 2,\n    },\n    endState,\n    attrs: {\n      x: start.x - margin,\n      y: end.y - margin,\n      width: width + margin * 2,\n      height: height + margin * 2,\n    },\n  };\n}\n\n/**\n * 获取坐标系范围的 BBox\n * @param coordinate\n * @param margin\n */\nexport function getCoordinateBBox(coordinate: Coordinate, margin = 0) {\n  const { start, end } = coordinate;\n  const width = coordinate.getWidth();\n  const height = coordinate.getHeight();\n  const minX = Math.min(start.x, end.x);\n  const minY = Math.min(start.y, end.y);\n\n  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);\n}\n","import { DIRECTION } from '../constant';\nimport { Coordinate } from '../dependents';\nimport { Position } from '../interface';\nimport { BBox } from './bbox';\n\n/**\n * @ignore\n * 方位常量转实际的 bbox 位置大小\n * @param parentBBox\n * @param bbox\n * @param direction\n */\nexport function directionToPosition(parentBBox: BBox, bbox: BBox, direction: DIRECTION): Position {\n  if (direction === DIRECTION.TOP) {\n    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];\n  }\n  if (direction === DIRECTION.BOTTOM) {\n    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];\n  }\n  if (direction === DIRECTION.LEFT) {\n    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];\n  }\n  if (direction === DIRECTION.RIGHT) {\n    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];\n  }\n\n  if (direction === DIRECTION.TOP_LEFT || direction === DIRECTION.LEFT_TOP) {\n    return [parentBBox.tl.x, parentBBox.tl.y];\n  }\n  if (direction === DIRECTION.TOP_RIGHT || direction === DIRECTION.RIGHT_TOP) {\n    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];\n  }\n  if (direction === DIRECTION.BOTTOM_LEFT || direction === DIRECTION.LEFT_BOTTOM) {\n    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];\n  }\n  if (direction === DIRECTION.BOTTOM_RIGHT || direction === DIRECTION.RIGHT_BOTTOM) {\n    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];\n  }\n\n  return [0, 0];\n}\n\n/**\n * get direction after coordinate transpose\n * @param direction\n * @param coordinate\n * @returns direction after transpose or not\n */\nfunction getTransposedDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  if (coordinate.isTransposed) {\n    switch (direction) {\n      case DIRECTION.BOTTOM:\n        return DIRECTION.LEFT;\n      case DIRECTION.LEFT:\n        return DIRECTION.BOTTOM;\n      case DIRECTION.RIGHT:\n        return DIRECTION.TOP;\n      case DIRECTION.TOP:\n        return DIRECTION.RIGHT;\n    }\n  }\n  return direction;\n}\n\nfunction reflectX(direct: DIRECTION): DIRECTION {\n  if (direct === DIRECTION.LEFT) {\n    return DIRECTION.RIGHT;\n  }\n\n  if (direct === DIRECTION.RIGHT) {\n    return DIRECTION.LEFT;\n  }\n\n  return direct;\n}\n\nfunction reflectY(direct: DIRECTION): DIRECTION {\n  if (direct === DIRECTION.TOP) {\n    return DIRECTION.BOTTOM;\n  }\n  if (direct === DIRECTION.BOTTOM) {\n    return DIRECTION.TOP;\n  }\n\n  return direct;\n}\n\n/**\n * get direction after coordinate.scale\n * @param direction\n * @param coordinate\n */\nfunction getScaleDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  const x = coordinate.matrix[0];\n  const y = coordinate.matrix[4];\n\n  let d = direction;\n  if (x < 0) {\n    d = reflectX(d);\n  }\n  if (y < 0) {\n    d = reflectY(d);\n  }\n  return d;\n}\n\n/**\n *\n * @param direction\n * @param coordinate\n */\nfunction getReflectDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  let d = direction;\n\n  if (coordinate.isReflect('x')) {\n    d = reflectX(d);\n  }\n  if (coordinate.isReflect('y')) {\n    d = reflectY(d);\n  }\n\n  return d;\n}\n\n/**\n * @ignore\n * get direction after coordinate translate\n * @param direction\n * @param coordinate\n */\nexport function getTranslateDirection(direction: DIRECTION, coordinate: Coordinate): DIRECTION {\n  let d = direction;\n  d = getTransposedDirection(d, coordinate);\n  d = getScaleDirection(d, coordinate);\n  d = getReflectDirection(d, coordinate);\n\n  return d;\n}\n","import { MIN_CHART_HEIGHT, MIN_CHART_WIDTH } from '../constant';\nimport { Size } from '../interface';\n\n/**\n * get the element's bounding size\n * @param ele dom element\n * @returns the element width and height\n */\nfunction getElementSize(ele: HTMLElement): Size {\n  const style = getComputedStyle(ele);\n\n  return {\n    width:\n      (ele.clientWidth || parseInt(style.width, 10)) -\n      parseInt(style.paddingLeft, 10) -\n      parseInt(style.paddingRight, 10),\n    height:\n      (ele.clientHeight || parseInt(style.height, 10)) -\n      parseInt(style.paddingTop, 10) -\n      parseInt(style.paddingBottom, 10),\n  };\n}\n\n/**\n * is value a valid number\n * @param v the input value\n * @returns whether it is a number\n */\nfunction isNumber(v: any): boolean {\n  return typeof v === 'number' && !isNaN(v);\n}\n\n/**\n * @ignore\n * calculate the chart size\n * @param ele DOM element\n * @param autoFit should auto fit\n * @param width chart width which is set by user\n * @param height chart height which is set by user\n * @returns the chart width and height\n */\nexport function getChartSize(ele: HTMLElement, autoFit: boolean, width: number, height: number): Size {\n  let w = width;\n  let h = height;\n\n  if (autoFit) {\n    const size = getElementSize(ele);\n\n    w = size.width ? size.width : w;\n    h = size.height ? size.height : h;\n  }\n\n  return {\n    width: Math.max(isNumber(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),\n    height: Math.max(isNumber(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),\n  };\n}\n\n/**\n * @ignore\n * remove html element from its parent\n * @param dom\n */\nexport function removeDom(dom: HTMLElement) {\n  const parent = dom.parentNode;\n\n  if (parent) {\n    parent.removeChild(dom);\n  }\n}\n\n/** @ignore */\nexport { createDom, modifyCSS } from '@antv/dom-util';\n"],"names":["getNormalizedValue","val","scale","scaled","isCategory","getMedian","values","map","_","idx","length","getMean","getMappingValue","attr","value","def","r","callback","restArgs","Array","fill","mapping","apply","__spreadArray","__read","join","getAxisRegion","coordinate","direction","region","start","x","y","end","isRect","DIRECTION","getLineAxisRelativeRegion","isPolar","isTransposed","getCircleAxisRelativeRegion","convert","isVertical","getAxisFactorByRegion","center","getAxisThemeCfg","theme","axisTheme","get","deepMix","getAxisTitleOptions","axisOptions","getCircleAxisCenterRadius","isReflectY","startVector","normalVector","startAngle","vec2","endAngle","radius","Math","sqrt","getAxisOption","axes","field","isBoolean","getAxisDirection","axisOption","getAxisTitleText","getName","width","height","this","BBox","minX","minY","maxX","maxY","bbox","Object","child","subBBox","clone","each","b","min","max","fromRange","gap","top","right","bottom","left","p","toPoints","getAxes","points","vector","rotateAtPoint","point","deg","origin","cos","sin","getRectPoints","box","rotation","getProjection","axis","scalars","forEach","a","push","isProjectionOverlap","projection1","projection2","isValidBox","every","d","Number","isNaN","Infinity","intersect","box1","box2","margin","isIntersectRect","rect1Points","rect2Points","concat","i","preset","isContrastColorWhite","color","rgb","colorUtil","toUpperCase","ctx","getCanvasContext","document","createElement","getContext","getXDimensionLength","getRadius","pow","isFullCircle","PI","getDistanceToCenter","getCenter","isPointInCoordinate","result","type","isBetween","invertPoint","invert","getAngleByPoint","atan2","getCoordinateClipCfg","endState","getWidth","getHeight","endAngle_1","center_1","radius_1","startState","path","getSectorPath","startAngle_1","ratio","diff","attrs","getCoordinateBBox","directionToPosition","parentBBox","tl","tr","bl","br","isNumber","v","getChartSize","ele","autoFit","w","h","size","style","getComputedStyle","clientWidth","parseInt","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom","getElementSize","MIN_CHART_WIDTH","MIN_CHART_HEIGHT","removeDom","dom","parent","parentNode","removeChild"],"sourceRoot":""}