{"version":3,"file":"static/js/6642.4537b541.js","mappings":"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","sources":["../node_modules/@antv/g2/src/chart/layout/auto.ts","../node_modules/@antv/g2/src/chart/layout/index.ts","../node_modules/@antv/g2/src/chart/layout/padding-cal.ts","../node_modules/@antv/g2/src/chart/util/scale-pool.ts","../node_modules/@antv/g2/src/chart/util/sync-view-padding.ts","../node_modules/@antv/g2/src/component/update-label.ts","../node_modules/@antv/g2/src/component/labels.ts","../node_modules/@antv/g2/src/constant.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { COMPONENT_TYPE } from '../../constant';\nimport { ComponentOption, Padding } from '../../interface';\nimport { BBox } from '../../util/bbox';\nimport { isAutoPadding, parsePadding } from '../../util/padding';\nimport View from '../view';\nimport { PaddingCal } from './padding-cal';\n\n/**\n * @ignore\n * 根据 view 中的组件，计算实际的 padding 数值\n * @param view\n */\nexport function calculatePadding(view: View): PaddingCal {\n  const padding = view.padding;\n\n  // 如果不是 auto padding，那么直接解析之后返回\n  if (!isAutoPadding(padding)) {\n    return new PaddingCal(...parsePadding(padding));\n  }\n\n  // 是 auto padding，根据组件的情况，来计算 padding\n  const { viewBBox } = view;\n\n  const paddingCal = new PaddingCal();\n\n  const axisComponents = [];\n  const paddingComponents = [];\n  const otherComponents = [];\n\n  each(view.getComponents(), (co: ComponentOption) => {\n    const { type } = co;\n    if (type === COMPONENT_TYPE.AXIS) {\n      axisComponents.push(co);\n    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {\n      paddingComponents.push(co);\n    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {\n      otherComponents.push(co);\n    }\n  });\n\n  // 进行坐标轴布局，应该是取 padding 的并集，而不是进行相加\n  each(axisComponents, (co: ComponentOption) => {\n    const { component } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n\n    const exceed = componentBBox.exceed(viewBBox);\n\n    // 在对组件分组之后，先对 axis 进行处理，然后取最大的超出即可。\n    paddingCal.max(exceed);\n  });\n\n  // 有 padding 的组件布局\n  each(paddingComponents, (co: ComponentOption) => {\n    const { component, direction } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentPadding: Padding = component.get('padding');\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(\n      componentPadding\n    );\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n\n  // 其他组件布局\n  each(otherComponents, (co: ComponentOption) => {\n    const { component, direction } = co;\n    const bboxObject = component.getLayoutBBox();\n    const componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);\n    // 按照方向计算 padding\n    paddingCal.inc(componentBBox, direction);\n  });\n\n  return paddingCal;\n}\n","import { Controller } from '../controller/base';\nimport View from '../view';\n\n// 布局函数的定义\n// 布局函数的职责：根据 view 中组件信息，计算出最终的图形 padding 数值，以及最终各个组件的布局和位置\nexport type Layout = (view: View) => void;\n\n/**\n * @ignore\n * G2 默认提供的 layout 函数\n * 内置布局函数处理的逻辑：\n *\n * 1. 如果 padding = 'auto'，那么自动根据组件的 direction 来计算 padding 数组\n * 2. 根据 padding 和 direction 去分配对应方向的 padding 数值\n * 3. 移动组件位置\n *\n * 前面 1，2 步骤在 view 中已经做掉了。对于组件响应式布局，可以尝试使用约束布局的方式去求解位置信息。\n * @param view\n */\nexport default function defaultLayout(view: View): void {\n  const axis = view.getController('axis');\n  const legend = view.getController('legend');\n  const annotation = view.getController('annotation');\n  const slider = view.getController('slider');\n  const scrollbar = view.getController('scrollbar');\n\n  // 根据最新的 coordinate 重新布局组件\n  [axis, slider, scrollbar, legend, annotation].forEach((controller: Controller) => {\n    if (controller) {\n      controller.layout();\n    }\n  });\n}\n","import { DIRECTION } from '../../constant';\nimport { BBox } from '../../dependents';\nimport { Padding } from '../../interface';\n\nexport type PaddingCalCtor = {\n  readonly instance: (top?: number, right?: number, bottom?: number, left?: number) => PaddingCal;\n};\n\n/** @ignore */\nexport class PaddingCal {\n  private top: number;\n  private right: number;\n  private bottom: number;\n  private left: number;\n\n  /**\n   * 使用静态方法创建一个\n   * @param top\n   * @param right\n   * @param bottom\n   * @param left\n   */\n  public static instance(top: number = 0, right: number = 0, bottom: number = 0, left: number = 0) {\n    return new PaddingCal(top, right, bottom, left);\n  }\n\n  /**\n   * 初始的 padding 数据\n   * @param top\n   * @param right\n   * @param bottom\n   * @param left\n   */\n  constructor(top: number = 0, right: number = 0, bottom: number = 0, left: number = 0) {\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n\n  /**\n   * 取最大区间\n   * @param padding\n   */\n  public max(padding: Padding): PaddingCal {\n    const [top, right, bottom, left] = padding;\n\n    this.top = Math.max(this.top, top);\n    this.right = Math.max(this.right, right);\n    this.bottom = Math.max(this.bottom, bottom);\n    this.left = Math.max(this.left, left);\n\n    return this;\n  }\n\n  /**\n   * 四周增加 padding\n   * @param padding\n   */\n  public shrink(padding: Padding): PaddingCal {\n    const [top, right, bottom, left] = padding;\n\n    this.top += top;\n    this.right += right;\n    this.bottom += bottom;\n    this.left += left;\n\n    return this;\n  }\n\n  /**\n   * 在某一个方向增加 padding\n   * @param bbox\n   * @param direction\n   */\n  public inc(bbox: BBox, direction: DIRECTION): PaddingCal {\n    const { width, height } = bbox;\n\n    switch (direction) {\n      case DIRECTION.TOP:\n      case DIRECTION.TOP_LEFT:\n      case DIRECTION.TOP_RIGHT:\n        this.top += height;\n        break;\n\n      case DIRECTION.RIGHT:\n      case DIRECTION.RIGHT_TOP:\n      case DIRECTION.RIGHT_BOTTOM:\n        this.right += width;\n        break;\n\n      case DIRECTION.BOTTOM:\n      case DIRECTION.BOTTOM_LEFT:\n      case DIRECTION.BOTTOM_RIGHT:\n        this.bottom += height;\n        break;\n\n      case DIRECTION.LEFT:\n      case DIRECTION.LEFT_TOP:\n      case DIRECTION.LEFT_BOTTOM:\n        this.left += width;\n        break;\n      default:\n        break;\n    }\n\n    return this;\n  }\n\n  /**\n   * 获得最终的 padding\n   */\n  public getPadding(): Padding {\n    return [this.top, this.right, this.bottom, this.left];\n  }\n\n  /**\n   * clone 一个 padding cal\n   */\n  public clone(): PaddingCal {\n    return new PaddingCal(...this.getPadding());\n  }\n}\n","/**\n * view 中缓存 scale 的类\n */\nimport { deepMix, each, get, isNumber, last } from '@antv/util';\nimport { Scale, Coordinate } from '../../dependents';\nimport { Data, LooseObject, ScaleOption, ViewCfg } from '../../interface';\nimport { createScaleByField, syncScale, getDefaultCategoryScaleRange } from '../../util/scale';\n\n/** @ignore */\ninterface ScaleMeta {\n  readonly key: string;\n  readonly scale: Scale;\n  scaleDef: ScaleOption;\n  syncKey?: string;\n}\n\n/** @ignore */\nexport class ScalePool {\n  /** 所有的 scales */\n  private scales = new Map<string, ScaleMeta>();\n  /** 需要同步的 scale 分组， key: scaleKeyArray */\n  private syncScales = new Map<string, string[]>();\n\n  /**\n   * 创建 scale\n   * @param field\n   * @param data\n   * @param scaleDef\n   * @param key\n   */\n  public createScale(field: string, data: Data, scaleDef: ScaleOption, key: string): Scale {\n    let finalScaleDef = scaleDef;\n\n    const cacheScaleMeta = this.getScaleMeta(key);\n    if (data.length === 0 && cacheScaleMeta) {\n      // 在更新过程中数据变为空，同时 key 对应的 scale 已存在则保持 scale 同类型\n      const cacheScale = cacheScaleMeta.scale;\n      const cacheScaleDef: LooseObject = {\n        type: cacheScale.type,\n      };\n      if (cacheScale.isCategory) {\n        // 如果是分类类型，保持 values\n        cacheScaleDef.values = cacheScale.values;\n      }\n      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);\n    }\n\n    const scale = createScaleByField(field, data, finalScaleDef);\n\n    // 缓存起来\n    this.cacheScale(scale, scaleDef, key);\n\n    return scale;\n  }\n\n  /**\n   * 同步 scale\n   */\n  public sync(coordinate: Coordinate, theme: ViewCfg['theme']) {\n    // 对于 syncScales 中每一个 syncKey 下面的 scale 数组进行同步处理\n    this.syncScales.forEach((scaleKeys: string[], syncKey: string) => {\n      // min, max, values, ranges\n      let min = Number.MAX_SAFE_INTEGER;\n      let max = Number.MIN_SAFE_INTEGER;\n      const values = [];\n\n      // 1. 遍历求得最大最小值，values 等\n      each(scaleKeys, (key: string) => {\n        const scale = this.getScale(key);\n\n        max = isNumber(scale.max) ? Math.max(max, scale.max) : max;\n        min = isNumber(scale.min) ? Math.min(min, scale.min) : min;\n\n        // 去重\n        each(scale.values, (v: any) => {\n          if (!values.includes(v)) {\n            values.push(v);\n          }\n        });\n      });\n\n      // 2. 同步\n      each(scaleKeys, (key: string) => {\n        const scale = this.getScale(key);\n\n        if (scale.isContinuous) {\n          scale.change({\n            min,\n            max,\n            values,\n          });\n        } else if (scale.isCategory) {\n          let range = scale.range;\n          const cacheScaleMeta = this.getScaleMeta(key);\n\n          // 存在 value 值，且用户没有配置 range 配置 to fix https://github.com/antvis/G2/issues/2996\n          if (values && !get(cacheScaleMeta, ['scaleDef', 'range'])) {\n            // 更新 range\n            range = getDefaultCategoryScaleRange(\n              deepMix({}, scale, {\n                values,\n              }),\n              coordinate,\n              theme\n            );\n          }\n          scale.change({\n            values,\n            range,\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * 缓存一个 scale\n   * @param scale\n   * @param scaleDef\n   * @param key\n   */\n  private cacheScale(scale: Scale, scaleDef: ScaleOption, key: string) {\n    // 1. 缓存到 scales\n\n    let sm = this.getScaleMeta(key);\n    // 存在则更新，同时检测类型是否一致\n    if (sm && sm.scale.type === scale.type) {\n      syncScale(sm.scale, scale);\n      sm.scaleDef = scaleDef;\n      // 更新 scaleDef\n    } else {\n      sm = {\n        key,\n        scale,\n        scaleDef,\n      };\n\n      this.scales.set(key, sm);\n    }\n\n    // 2. 缓存到 syncScales，构造 Record<sync, string[]> 数据结构\n    const syncKey = this.getSyncKey(sm);\n    sm.syncKey = syncKey; // 设置 sync 同步的 key\n\n    // 因为存在更新 scale 机制，所以在缓存之前，先从原 syncScales 中去除 sync 的缓存引用\n    this.removeFromSyncScales(key);\n\n    // 存在 sync 标记才进行 sync\n    if (syncKey) {\n      // 不存在这个 syncKey，则创建一个空数组\n      let scaleKeys = this.syncScales.get(syncKey);\n      if (!scaleKeys) {\n        scaleKeys = [];\n        this.syncScales.set(syncKey, scaleKeys);\n      }\n      scaleKeys.push(key);\n    }\n  }\n\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  public getScale(key: string): Scale {\n    let scaleMeta = this.getScaleMeta(key);\n    if (!scaleMeta) {\n      const field = last(key.split('-'));\n      const scaleKeys = this.syncScales.get(field);\n      if (scaleKeys && scaleKeys.length) {\n        scaleMeta = this.getScaleMeta(scaleKeys[0]);\n      }\n    }\n    return scaleMeta && scaleMeta.scale;\n  }\n\n  /**\n   * 在 view 销毁的时候，删除 scale 实例，防止内存泄露\n   * @param key\n   */\n  public deleteScale(key: string) {\n    const scaleMeta = this.getScaleMeta(key);\n    if (scaleMeta) {\n      const { syncKey } = scaleMeta;\n\n      const scaleKeys = this.syncScales.get(syncKey);\n\n      // 移除同步的关系\n      if (scaleKeys && scaleKeys.length) {\n        const idx = scaleKeys.indexOf(key);\n\n        if (idx !== -1) {\n          scaleKeys.splice(idx, 1);\n        }\n      }\n    }\n\n    // 删除 scale 实例\n    this.scales.delete(key);\n  }\n\n  /**\n   * 清空\n   */\n  public clear() {\n    this.scales.clear();\n    this.syncScales.clear();\n  }\n\n  /**\n   * 删除 sync scale 引用\n   * @param key\n   */\n  private removeFromSyncScales(key: string) {\n    this.syncScales.forEach((scaleKeys: string[], syncKey: string) => {\n      const idx = scaleKeys.indexOf(key);\n\n      if (idx !== -1) {\n        scaleKeys.splice(idx, 1);\n\n        // 删除空数组值\n        if (scaleKeys.length === 0) {\n          this.syncScales.delete(syncKey);\n        }\n\n        return false; // 跳出循环\n      }\n    });\n  }\n\n  /**\n   * get sync key\n   * @param sm\n   */\n  private getSyncKey(sm: ScaleMeta): string {\n    const { scale, scaleDef } = sm;\n    const { field } = scale;\n    const sync = get(scaleDef, ['sync']);\n\n    // 如果 sync = true，则直接使用字段名作为 syncKey\n    return sync === true ? field : sync === false ? undefined : sync;\n  }\n\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  private getScaleMeta(key: string): ScaleMeta {\n    return this.scales.get(key);\n  }\n}\n","import { PaddingCalCtor } from '../layout/padding-cal';\nimport { View } from '../view';\n\n/**\n * 默认的 syncViewPadding 逻辑\n * @param chart\n * @param views\n * @param PC: PaddingCalCtor\n */\nexport function defaultSyncViewPadding(chart: View, views: View[], PC: PaddingCalCtor) {\n  const syncPadding = PC.instance();\n\n  // 所有的 view 的 autoPadding 指向同一个引用\n  views.forEach((v: View) => {\n    v.autoPadding = syncPadding.max(v.autoPadding.getPadding());\n  });\n}\n","import { Coordinate } from '@antv/coord';\nimport { IGroup, IShape } from '@antv/g-base';\nimport { each, get } from '@antv/util';\nimport { doAnimate } from '../animate';\nimport { getReplaceAttrs } from '../util/graphics';\n\n/** label 的必要配置 */\ntype Cfg = {\n  data: any;\n  origin: any;\n  animateCfg: any;\n  coordinate: Coordinate;\n};\n\n/**\n * @desc 更新 label (目前没有根据 id 索引，还是会存在一点小问题的，只能根据 idx 索引)\n * @done shape 属性更新\n * @done shape delete\n * @done shape append\n *\n * @param fromShape old labelShape\n * @param toShape new labelShape\n * @param cfg\n */\nexport function updateLabel(fromShape: IGroup, toShape: IGroup, cfg: Cfg): void {\n  const { data, origin, animateCfg, coordinate } = cfg;\n  const updateAnimateCfg = get(animateCfg, 'update');\n\n  fromShape.set('data', data);\n  fromShape.set('origin', origin);\n  fromShape.set('animateCfg', animateCfg);\n  fromShape.set('coordinate', coordinate);\n  fromShape.set('visible', toShape.get('visible'));\n\n  (fromShape.getChildren() || []).forEach((fromChild, idx) => {\n    const toChild = toShape.getChildByIndex(idx) as IShape;\n    if (!toChild) {\n      fromShape.removeChild(fromChild);\n      fromChild.remove(true);\n    } else {\n      fromChild.set('data', data);\n      fromChild.set('origin', origin);\n      fromChild.set('animateCfg', animateCfg);\n      fromChild.set('coordinate', coordinate);\n\n      const newAttrs = getReplaceAttrs(fromChild as IShape, toChild);\n      if (updateAnimateCfg) {\n        doAnimate(fromChild as IShape, updateAnimateCfg, {\n          toAttrs: newAttrs,\n          coordinate,\n        });\n      } else {\n        fromChild.attr(newAttrs);\n      }\n      if (toChild.isGroup()) {\n        updateLabel(fromChild as any, toChild as any, cfg);\n      }\n    }\n  });\n\n  // append\n  each(toShape.getChildren(), (child, idx) => {\n    if (idx >= fromShape.getCount()) {\n      if (!child.destroyed) {\n        fromShape.add(child);\n      }\n    }\n  });\n}\n","import { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { BBox, Coordinate, IGroup, IShape } from '../dependents';\nimport { LabelItem } from '../geometry/label/interface';\nimport { AnimateOption, GeometryLabelLayoutCfg } from '../interface';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n\n/**\n * Labels 实例创建时，传入构造函数的参数定义\n */\nexport interface LabelsGroupCfg {\n  /** label 容器 */\n  container: IGroup;\n  /** label 布局配置 */\n  layout?: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n}\n\n/**\n * Geometry labels 渲染组件\n */\nexport default class Labels {\n  /** 用于指定 labels 布局的类型 */\n  public layout: GeometryLabelLayoutCfg | GeometryLabelLayoutCfg[];\n  /** 图形容器 */\n  public container: IGroup;\n  /** 动画配置 */\n  public animate: AnimateOption | false;\n  /** label 绘制的区域 */\n  public region: BBox;\n\n  /** 存储当前 shape 的映射表，键值为 shape id */\n  public shapesMap: Record<string, IGroup> = {};\n\n  constructor(cfg: LabelsGroupCfg) {\n    const { layout, container } = cfg;\n\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n  public async render(items: LabelItem[], shapes: Record<string, IShape | IGroup>, isUpdate: boolean = false) {\n    const shapesMap = {};\n    const offscreenGroup = this.createOffscreenGroup(); // 创建虚拟分组\n    if (items.length) {\n      // 如果 items 空的话就不进行绘制调整操作\n      // step 1: 在虚拟 group 中创建 shapes\n      for (const item of items) {\n        if (item) {\n          shapesMap[item.id] = this.renderLabel(item, offscreenGroup);\n        }\n      }\n      // [todo] Move layout into Worker.\n      // step 2: 根据布局，调整 labels\n      await this.doLayout(items, shapes, shapesMap);\n\n      // step 3.1: 绘制 labelLine\n      this.renderLabelLine(items, shapesMap);\n      // step 3.2: 绘制 labelBackground\n      this.renderLabelBackground(items, shapesMap);\n      // step 4: 根据用户设置的偏移量调整 label\n      this.adjustLabel(items, shapesMap);\n    }\n\n    // 进行添加、更新、销毁操作\n    const lastShapesMap = this.shapesMap;\n    each(shapesMap, (shape, id) => {\n      if (shape.destroyed) {\n        // label 在布局调整环节被删除了（doLayout）\n        delete shapesMap[id];\n      } else {\n        if (lastShapesMap[id]) {\n          // 图形发生更新\n          const data = shape.get('data');\n          const origin = shape.get('origin');\n          const coordinate = shape.get('coordinate');\n          const currentAnimateCfg = shape.get('animateCfg');\n\n          const currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n          updateLabel(currentShape, shapesMap[id], {\n            data,\n            origin,\n            animateCfg: currentAnimateCfg,\n            coordinate,\n          });\n\n          shapesMap[id] = currentShape; // 保存引用\n        } else {\n          // 新生成的 shape\n          // If container has been destroyed, no need to render labels.\n          if (this.container.destroyed) return;\n          this.container.add(shape);\n          const animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n          if (animateCfg) {\n            doAnimate(shape, animateCfg, {\n              toAttrs: {\n                ...shape.attr(),\n              },\n              coordinate: shape.get('coordinate'),\n            });\n          }\n        }\n        delete lastShapesMap[id];\n      }\n    });\n\n    // 移除\n    each(lastShapesMap, (deleteShape) => {\n      const animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n      if (animateCfg) {\n        doAnimate(deleteShape, animateCfg, {\n          toAttrs: null,\n          coordinate: deleteShape.get('coordinate'),\n        });\n      } else {\n        deleteShape.remove(true); // 移除\n      }\n    });\n\n    this.shapesMap = shapesMap;\n    offscreenGroup.destroy();\n  }\n\n  /** 清除当前 labels */\n  public clear() {\n    this.container.clear();\n    this.shapesMap = {};\n  }\n\n  /** 销毁 */\n  public destroy() {\n    this.container.destroy();\n    this.shapesMap = null;\n  }\n\n  private renderLabel(cfg: LabelItem, container: IGroup): IGroup {\n    const { id, elementId, data, mappingData, coordinate, animate, content, capture } = cfg;\n    const shapeAppendCfg = {\n      id,\n      elementId,\n      capture,\n      data,\n      origin: {\n        ...mappingData,\n        data: mappingData[FIELD_ORIGIN],\n      },\n      coordinate,\n    };\n    const labelGroup = container.addGroup({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg:\n        this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate),\n      ...shapeAppendCfg,\n    });\n    let labelShape;\n    if ((content.isGroup && content.isGroup()) || (content.isShape && content.isShape())) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      const { width, height } = content.getCanvasBBox();\n      const textAlign = get(cfg, 'textAlign', 'left');\n\n      let x = cfg.x;\n      const y = cfg.y - height / 2;\n\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      const fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', {\n        attrs: {\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content,\n          ...cfg.style,\n          fill: isNull(fill) ? cfg.color : fill,\n        },\n        ...shapeAppendCfg,\n      });\n    }\n\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n    return labelGroup;\n  }\n\n  // 根据type对label布局\n  private async doLayout(items: LabelItem[], shapes: Record<string, IShape | IGroup>, shapesMap: Record<string, IGroup>) {\n    if (this.layout) {\n      const layouts = isArray(this.layout) ? this.layout : [this.layout];\n      await Promise.all(layouts.map((layout: GeometryLabelLayoutCfg) => {\n        const layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n        if (!layoutFn) return;\n\n        const labelShapes = [];\n        const geometryShapes = [];\n        each(shapesMap, (labelShape, id) => {\n          labelShapes.push(labelShape);\n          geometryShapes.push(shapes[labelShape.get('elementId')]);\n        });\n        // [todo] Refactor more layout into Worker.\n        return layoutFn(items, labelShapes, geometryShapes, this.region, layout.cfg);\n      }));\n    }\n  }\n\n  private renderLabelLine(labelItems: LabelItem[], shapesMap) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      if (!labelItem || !coordinate) {\n        return;\n      }\n      const center = coordinate.getCenter();\n      const radius = coordinate.getRadius();\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n      const labelLineCfg = get(labelItem, 'labelLine', {});\n      const id = labelItem.id;\n      let path = labelLineCfg.path;\n      if (!path) {\n        const start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [\n          ['M', start.x, start.y],\n          ['L', labelItem.x, labelItem.y],\n        ];\n      }\n      const labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false, // labelLine 默认不参与事件捕获\n          attrs: {\n            path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null,\n            ...labelLineCfg.style,\n          },\n          id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate,\n        });\n      }\n    });\n  }\n\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n  private renderLabelBackground(labelItems: LabelItem[], shapesMap) {\n    each(labelItems, (labelItem) => {\n      const coordinate: Coordinate = get(labelItem, 'coordinate');\n      const background: LabelItem['background'] = get(labelItem, 'background');\n      if (!background || !coordinate) {\n        return;\n      }\n\n      const id = labelItem.id;\n      const labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        const labelContentShape = labelGroup.getChildren()[0];\n        if (labelContentShape) {\n          const { rotation, ...box } = getLabelBackgroundInfo(labelGroup, labelItem, background.padding);\n          const backgroundShape = labelGroup.addShape('rect', {\n            attrs: {\n              ...box,\n              ...(background.style || {}),\n            },\n            id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate,\n          });\n          backgroundShape.setZIndex(-1);\n\n          if (rotation) {\n            const matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  }\n\n  private createOffscreenGroup() {\n    const container = this.container;\n    const GroupClass = container.getGroupBase(); // 获取分组的构造函数\n    const newGroup = new GroupClass({});\n    return newGroup;\n  }\n\n  private adjustLabel(items: LabelItem[], shapesMap) {\n    each(items, (item) => {\n      if (item) {\n        const id = item.id;\n        const labelGroup = shapesMap[id];\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          const labelShapes = labelGroup.findAll((ele) => ele.get('type') !== 'path');\n          each(labelShapes, (labelShape) => {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  }\n}\n","/**\n * view 中三层 group 分层 key\n */\nexport enum LAYER {\n  /** 前景层 */\n  FORE = 'fore',\n  /** 中间层 */\n  MID = 'mid',\n  /** 背景层 */\n  BG = 'bg',\n}\n\n/**\n * 组件在画布的布局方位 12 方位\n */\nexport enum DIRECTION {\n  TOP = 'top',\n  TOP_LEFT = 'top-left',\n  TOP_RIGHT = 'top-right',\n  RIGHT = 'right',\n  RIGHT_TOP = 'right-top',\n  RIGHT_BOTTOM = 'right-bottom',\n  LEFT = 'left',\n  LEFT_TOP = 'left-top',\n  LEFT_BOTTOM = 'left-bottom',\n  BOTTOM = 'bottom',\n  BOTTOM_LEFT = 'bottom-left',\n  BOTTOM_RIGHT = 'bottom-right',\n  RADIUS = 'radius',\n  CIRCLE = 'circle',\n  // no direction information\n  NONE = 'none',\n}\n\n/**\n * 组件的类型，可能会影响到布局算法\n */\nexport enum COMPONENT_TYPE {\n  /** axis 组件 */\n  AXIS = 'axis',\n  /** grid 组件 */\n  GRID = 'grid',\n  /** legend 组件 */\n  LEGEND = 'legend',\n  /** tooltip 组件 */\n  TOOLTIP = 'tooltip',\n  /** annotation 组件 */\n  ANNOTATION = 'annotation',\n  /** 缩略轴组件 */\n  SLIDER = 'slider',\n  /** 滚动条组件 */\n  SCROLLBAR = 'scrollbar',\n  /** 其他组件，自定义组件 */\n  OTHER = 'other',\n}\n\n/**\n * 三层 group 的 z index\n */\nexport const GROUP_Z_INDEX = {\n  FORE: 3,\n  MID: 2,\n  BG: 1,\n};\n\n/**\n * View 的生命周期阶段（和 3.x 的生命周期略有不同）\n * 我们需要先确定在那写场景需要用到生命周期，如果只是为了在生命周期插入一下什么组件之类的，那么在现有架构就是不需要的\n */\nexport enum VIEW_LIFE_CIRCLE {\n  BEFORE_RENDER = 'beforerender',\n  AFTER_RENDER = 'afterrender',\n\n  BEFORE_PAINT = 'beforepaint',\n  AFTER_PAINT = 'afterpaint',\n\n  BEFORE_CHANGE_DATA = 'beforechangedata',\n  AFTER_CHANGE_DATA = 'afterchangedata',\n\n  BEFORE_CLEAR = 'beforeclear',\n  AFTER_CLEAR = 'afterclear',\n\n  BEFORE_DESTROY = 'beforedestroy',\n\n  BEFORE_CHANGE_SIZE = 'beforechangesize',\n  AFTER_CHANGE_SIZE = 'afterchangesize',\n}\n\n/**\n * geometry 的生命周期\n */\nexport enum GEOMETRY_LIFE_CIRCLE {\n  BEFORE_DRAW_ANIMATE = 'beforeanimate',\n  AFTER_DRAW_ANIMATE = 'afteranimate',\n\n  BEFORE_RENDER_LABEL = 'beforerenderlabel',\n  AFTER_RENDER_LABEL = 'afterrenderlabel',\n}\n\n/**\n * 绘图区的事件列表\n */\nexport enum PLOT_EVENTS {\n  // mouse 事件\n  MOUSE_ENTER = 'plot:mouseenter',\n  MOUSE_DOWN = 'plot:mousedown',\n  MOUSE_MOVE = 'plot:mousemove',\n  MOUSE_UP = 'plot:mouseup',\n  MOUSE_LEAVE = 'plot:mouseleave',\n  // 移动端事件\n  TOUCH_START = 'plot:touchstart',\n  TOUCH_MOVE = 'plot:touchmove',\n  TOUCH_END = 'plot:touchend',\n  TOUCH_CANCEL = 'plot:touchcancel',\n  // click 事件\n  CLICK = 'plot:click',\n  DBLCLICK = 'plot:dblclick',\n  CONTEXTMENU = 'plot:contextmenu',\n\n  LEAVE = 'plot:leave',\n  ENTER = 'plot:enter',\n}\n\n/**\n * Element 图形交互状态\n */\nexport enum ELEMENT_STATE {\n  ACTIVE = 'active',\n  INACTIVE = 'inactive',\n  SELECTED = 'selected',\n  DEFAULT = 'default',\n}\n\n/** 参与分组的图形属性名 */\nexport const GROUP_ATTRS = ['color', 'shape', 'size'];\n/** 存储原始数据的字段名 */\nexport const FIELD_ORIGIN = '_origin';\n/** 最小的图表宽度 */\nexport const MIN_CHART_WIDTH = 1;\n/** 最小的图表高度 */\nexport const MIN_CHART_HEIGHT = 1;\n/** 辅助组件占图表的尺寸的最大比例：如图表上方的图例最多占图表高度的25% */\nexport const COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;\n"],"names":["calculatePadding","view","padding","isAutoPadding","PaddingCal","__spreadArray","parsePadding","viewBBox","paddingCal","axisComponents","paddingComponents","otherComponents","each","getComponents","co","type","COMPONENT_TYPE","push","includes","bboxObject","getLayoutBBox","exceed","BBox","x","y","width","height","max","component","direction","componentPadding","get","componentBBox","expand","inc","defaultLayout","axis","getController","legend","annotation","forEach","controller","layout","top","right","bottom","left","this","Math","bbox","DIRECTION","apply","getPadding","scales","Map","syncScales","ScalePool","field","data","scaleDef","key","finalScaleDef","cacheScaleMeta","getScaleMeta","length","cacheScale","scale","cacheScaleDef","isCategory","values","deepMix","createScaleByField","coordinate","theme","scaleKeys","syncKey","min","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","_this","getScale","isNumber","v","isContinuous","change","range","getDefaultCategoryScaleRange","sm","syncScale","set","getSyncKey","removeFromSyncScales","scaleMeta","last","split","idx","indexOf","splice","delete","clear","sync","undefined","defaultSyncViewPadding","chart","views","PC","syncPadding","instance","autoPadding","updateLabel","fromShape","toShape","cfg","origin","animateCfg","updateAnimateCfg","getChildren","fromChild","toChild","getChildByIndex","newAttrs","getReplaceAttrs","doAnimate","toAttrs","attr","isGroup","removeChild","remove","child","getCount","destroyed","add","shapesMap","container","Labels","items","shapes","isUpdate","offscreenGroup","createOffscreenGroup","items_1","items_1_1","item","id","renderLabel","doLayout","_b","renderLabelLine","renderLabelBackground","adjustLabel","lastShapesMap","shape","origin_1","currentAnimateCfg","currentShape","deleteShape","destroy","labelShape","elementId","mappingData","animate","content","shapeAppendCfg","capture","FIELD_ORIGIN","labelGroup","addGroup","__assign","name","isShape","getCanvasBBox","textAlign","translate","fill","addShape","attrs","textBaseline","text","style","isNull","color","rotate","layouts","isArray","Promise","all","map","layoutFn","getGeometryLabelLayout","labelShapes","geometryShapes","region","_a","labelItems","labelItem","center","getCenter","radius","getRadius","labelLine","labelLineCfg","path","start","polarToCartesian","angle","stroke","background","labelContentShape","getLabelBackgroundInfo","rotation","box","backgroundShape","setZIndex","matrix","getMatrix","setMatrix","getGroupBase","findAll","ele","offsetX","offsetY","LAYER","VIEW_LIFE_CIRCLE","GEOMETRY_LIFE_CIRCLE","PLOT_EVENTS","ELEMENT_STATE","GROUP_Z_INDEX","FORE","MID","BG","GROUP_ATTRS","MIN_CHART_WIDTH","MIN_CHART_HEIGHT","COMPONENT_MAX_VIEW_PERCENTAGE"],"sourceRoot":""}