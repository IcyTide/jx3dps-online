{"version":3,"file":"static/js/2701.1fe4af86.js","mappings":"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","sources":["../node_modules/@antv/g2/src/geometry/point.ts","../node_modules/@antv/g2/src/geometry/polygon.ts","../node_modules/@antv/g2/src/geometry/schema.ts","../node_modules/@antv/g2/src/geometry/shape/area/index.ts","../node_modules/@antv/g2/src/geometry/shape/area/line.ts","../node_modules/@antv/g2/src/geometry/shape/area/smooth-line.ts","../node_modules/@antv/g2/src/geometry/shape/area/smooth.ts","../node_modules/@antv/g2/src/geometry/shape/area/util.ts","../node_modules/@antv/g2/src/geometry/shape/base.ts","../node_modules/@antv/g2/src/geometry/shape/constant.ts","../node_modules/@antv/g2/src/geometry/shape/edge/arc.ts","../node_modules/@antv/g2/src/geometry/shape/edge/index.ts","../node_modules/@antv/g2/src/geometry/shape/edge/smooth.ts","../node_modules/@antv/g2/src/geometry/shape/edge/util.ts","../node_modules/@antv/g2/src/geometry/shape/edge/vhv.ts","../node_modules/@antv/g2/src/geometry/shape/interval/funnel.ts","../node_modules/@antv/g2/src/geometry/shape/interval/hollow-rect.ts","../node_modules/@antv/g2/src/geometry/shape/interval/index.ts","../node_modules/@antv/g2/src/geometry/shape/interval/line.ts","../node_modules/@antv/g2/src/geometry/shape/interval/pyramid.ts","../node_modules/@antv/g2/src/geometry/shape/interval/tick.ts","../node_modules/@antv/g2/src/geometry/shape/interval/util.ts","../node_modules/@antv/g2/src/geometry/shape/line/index.ts"],"sourcesContent":["import { MappingDatum, ShapeInfo } from '../interface';\nimport Geometry from './base';\n/** 引入 Point 对应的 ShapeFactory */\nimport './shape/point';\n\n/**\n * Point 几何标记。\n * 常用于绘制点图。\n */\nexport default class Point extends Geometry {\n  public readonly type: string = 'point';\n  public readonly shapeType: string = 'point';\n  protected generatePoints: boolean = true;\n\n  /**\n   * 获取一个点的绘制信息。\n   * @param mappingDatum\n   * @returns draw cfg\n   */\n  protected getDrawCfg(mappingDatum: MappingDatum): ShapeInfo {\n    const shapeCfg = super.getDrawCfg(mappingDatum);\n\n    return {\n      ...shapeCfg,\n      isStack: !!this.getAdjust('stack'), // 层叠点图\n    };\n  }\n}\n","import { isArray } from '@antv/util';\nimport { Datum } from '../interface';\nimport Geometry from './base';\n/** 引入 Path 对应的 ShapeFactory */\nimport './shape/polygon';\n\n/**\n * Polygon 几何标记。\n * 常用于绘制色块图、日历图等。\n */\nexport default class Polygon extends Geometry {\n  public readonly type: string = 'polygon';\n  public readonly shapeType: string = 'polygon';\n  protected generatePoints: boolean = true;\n\n  /**\n   * 获取 Shape 的关键点数据。\n   * @param obj\n   * @returns\n   */\n  protected createShapePointsCfg(obj: Datum) {\n    const cfg: any = super.createShapePointsCfg(obj);\n    let x = cfg.x;\n    let y = cfg.y;\n    let temp;\n    // x y 都是数组时，不做处理\n    if (!(isArray(x) && isArray(y))) {\n      const xScale = this.getXScale();\n      const yScale = this.getYScale();\n      const xCount = xScale.values.length;\n      const yCount = yScale.values.length;\n      const xOffset = (0.5 * 1) / xCount;\n      const yOffset = (0.5 * 1) / yCount;\n\n      if (xScale.isCategory && yScale.isCategory) {\n        // 如果x,y都是分类\n        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];\n        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];\n      } else if (isArray(x)) {\n        // x 是数组\n        temp = x;\n        x = [temp[0], temp[0], temp[1], temp[1]];\n        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];\n      } else if (isArray(y)) {\n        // y 是数组\n        temp = y;\n        y = [temp[0], temp[1], temp[1], temp[0]];\n        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];\n      }\n      cfg.x = x;\n      cfg.y = y;\n    }\n    return cfg;\n  }\n}\n","import { LooseObject } from '../interface';\nimport { getXDimensionLength } from '../util/coordinate';\nimport Geometry from './base';\n/** 引入对应的 ShapeFactory */\nimport './shape/schema';\nimport { getDefaultSize } from './util/shape-size';\n\n/**\n * Schema 几何标记，用于一些自定义图形的绘制，比如箱型图、股票图等。\n */\nexport default class Schema extends Geometry {\n  public readonly type: string = 'schema';\n  public readonly shapeType: string = 'schema';\n  protected generatePoints: boolean = true;\n\n  /**\n   * 获取 Shape 的关键点数据。\n   * @param record\n   * @returns\n   */\n  protected createShapePointsCfg(record: LooseObject) {\n    const cfg = super.createShapePointsCfg(record);\n\n    // 计算每个 shape 的 size\n    let size;\n    const sizeAttr = this.getAttribute('size');\n    if (sizeAttr) {\n      size = this.getAttributeValues(sizeAttr, record)[0];\n      // 归一化\n      const coordinate = this.coordinate;\n      const coordinateWidth = getXDimensionLength(coordinate);\n      size = size / coordinateWidth;\n    } else {\n      if (!this.defaultSize) {\n        this.defaultSize = getDefaultSize(this);\n      }\n      size = this.defaultSize;\n    }\n    cfg.size = size;\n\n    return cfg;\n  }\n}\n","import { isArray } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getShapeAttrs } from './util';\n\nconst AreaShapeFactory = registerShapeFactory('area', {\n  defaultShapeType: 'area',\n  getDefaultPoints(pointInfo: ShapePoint): Point[] {\n    // area 基本标记的绘制需要获取上下两边的顶点\n    const { x, y0 } = pointInfo;\n    const y = isArray(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];\n\n    return y.map((yItem: number) => {\n      return {\n        x: x as number,\n        y: yItem,\n      };\n    });\n  },\n});\n\n// Area 几何标记默认的 shape：填充的区域图\nregisterShape('area', 'area', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const attrs = getShapeAttrs(cfg, false, false, this);\n    const shape = container.addShape({\n      type: 'path',\n      attrs,\n      name: 'area',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: (x: number, y: number, r: number = 5.5) => {\n        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];\n      },\n      style: {\n        r: 5,\n        fill: color,\n        fillOpacity: 1,\n      },\n    };\n  },\n});\n\nexport default AreaShapeFactory;\n","import { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\nimport { registerShape } from '../base';\nimport { getShapeAttrs } from './util';\n\n/**\n * 描边但不填充的区域图\n */\nregisterShape('area', 'line', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const attrs = getShapeAttrs(cfg, true, false, this);\n    const shape = container.addShape({\n      type: 'path',\n      attrs,\n      name: 'area',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: (x: number, y: number, r: number = 5.5) => {\n        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];\n      },\n      style: {\n        r: 5,\n        stroke: color,\n        fill: null,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getConstraint, getShapeAttrs } from './util';\n\n/** 描边的平滑曲面图 */\nregisterShape('area', 'smooth-line', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const coordinate = this.coordinate;\n    const attrs = getShapeAttrs(cfg, true, true, this, getConstraint(coordinate));\n    const shape = container.addShape({\n      type: 'path',\n      attrs,\n      name: 'area',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: (x: number, y: number, r: number = 5.5) => {\n        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];\n      },\n      style: {\n        r: 5,\n        stroke: color,\n        fill: null,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getConstraint, getShapeAttrs } from './util';\n\n/**\n * 填充的平滑曲面图\n */\nregisterShape('area', 'smooth', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const coordinate = this.coordinate;\n    const attrs = getShapeAttrs(cfg, false, true, this, getConstraint(coordinate));\n    const shape = container.addShape({\n      type: 'path',\n      attrs,\n      name: 'area',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: (x: number, y: number, r: number = 5.5) => {\n        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];\n      },\n      style: {\n        r: 5,\n        fill: color,\n        fillOpacity: 1,\n      },\n    };\n  },\n});\n","import { each } from '@antv/util';\nimport { Coordinate, PathCommand } from '../../../dependents';\nimport { Point, Position, Shape, ShapeInfo } from '../../../interface';\n\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\n\nfunction getPath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n): PathCommand[] {\n  let path = [];\n\n  if (points.length) {\n    const topLinePoints = []; // area 区域上部分\n    let bottomLinePoints = []; // area 区域下部分\n    for (let i = 0, len = points.length; i < len; i++) {\n      const point = points[i];\n      topLinePoints.push(point[1]);\n      bottomLinePoints.push(point[0]);\n    }\n    bottomLinePoints = bottomLinePoints.reverse();\n\n    each([topLinePoints, bottomLinePoints], (pointsData, index) => {\n      let subPath = [];\n      const parsedPoints = registeredShape.parsePoints(pointsData);\n      const p1 = parsedPoints[0];\n\n      if (topLinePoints.length === 1 && bottomLinePoints.length === 1) {\n        // 都只有一个点，绘制一条竖线\n        subPath =\n          index === 0\n            ? [\n                ['M', p1.x - 0.5, p1.y],\n                ['L', p1.x + 0.5, p1.y],\n              ]\n            : [\n                ['L', p1.x + 0.5, p1.y],\n                ['L', p1.x - 0.5, p1.y],\n              ];\n      } else {\n        if (isInCircle) {\n          parsedPoints.push({ x: p1.x, y: p1.y });\n        }\n        if (smooth) {\n          subPath = getSplinePath(parsedPoints, false, constraint);\n        } else {\n          subPath = getLinePath(parsedPoints, false);\n        }\n        if (index > 0) {\n          subPath[0][0] = 'L';\n        }\n      }\n\n      path = path.concat(subPath);\n    });\n\n    path.push(['Z']);\n  }\n\n  return path;\n}\n\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(\n  cfg: ShapeInfo,\n  isStroke: boolean,\n  smooth: boolean,\n  registeredShape: Shape,\n  constraint?: Position[]\n) {\n  const attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  const { connectNulls, isInCircle, points, showSinglePoint } = cfg;\n  const pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n\n  let path = [];\n  for (let i = 0, len = pathPoints.length; i < len; i++) {\n    const eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n  attrs.path = path;\n\n  return attrs;\n}\n\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate: Coordinate): Position[] {\n  const { start, end } = coordinate;\n  return [\n    [start.x, end.y],\n    [end.x, start.y],\n  ];\n}\n","import { LooseObject } from '@antv/g-svg';\nimport { parsePathString } from '@antv/path-util';\nimport { deepMix, get, upperFirst } from '@antv/util';\nimport { IGroup, IShape, PathCommand } from '../../dependents';\nimport {\n  Point,\n  RegisterShape,\n  RegisterShapeFactory,\n  Shape,\n  ShapeFactory,\n  ShapeInfo,\n  ShapeMarkerAttrs,\n  ShapeMarkerCfg,\n  ShapePoint,\n} from '../../interface';\n\nimport { convertNormalPath, convertPolarPath } from './util/path';\n\n/** ShapeFactory 基类 */\nconst ShapeFactoryBase = {\n  /** 坐标系对象 */\n  coordinate: null,\n  /** 默认绘制的 Shape 类型 */\n  defaultShapeType: null,\n  /** 主题样式 */\n  theme: null,\n  /**\n   * 获取 shape 绘制需要的关键点\n   * @param shapeType shape 类型\n   * @param shapePoint 每条数据映射后的坐标点以及 size 数值\n   * @returns 图形关键点信息\n   */\n  getShapePoints(shapeType: string, shapePoint: ShapePoint) {\n    const shape = this.getShape(shapeType);\n    if (shape.getPoints) {\n      return shape.getPoints(shapePoint);\n    }\n\n    return this.getDefaultPoints(shapePoint);\n  },\n  /**\n   * 根据 shape 类型获取具体的 shape 实例\n   * @param shapeType string shape 的类型\n   * @returns\n   */\n  getShape(shapeType: string): Shape {\n    const shape = this[shapeType] || this[this.defaultShapeType];\n    shape.coordinate = this.coordinate;\n\n    return shape;\n  },\n  /**\n   * 获取 shape 的默认关键点\n   * @override\n   */\n  getDefaultPoints() {\n    return [];\n  },\n  /**\n   * 获取 shape 的默认绘制样式 (内置的 shapeFactory 均有注册默认样式)\n   */\n  getDefaultStyle(geometryTheme: LooseObject): LooseObject {\n    return get(geometryTheme, [this.defaultShapeType, 'default', 'style'], {});\n  },\n  /**\n   * 获取 shape 对应的缩略图配置信息。\n   * @param shapeType shape 类型\n   * @param color 颜色\n   * @param isInPolar 是否在极坐标系下\n   * @returns 返回缩略图 marker 配置。\n   */\n  getMarker(shapeType: string, markerCfg: ShapeMarkerCfg): ShapeMarkerAttrs {\n    let shape = this.getShape(shapeType);\n\n    if (!shape.getMarker) {\n      const defaultShapeType = this.defaultShapeType;\n      shape = this.getShape(defaultShapeType);\n    }\n\n    const theme = this.theme;\n    const shapeStyle = get(theme, [shapeType, 'default'], {});\n    const markerStyle = shape.getMarker(markerCfg);\n\n    return deepMix({}, shapeStyle, markerStyle);\n  },\n  /**\n   * 绘制 shape\n   * @override\n   * @param shapeType 绘制的 shape 类型\n   * @param cfg 绘制 shape 需要的信息\n   * @param element Element 实例\n   * @returns\n   */\n  drawShape(shapeType: string, cfg: ShapeInfo, container: IGroup): IShape | IGroup {\n    const shape = this.getShape(shapeType);\n    return shape.draw(cfg, container);\n  },\n};\n\n/** Shape 基类 */\nconst ShapeBase = {\n  /** 坐标系对象 */\n  coordinate: null,\n  /**\n   * 将归一化的 path 转换成坐标系下的 path\n   * @param path 归一化的路径\n   * @returns\n   */\n  parsePath(path: string): PathCommand[] {\n    const coordinate = this.coordinate;\n    let parsedPath = parsePathString(path);\n    if (coordinate.isPolar) {\n      parsedPath = convertPolarPath(coordinate, parsedPath);\n    } else {\n      parsedPath = convertNormalPath(coordinate, parsedPath);\n    }\n    return parsedPath;\n  },\n  /**\n   * 将归一化的坐标转换成画布坐标\n   * @param point 归一化的坐标点数据\n   * @returns\n   */\n  parsePoint(point: Point): Point {\n    const coordinate = this.coordinate;\n    return coordinate.convert(point);\n  },\n  /**\n   * 0～1 points 转 画布 points\n   * @param points 节点集合\n   * @returns\n   */\n  parsePoints(points: Point[]): Point[] {\n    const coordinate = this.coordinate;\n    return points.map((point) => {\n      return coordinate.convert(point);\n    });\n  },\n  /**\n   * 绘制 shape\n   * @override\n   */\n  draw(cfg: ShapeInfo, container: IGroup) {},\n};\n\nconst ShapeFactoryMap = {};\n\n/**\n * 注册 ShapeFactory。\n * @param factoryName  ShapeFactory 名称，对应 Geometry 几何标记名称。\n * @param cfg 注册 ShapeFactory 需要覆写定义的属性。\n * @returns 返回 ShapeFactory 对象。\n */\nexport function registerShapeFactory(factoryName: string, cfg: RegisterShapeFactory): ShapeFactory {\n  const className = upperFirst(factoryName);\n  const geomObj = {\n    ...ShapeFactoryBase,\n    ...cfg,\n    geometryType: factoryName,\n  };\n  ShapeFactoryMap[className] = geomObj;\n  return geomObj;\n}\n\n/**\n * 注册 Shape。\n * @param factoryName 对应的 ShapeFactory 名称。\n * @param shapeType 注册的 shape 名称。\n * @param cfg 注册 Shape 需要覆写定义的属性。\n * @returns shape 返回注册的 shape 对象。\n */\nexport function registerShape(factoryName: string, shapeType: string, cfg: RegisterShape): Shape {\n  const className = upperFirst(factoryName);\n  const factory = ShapeFactoryMap[className];\n  const shapeObj = {\n    ...ShapeBase,\n    ...cfg,\n  };\n  factory[shapeType] = shapeObj;\n  return shapeObj;\n}\n\n/**\n * 获取 factoryName 对应的 shapeFactory\n * @param factoryName\n * @returns shape factory\n */\nexport function getShapeFactory(factoryName: string): ShapeFactory {\n  const className = upperFirst(factoryName);\n  return ShapeFactoryMap[className];\n}\n","/**\n * Name of Background Shape\n */\nexport const BACKGROUND_SHAPE = 'element-background';\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { getArcPath } from '../../../util/graphics';\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\nimport { getCPath, getQPath } from './util';\n\nfunction getArcShapePath(from: Point, to: Point, center: Point) {\n  const sub = getQPath(to, center);\n  const path = [['M', from.x, from.y]];\n  path.push(sub);\n  return path;\n}\n\nfunction getArcShapeWeightPath(points: Point[], center: Point) {\n  const arc1 = getQPath(points[1], center);\n  const arc2 = getQPath(points[3], center);\n  const path = [['M', points[0].x, points[0].y]];\n  path.push(arc2);\n  path.push(['L', points[3].x, points[3].y]);\n  path.push(['L', points[2].x, points[2].y]);\n  path.push(arc1);\n  path.push(['L', points[1].x, points[1].y]);\n  path.push(['L', points[0].x, points[0].y]);\n  path.push(['Z']);\n  return path;\n}\n\n// 弧线包括笛卡尔坐标系下的半圆弧线、极坐标系下以圆心为控制点的二阶曲线、笛卡尔坐标系下带权重的三阶曲线、极坐标系下带权重的以圆心为控制点的二阶曲线\nregisterShape('edge', 'arc', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false, 'lineWidth');\n\n    let points = cfg.points as Point[];\n    const type = points.length > 2 ? 'weight' : 'normal';\n    let path;\n    if (cfg.isInCircle) {\n      const center = { x: 0, y: 1 };\n      if (type === 'normal') {\n        path = getArcShapePath(points[0], points[1], center);\n      } else {\n        style.fill = style.stroke;\n        path = getArcShapeWeightPath(points, center);\n      }\n      path = this.parsePath(path);\n\n      return container.addShape('path', {\n        attrs: {\n          ...style,\n          path,\n        },\n      });\n    } else {\n      if (type === 'normal') {\n        points = this.parsePoints(points);\n        path = getArcPath(\n          (points[1].x + points[0].x) / 2,\n          points[0].y,\n          Math.abs(points[1].x - points[0].x) / 2,\n          Math.PI,\n          Math.PI * 2\n        );\n        return container.addShape('path', {\n          attrs: {\n            ...style,\n            path,\n          },\n        });\n      } else {\n        const c1 = getCPath(points[1], points[3]);\n        const c2 = getCPath(points[2], points[0]);\n\n        path = [\n          ['M', points[0].x, points[0].y],\n          ['L', points[1].x, points[1].y],\n          c1,\n          ['L', points[3].x, points[3].y],\n          ['L', points[2].x, points[2].y],\n          c2,\n          ['Z'],\n        ];\n        path = this.parsePath(path);\n        style.fill = style.stroke;\n\n        return container.addShape('path', {\n          attrs: {\n            ...style,\n            path,\n          },\n        });\n      }\n    }\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4.5,\n        fill: markerCfg.color,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\n\nconst EdgeShapeFactory = registerShapeFactory('edge', {\n  defaultShapeType: 'line',\n  getDefaultPoints(pointInfo: ShapePoint): Point[] {\n    return splitPoints(pointInfo);\n  },\n});\n\nregisterShape('edge', 'line', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false, 'lineWidth');\n    const path = getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);\n    return container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4.5,\n        fill: markerCfg.color,\n      },\n    };\n  },\n});\n\nexport default EdgeShapeFactory;\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\nimport { getCPath } from './util';\n\nfunction getSmoothPath(from: Point, to: Point) {\n  const sub = getCPath(from, to);\n  const path = [['M', from.x, from.y]];\n\n  path.push(sub);\n  return path;\n}\n\nregisterShape('edge', 'smooth', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false, 'lineWidth');\n    const points = cfg.points;\n    const path = this.parsePath(getSmoothPath(points[0] as Point, points[1] as Point));\n    return container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4.5,\n        fill: markerCfg.color,\n      },\n    };\n  },\n});\n","import { each } from '@antv/util';\nimport { Point } from '../../../interface';\n\n/**\n * @ignore\n * Gets cpath\n * @param from\n * @param to\n * @returns\n */\nexport function getCPath(from: Point, to: Point) {\n  return ['C', (from.x * 1) / 2 + (to.x * 1) / 2, from.y, (from.x * 1) / 2 + (to.x * 1) / 2, to.y, to.x, to.y];\n}\n\n/**\n * @ignore\n * Gets qpath\n * @param to\n * @param center\n * @returns\n */\nexport function getQPath(to: Point, center: Point) {\n  const points = [];\n  points.push({\n    x: center.x,\n    y: center.y,\n  });\n  points.push(to);\n\n  const sub = ['Q'];\n  each(points, (point) => {\n    sub.push(point.x, point.y);\n  });\n\n  return sub;\n}\n","import { each } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\n\nconst CORNER_PERCENT = 1 / 3;\n\nfunction getVHVPath(from: Point, to: Point) {\n  const points = [];\n  points.push({\n    x: from.x,\n    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,\n  });\n  points.push({\n    x: to.x,\n    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT,\n  });\n  points.push(to);\n\n  const path = [['M', from.x, from.y]];\n  each(points, (point) => {\n    path.push(['L', point.x, point.y]);\n  });\n\n  return path;\n}\n\nregisterShape('edge', 'vhv', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false, 'lineWidth');\n    const points = cfg.points;\n    const path = this.parsePath(getVHVPath(points[0] as Point, points[1] as Point));\n    return container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n    });\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    return {\n      symbol: 'circle',\n      style: {\n        r: 4.5,\n        fill: markerCfg.color,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\nimport { getFunnelPath, getRectPoints } from './util';\n\n/** 漏斗图 */\nregisterShape('interval', 'funnel', {\n  getPoints(shapePoint: ShapePoint) {\n    shapePoint.size = shapePoint.size * 2; // 漏斗图的 size 是柱状图的两倍\n    return getRectPoints(shapePoint);\n  },\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, false, true);\n    const path = this.parsePath(getFunnelPath(cfg.points as Point[], cfg.nextPoints as Point[], false));\n    const shape = container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n      name: 'interval',\n    });\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'square',\n      style: {\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { BACKGROUND_SHAPE } from '../constant';\nimport { getBackgroundRectStyle, getStyle } from '../util/get-style';\nimport { getBackgroundRectPath, getRectPath } from './util';\n\n/** 描边柱状图 */\nregisterShape('interval', 'hollow-rect', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false);\n    let group = container;\n    const backgroundCfg = cfg?.background;\n    if (backgroundCfg) {\n      group = container.addGroup();\n      const backgroundStyle = getBackgroundRectStyle(cfg);\n      const backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points) as Point[], this.coordinate);\n      group.addShape('path', {\n        attrs: {\n          ...backgroundStyle,\n          path: backgroundPath,\n        },\n        capture: false,\n        zIndex: -1,\n        name: BACKGROUND_SHAPE,\n      });\n    }\n\n    const path = this.parsePath(getRectPath(cfg.points as Point[]));\n    const shape = group.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n      name: 'interval',\n    });\n\n    return backgroundCfg ? group : shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color, isInPolar } = markerCfg;\n    if (isInPolar) {\n      return {\n        symbol: 'circle',\n        style: {\n          r: 4.5,\n          stroke: color,\n          fill: null,\n        },\n      };\n    }\n\n    return {\n      symbol: 'square',\n      style: {\n        r: 4,\n        stroke: color,\n        fill: null,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape, registerShapeFactory } from '../base';\nimport { BACKGROUND_SHAPE } from '../constant';\nimport { getBackgroundRectStyle, getStyle } from '../util/get-style';\nimport { getBackgroundRectPath, getIntervalRectPath, getRectPoints, getRectWithCornerRadius } from './util';\n\n/** Interval 的 shape 工厂 */\nconst IntervalShapeFactory = registerShapeFactory('interval', {\n  defaultShapeType: 'rect',\n  getDefaultPoints(pointInfo: ShapePoint): Point[] {\n    return getRectPoints(pointInfo);\n  },\n});\n\n/** Inerval 默认 shape，填充的矩形 */\nregisterShape('interval', 'rect', {\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, false, true);\n    let group = container;\n\n    const backgroundCfg = cfg?.background;\n    if (backgroundCfg) {\n      group = container.addGroup({\n        name: 'interval-group',\n      });\n      const backgroundStyle = getBackgroundRectStyle(cfg);\n      const backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points) as Point[], this.coordinate);\n      group.addShape('path', {\n        attrs: {\n          ...backgroundStyle,\n          path: backgroundPath,\n        },\n        capture: false,\n        zIndex: -1,\n        name: BACKGROUND_SHAPE,\n      });\n    }\n\n    let path;\n    if (style.radius && this.coordinate.isRect) {\n      path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);\n    } else {\n      path = this.parsePath(getIntervalRectPath(cfg.points as Point[], style.lineCap, this.coordinate));\n    }\n\n    const shape = group.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n      name: 'interval',\n    });\n\n    return backgroundCfg ? group : shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color, isInPolar } = markerCfg;\n    if (isInPolar) {\n      return {\n        symbol: 'circle',\n        style: {\n          r: 4.5,\n          fill: color,\n        },\n      };\n    }\n\n    return {\n      symbol: 'square',\n      style: {\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n\nexport default IntervalShapeFactory;\n","import { isArray } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\nimport { getRectPath } from './util';\nimport { omit } from '../../../util/helper';\n\n// 根据数据点生成 Line 的两个关键点\nfunction getLinePoints(pointInfo: ShapePoint): Point[] {\n  const { x, y, y0 } = pointInfo;\n\n  if (isArray(y)) {\n    return y.map((yItem, idx) => {\n      return {\n        x: isArray(x) ? x[idx] : x,\n        y: yItem,\n      };\n    });\n  }\n\n  // 起始点从 y0 开始\n  return [\n    { x: x as number, y: y0 },\n    { x: x as number, y },\n  ];\n}\n\nregisterShape('interval', 'line', {\n  getPoints(shapePoint: ShapePoint) {\n    return getLinePoints(shapePoint);\n  },\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false, 'lineWidth');\n    const newStyle = omit({ ...style }, ['fill']);\n    const path = this.parsePath(getRectPath(cfg.points as Point[], false));\n    const shape = container.addShape('path', {\n      attrs: {\n        ...newStyle,\n        path,\n      },\n      name: 'interval',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: (x: number, y: number, r: number) => {\n        return [\n          ['M', x, y - r],\n          ['L', x, y + r],\n        ];\n      },\n      style: {\n        r: 5,\n        stroke: color,\n      },\n    };\n  },\n});\n","import { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\nimport { getFunnelPath, getRectPoints } from './util';\n\n/** 金字塔图，尖底漏斗图 */\nregisterShape('interval', 'pyramid', {\n  getPoints(shapePoint: ShapePoint) {\n    shapePoint.size = shapePoint.size * 2; // 漏斗图的 size 是柱状图的两倍\n    return getRectPoints(shapePoint);\n  },\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, false, true);\n    const path = this.parsePath(getFunnelPath(cfg.points as Point[], cfg.nextPoints as Point[], true));\n    const shape = container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n      name: 'interval',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: 'square',\n      style: {\n        r: 4,\n        fill: color,\n      },\n    };\n  },\n});\n","import { isArray } from '@antv/util';\nimport { IGroup } from '../../../dependents';\nimport { Point, ShapeInfo, ShapeMarkerCfg, ShapePoint } from '../../../interface';\n\nimport { registerShape } from '../base';\nimport { getStyle } from '../util/get-style';\n\n// 根据数据点生成 tick shape 的 6 个关键点\nfunction getTickPoints(pointInfo: ShapePoint): Point[] {\n  const { x, y, y0, size } = pointInfo;\n  let yMin;\n  let yMax;\n  if (isArray(y)) {\n    [yMin, yMax] = y;\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  const xMax = (x as number) + size / 2;\n  const xMin = (x as number) - size / 2;\n\n  // tick 关键点顺序\n  // 4 - 1 - 5\n  //     |\n  // 2 - 0 - 3\n  return [\n    { x: x as number, y: yMin },\n    { x: x as number, y: yMax },\n    { x: xMin, y: yMin },\n    { x: xMax, y: yMin },\n    { x: xMin, y: yMax },\n    { x: xMax, y: yMax },\n  ];\n}\n\n// 根据 tick 关键点绘制 path\nfunction getTickPath(points: Point[]) {\n  return [\n    ['M', points[0].x, points[0].y],\n    ['L', points[1].x, points[1].y],\n    ['M', points[2].x, points[2].y],\n    ['L', points[3].x, points[3].y],\n    ['M', points[4].x, points[4].y],\n    ['L', points[5].x, points[5].y],\n  ];\n}\n\n/** I 形状柱状图，常用于 error bar chart */\nregisterShape('interval', 'tick', {\n  getPoints(shapePoint: ShapePoint) {\n    return getTickPoints(shapePoint);\n  },\n  draw(cfg: ShapeInfo, container: IGroup) {\n    const style = getStyle(cfg, true, false);\n    const path = this.parsePath(getTickPath(cfg.points as Point[]));\n    const shape = container.addShape('path', {\n      attrs: {\n        ...style,\n        path,\n      },\n      name: 'interval',\n    });\n\n    return shape;\n  },\n  getMarker(markerCfg: ShapeMarkerCfg) {\n    const { color } = markerCfg;\n    return {\n      symbol: (x: number, y: number, r: number) => {\n        return [\n          ['M', x - r / 2, y - r],\n          ['L', x + r / 2, y - r],\n          ['M', x, y - r],\n          ['L', x, y + r],\n          ['M', x - r / 2, y + r],\n          ['L', x + r / 2, y + r],\n        ];\n      },\n      style: {\n        r: 5,\n        stroke: color,\n      },\n    };\n  },\n});\n","import { Coordinate } from '@antv/coord';\nimport { isArray, isNil, get } from '@antv/util';\nimport { getAngle, getSectorPath } from '../../../util/graphics';\nimport { PathCommand } from '../../../dependents';\nimport { Point, ShapeInfo, ShapePoint } from '../../../interface';\n\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @param [isPyramid] 是否为尖底漏斗图\n * @returns rect points 返回矩形四个顶点信息\n */\nexport function getRectPoints(pointInfo: ShapePoint): Point[] {\n  const { x, y, y0, size } = pointInfo;\n  // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n  let yMin;\n  let yMax;\n  if (isArray(y)) {\n    [yMin, yMax] = y;\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  let xMin;\n  let xMax;\n  if (isArray(x)) {\n    [xMin, xMax] = x;\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  const points = [\n    { x: xMin, y: yMin },\n    { x: xMin, y: yMax },\n  ];\n\n  // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n  points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });\n\n  return points;\n}\n\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\nexport function getRectPath(points: Point[], isClosed: boolean = true): PathCommand[] {\n  const path = [];\n  const firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n  for (let i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  }\n  // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n    path.push(['z']);\n  }\n  return path;\n}\n\n/**\n * 处理 rect path 的 radius\n * @returns 返回矩形 path 的四个角的 arc 半径\n */\nexport function parseRadius(radius: number | number[], minLength: number): number[] {\n  let r1 = 0;\n  let r2 = 0;\n  let r3 = 0;\n  let r4 = 0;\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  }\n\n  // 处理 边界值\n  if (r1 + r2 > minLength) {\n    r1 = r1 ? minLength / (1 + r2 / r1) : 0;\n    r2 = minLength - r1;\n  }\n\n  if (r3 + r4 > minLength) {\n    r3 = r3 ? minLength / (1 + r4 / r3) : 0;\n    r4 = minLength - r3;\n  }\n\n  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];\n}\n\n/**\n * 获取 interval 矩形背景的 path\n * @param cfg 关键点的信息\n * @param points 已转化为画布坐标的 4 个关键点\n * @param coordinate 坐标系\n * @returns 返回矩形背景的 path\n */\nexport function getBackgroundRectPath(cfg: ShapeInfo, points: Point[], coordinate: Coordinate): PathCommand[] {\n  let path = [];\n  if (coordinate.isRect) {\n    const p0 = coordinate.isTransposed\n      ? { x: coordinate.start.x, y: points[0].y }\n      : { x: points[0].x, y: coordinate.start.y };\n    const p1 = coordinate.isTransposed\n      ? { x: coordinate.end.x, y: points[2].y }\n      : { x: points[3].x, y: coordinate.end.y };\n\n    // corner radius of background shape works only in 笛卡尔坐标系\n    const radius = get(cfg, ['background', 'style', 'radius']);\n    if (radius) {\n      const width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;\n      const height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();\n      const [r1, r2, r3, r4] = parseRadius(radius, Math.min(width, height));\n\n      // 同时存在 坐标系是否发生转置 和 y 镜像的时候\n      const isReflectYTransposed = (coordinate.isTransposed && coordinate.isReflect('y'));\n      const bump = isReflectYTransposed ? 0 : 1;\n      const opposite = (r: number) => isReflectYTransposed ? -r : r;\n\n      path.push(['M', p0.x, p1.y + opposite(r1)]);\n      r1 !== 0 && path.push(['A', r1, r1, 0, 0, bump, p0.x + r1, p1.y]);\n      path.push(['L', p1.x - r2, p1.y]);\n      r2 !== 0 && path.push(['A', r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);\n      path.push(['L', p1.x, p0.y - opposite(r3)]);\n      r3 !== 0 && path.push(['A', r3, r3, 0, 0, bump, p1.x - r3, p0.y]);\n      path.push(['L', p0.x + r4, p0.y]);\n      r4 !== 0 && path.push(['A', r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);\n    } else {\n      path.push(['M', p0.x, p0.y]);\n      path.push(['L', p1.x, p0.y]);\n      path.push(['L', p1.x, p1.y]);\n      path.push(['L', p0.x, p1.y]);\n      path.push(['L', p0.x, p0.y]);\n    }\n\n    path.push(['z']);\n  }\n\n  if (coordinate.isPolar) {\n    const center = coordinate.getCenter();\n    const { startAngle, endAngle } = getAngle(cfg, coordinate);\n    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {\n      // 获取扇形 path\n      path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);\n    } else {\n      const pow = (v) => Math.pow(v, 2);\n      const r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));\n      const r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));\n      // 获取扇形 path（其实是一个圆环，从 coordinate 的起始角度到结束角度）\n      path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);\n    }\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param lineCap 'round'圆角样式\n * @param coor 坐标\n * @returns 返回矩形的 path\n */\nexport function getIntervalRectPath(points: Point[], lineCap: CanvasLineCap, coor: Coordinate): PathCommand[] {\n  const width = coor.getWidth();\n  const height = coor.getHeight();\n  const isRect = coor.type === 'rect';\n  let path = [];\n  const r = (points[2].x - points[1].x) / 2;\n  const ry = coor.isTransposed ? (r * height) / width : (r * width) / height;\n  if (lineCap === 'round') {\n    if (isRect) {\n      path.push(['M', points[0].x, points[0].y + ry]);\n      path.push(['L', points[1].x, points[1].y - ry]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);\n      path.push(['L', points[3].x, points[3].y + ry]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);\n    } else {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['L', points[1].x, points[1].y]);\n      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);\n      path.push(['L', points[3].x, points[3].y]);\n      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);\n    }\n    path.push(['z']);\n  } else {\n    path = getRectPath(points);\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 根据 funnel 关键点绘制漏斗图的 path\n * @param points 图形关键点信息\n * @param nextPoints 下一个数据的图形关键点信息\n * @param isPyramid 是否为尖底漏斗图\n * @returns 返回漏斗图的图形 path\n */\nexport function getFunnelPath(points: Point[], nextPoints: Point[], isPyramid: boolean) {\n  const path = [];\n  if (!isNil(nextPoints)) {\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', nextPoints[1].x, nextPoints[1].y],\n      ['L', nextPoints[0].x, nextPoints[0].y],\n      ['Z']\n    );\n  } else if (isPyramid) {\n    // 金字塔最底部\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2],\n      ['Z']\n    );\n  } else {\n    // 漏斗图最底部\n    path.push(\n      ['M', points[0].x, points[0].y],\n      ['L', points[1].x, points[1].y],\n      ['L', points[2].x, points[2].y],\n      ['L', points[3].x, points[3].y],\n      ['Z']\n    );\n  }\n\n  return path;\n}\n\n/**\n * 交换两个对象\n */\nfunction swap<T>(p0: T, p1: T) {\n  return [p1, p0];\n}\n\n/**\n * 获取 倒角 矩形\n * - 目前只适用于笛卡尔坐标系下\n */\nexport function getRectWithCornerRadius(points: Point[], coordinate: Coordinate, radius?: number | number[]) {\n  // 获取 四个关键点\n  let [p0, p1, p2, p3] = [...points];\n  let [r1, r2, r3, r4] = typeof radius === 'number' ? Array(4).fill(radius) : radius;\n\n  if (coordinate.isTransposed) {\n    [p1, p3] = swap(p1, p3);\n  }\n\n  /**\n   * 存在镜像\n   */\n  if (coordinate.isReflect('y')) {\n    [p0, p1] = swap(p0, p1);\n    [p2, p3] = swap(p2, p3);\n  }\n  if (coordinate.isReflect('x')) {\n    [p0, p3] = swap(p0, p3);\n    [p1, p2] = swap(p1, p2);\n  }\n\n  const path = [];\n\n\n  /**\n   *  p1 → p2\n   *  ↑    ↓\n   *  p0 ← p3\n   *\n   *  负数的情况，关键点会变成下面的形式\n   *\n   *  p0 ← p3               p2 ← p1\n   *  ↓    ↑                ↓     ↑\n   *  p1 → p2  --> (转置下)  p3 → p0\n   */\n  const abs = v => Math.abs(v);\n  [r1, r2, r3, r4] = parseRadius([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(d => abs(d));\n\n  if (coordinate.isTransposed) {\n    [r1, r2, r3, r4] = [r4, r1, r2, r3]\n  }\n\n  if (p0.y < p1.y /** 负数情况 */) {\n    path.push(['M', p3.x, p3.y + r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x - r3, p3.y]);\n    path.push(['L', p0.x + r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y + r4]);\n    path.push(['L', p1.x, p1.y - r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0/** 逆时针 */, p1.x + r1, p1.y]);\n    path.push(['L', p2.x - r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y - r2]);\n    path.push(['L', p3.x, p3.y + r3]);\n    path.push(['z']);\n  } else if (p3.x < p0.x) {\n    path.push(['M', p2.x + r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 0, p2.x, p2.y + r2]);\n    path.push(['L', p3.x, p3.y - r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 0, p3.x + r3, p3.y]);\n    path.push(['L', p0.x - r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 0, p0.x, p0.y - r4]);\n    path.push(['L', p1.x, p1.y + r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 0, p1.x - r1, p1.y]);\n    path.push(['L', p2.x + r2, p2.y]);\n    path.push(['z']);\n  } else {\n    path.push(['M', p1.x, p1.y + r1]);\n    r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);\n    path.push(['L', p2.x - r2, p2.y]);\n    r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);\n    path.push(['L', p3.x, p3.y - r3]);\n    r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);\n    path.push(['L', p0.x + r4, p0.y]);\n    r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);\n    path.push(['L', p1.x, p1.y + r1]);\n    path.push(['z']);\n  }\n\n  return path;\n}\n","import { each, isArray } from '@antv/util';\nimport { IGroup, ShapeAttrs } from '../../../dependents';\nimport { Point, Position, RangePoint, ShapeInfo, ShapeMarkerCfg } from '../../../interface';\n\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\n\nfunction getShapeAttrs(cfg: ShapeInfo, smooth?: boolean, constraint?: Position[]) {\n  const { isStack, connectNulls, isInCircle, showSinglePoint } = cfg;\n  const shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n\n  const points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n  let path = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const eachLinePoints = points[i];\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n  }\n  shapeAttrs.path = path;\n\n  return shapeAttrs;\n}\n\n// 单条 path\nfunction getSinglePath(\n  points: Point[],\n  isInCircle: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  if (points.length === 1) {\n    // 只有一个点时\n    return [\n      ['M', points[0].x, points[0].y - style.lineWidth / 2],\n      ['L', points[0].x, points[0].y],\n      ['L', points[0].x, points[0].y + style.lineWidth / 2],\n    ];\n  }\n\n  let path;\n  if (!smooth) {\n    path = getLinePath(points, false);\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({ x: points[0].x, y: points[0].y });\n    }\n    path = getSplinePath(points, false, constraint);\n  }\n\n  return path;\n}\n\nfunction getRangePath(\n  points: RangePoint[],\n  isInCircle: boolean,\n  isStack?: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  const topPoints = [];\n  const bottomPoints = [];\n  each(points, (point: RangePoint) => {\n    const result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n    bottomPoints.push(result[0]); // 底边\n  });\n\n  const topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n  const bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n  if (isStack) {\n    return topPath;\n  }\n  return topPath.concat(bottomPath);\n}\n\n/**\n * 获取折线图 path\n */\nexport function getPath(\n  points: Point[] | RangePoint[],\n  isInCircle: boolean,\n  isStack?: boolean,\n  smooth?: boolean,\n  constraint?: Position[],\n  style?: ShapeAttrs\n) {\n  if (points.length) {\n    const first = points[0];\n\n    return isArray(first.y)\n      ? getRangePath(points as RangePoint[], isInCircle, isStack, smooth, constraint, style)\n      : getSinglePath(points as Point[], isInCircle, smooth, constraint, style);\n  }\n  return [];\n}\n\nconst LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line',\n});\n\n// 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\neach(['line', 'dot', 'dash', 'smooth'], (shapeType) => {\n  registerShape('line', shapeType, {\n    draw(cfg: ShapeInfo, container: IGroup) {\n      const smooth = shapeType === 'smooth';\n      let constraint;\n      if (smooth) {\n        const { start, end } = this.coordinate;\n        constraint = [\n          [start.x, end.y],\n          [end.x, start.y],\n        ];\n      }\n\n      const attrs = getShapeAttrs(cfg, smooth, constraint);\n      const shape = container.addShape({\n        type: 'path',\n        attrs,\n        name: 'line',\n        capture: !smooth,\n      });\n\n      return shape;\n    },\n    getMarker(markerCfg: ShapeMarkerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    },\n  });\n});\n\nexport default LineShapeFactory;\n"],"names":["_this","__extends","Point","mappingDatum","shapeCfg","_super","getDrawCfg","call","isStack","this","getAdjust","Geometry","Polygon","obj","temp","cfg","createShapePointsCfg","x","y","isArray","xScale","getXScale","yScale","getYScale","xOffset","values","length","yOffset","isCategory","Schema","record","size","sizeAttr","getAttribute","getAttributeValues","coordinate","getXDimensionLength","defaultSize","getDefaultSize","registerShapeFactory","defaultShapeType","getDefaultPoints","pointInfo","y0","map","yItem","registerShape","draw","container","attrs","getShapeAttrs","addShape","type","name","getMarker","markerCfg","symbol","r","style","fill","fillOpacity","stroke","getConstraint","getPath","points","isInCircle","smooth","registeredShape","constraint","path","topLinePoints_1","bottomLinePoints_1","i","len","point","push","reverse","each","pointsData","index","subPath","parsedPoints","parsePoints","p1","getSplinePath","getLinePath","concat","isStroke","getStyle","connectNulls","showSinglePoint","pathPoints","getPathPoints","eachPoints","start","end","ShapeFactoryBase","theme","getShapePoints","shapeType","shapePoint","shape","getShape","getPoints","getDefaultStyle","geometryTheme","get","shapeStyle","markerStyle","deepMix","drawShape","ShapeBase","parsePath","parsedPath","parsePathString","isPolar","convertPolarPath","convertNormalPath","parsePoint","convert","ShapeFactoryMap","factoryName","className","upperFirst","geomObj","geometryType","factory","shapeObj","getShapeFactory","BACKGROUND_SHAPE","center","from","to","sub","getQPath","getArcShapePath","arc1","arc2","getArcShapeWeightPath","getArcPath","Math","abs","PI","c1","getCPath","c2","color","splitPoints","getSmoothPath","CORNER_PERCENT","getVHVPath","getRectPoints","getFunnelPath","nextPoints","group","backgroundCfg","background","addGroup","backgroundStyle","getBackgroundRectStyle","backgroundPath","getBackgroundRectPath","capture","zIndex","getRectPath","radius","isRect","getRectWithCornerRadius","getIntervalRectPath","lineCap","idx","getLinePoints","newStyle","omit","yMin","yMax","_a","xMax","xMin","getTickPoints","_b","isClosed","firstPoint","parseRadius","minLength","r1","r2","r3","r4","p0","isTransposed","width","height","getWidth","getHeight","min","isReflectYTransposed_1","isReflect","bump","opposite","getCenter","getAngle","startAngle","endAngle","pow","v","sqrt","getSectorPath","getRadius","coor","ry","isPyramid","isNil","swap","p2","p3","Array","_c","_d","_e","_f","d","_g","getSinglePath","lineWidth","first","topPoints","bottomPoints","result","topPath","bottomPath","getRangePath","shapeAttrs","eachLinePoints","getLineMarker"],"sourceRoot":""}