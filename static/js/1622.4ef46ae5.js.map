{"version":3,"file":"static/js/1622.4ef46ae5.js","mappings":"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","sources":["../node_modules/@antv/g-math/src/util.ts","../node_modules/@antv/g-math/src/line.ts","../node_modules/@antv/g-math/src/bezier.ts","../node_modules/@antv/g-math/src/quadratic.ts","../node_modules/@antv/g-math/src/cubic.ts","../node_modules/@antv/g-math/src/ellipse.ts","../node_modules/@antv/g-math/src/arc.ts","../node_modules/@antv/g-math/src/segments.ts","../node_modules/@antv/g-math/src/polyline.ts"],"sourcesContent":["import { max, min } from '@antv/util';\nimport { BBox } from './types';\n\n/**\n * 两点之间的距离\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 结束点 x\n * @param {number} y2 结束点 y\n * @return {number} 距离\n */\nexport function distance(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function isNumberEqual(v1: number, v2: number) {\n  return Math.abs(v1 - v2) < 0.001;\n}\n\nexport function getBBoxByArray(xArr: number[], yArr: number[]): BBox {\n  const minX = min(xArr);\n  const minY = min(yArr);\n  const maxX = max(xArr);\n  const maxY = max(yArr);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function getBBoxRange(x1: number, y1: number, x2: number, y2: number) {\n  return {\n    minX: min([x1, x2]),\n    maxX: max([x1, x2]),\n    minY: min([y1, y2]),\n    maxY: max([y1, y2]),\n  };\n}\n\nexport function piMod(angle: number) {\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n","import { distance, getBBoxByArray } from './util';\nimport * as vec2 from 'gl-matrix/vec2';\nimport { BBox, Point } from './types';\n\nexport default {\n  /**\n   * 计算线段的包围盒\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {object} 包围盒对象\n   */\n  box(x1: number, y1: number, x2: number, y2: number): BBox {\n    return getBBoxByArray([x1, x2], [y1, y2]);\n  },\n  /**\n   * 线段的长度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 距离\n   */\n  length(x1: number, y1: number, x2: number, y2: number) {\n    return distance(x1, y1, x2, y2);\n  },\n  /**\n   * 根据比例获取点\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} t 指定比例\n   * @return {object} 包含 x, y 的点\n   */\n  pointAt(x1: number, y1: number, x2: number, y2: number, t: number): Point {\n    return {\n      x: (1 - t) * x1 + t * x2,\n      y: (1 - t) * y1 + t * y2,\n    };\n  },\n  /**\n   * 点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointDistance(x1: number, y1: number, x2: number, y2: number, x: number, y: number): number {\n    // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n    // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n    const cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n    if (cross < 0) {\n      return distance(x1, y1, x, y);\n    }\n    const lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    if (cross > lengthSquare) {\n      return distance(x2, y2, x, y);\n    }\n    return this.pointToLine(x1, y1, x2, y2, x, y);\n  },\n  /**\n   * 点到直线的距离，而不是点到线段的距离\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @param {number} x  测试点 x\n   * @param {number} y  测试点 y\n   * @return {number} 距离\n   */\n  pointToLine(x1: number, y1: number, x2: number, y2: number, x: number, y: number) {\n    const d = [x2 - x1, y2 - y1];\n    // 如果端点相等，则判定点到点的距离\n    if (vec2.exactEquals(d, [0, 0])) {\n      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n    }\n    const u = [-d[1], d[0]];\n    vec2.normalize(u, u);\n    const a = [x - x1, y - y1];\n    return Math.abs(vec2.dot(a, u));\n  },\n  /**\n   * 线段的角度\n   * @param {number} x1 起始点 x\n   * @param {number} y1 起始点 y\n   * @param {number} x2 结束点 x\n   * @param {number} y2 结束点 y\n   * @return {number} 导数\n   */\n  tangentAngle(x1: number, y1: number, x2: number, y2: number) {\n    return Math.atan2(y2 - y1, x2 - x1);\n  },\n};\n","import { distance } from './util';\nimport { Point, PointTuple } from './types';\n\nconst EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(\n  xArr: number[],\n  yArr: number[],\n  x: number,\n  y: number,\n  tCallback: (...arr: number[]) => number,\n  length?: number\n): Point {\n  let t: number;\n  let d = Infinity;\n  const v0: PointTuple = [x, y];\n\n  let segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  const increaseRate = 1 / segNum;\n\n  let interval = increaseRate / 10;\n\n  for (let i = 0; i <= segNum; i++) {\n    const _t = i * increaseRate;\n    const v1: PointTuple = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0],\n    };\n  }\n  if (t === 1) {\n    const count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1],\n    };\n  }\n  d = Infinity;\n\n  for (let i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    const prev = t - interval;\n    const next = t + interval;\n\n    const v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      const v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\n      const d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback.apply(null, xArr.concat([t])),\n    y: tCallback.apply(null, yArr.concat([t])),\n  };\n}\n\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr: number[], yArr: number[]) {\n  let totalLength = 0;\n  const count = xArr.length;\n  for (let i = 0; i < count; i++) {\n    const x = xArr[i];\n    const y = yArr[i];\n    const nextX = xArr[(i + 1) % count];\n    const nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}\n","import line from './line';\nimport { distance, isNumberEqual, getBBoxByArray, piMod } from './util';\nimport { nearestPoint } from './bezier';\nimport { Point } from './types';\n\n// 差值公式\nfunction quadraticAt(p0: number, p1: number, p2: number, t: number) {\n  const onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n\n// 求极值\nfunction extrema(p0: number, p1: number, p2: number) {\n  const a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  const rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\n\nfunction derivativeAt(p0: number, p1: number, p2: number, t: number) {\n  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\n// 分割贝塞尔曲线\nfunction divideQuadratic(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, t: number) {\n  // 划分点\n  const xt = quadraticAt(x1, x2, x3, t);\n  const yt = quadraticAt(y1, y2, y3, t);\n\n  // 分割的第一条曲线的控制点\n  const controlPoint1 = line.pointAt(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  const controlPoint2 = line.pointAt(x2, y2, x3, y3, t);\n  return [\n    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\n    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  iterationCount: number\n) {\n  if (iterationCount === 0) {\n    return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;\n  }\n  const quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  const left = quadratics[0];\n  const right = quadratics[1];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);\n}\n\nexport default {\n  box(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number) {\n    const xExtrema = extrema(x1, x2, x3)[0];\n    const yExtrema = extrema(y1, y2, y3)[0];\n    // 控制点不加入 box 的计算\n    const xArr = [x1, x3];\n    const yArr = [y1, y3];\n    if (xExtrema !== undefined) {\n      xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n    }\n    if (yExtrema !== undefined) {\n      yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n    }\n    return getBBoxByArray(xArr, yArr);\n  },\n  length(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number) {\n    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n  },\n  nearestPoint(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x0: number, y0: number) {\n    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n  },\n  pointDistance(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x0: number, y0: number) {\n    const point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n    return distance(point.x, point.y, x0, y0);\n  },\n  interpolationAt: quadraticAt,\n  pointAt(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, t: number): Point {\n    return {\n      x: quadraticAt(x1, x2, x3, t),\n      y: quadraticAt(y1, y2, y3, t),\n    };\n  },\n  divide(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, t: number) {\n    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n  },\n  tangentAngle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, t: number) {\n    const dx = derivativeAt(x1, x2, x3, t);\n    const dy = derivativeAt(y1, y2, y3, t);\n    const angle = Math.atan2(dy, dx);\n    return piMod(angle);\n  },\n};\n","import { distance, isNumberEqual, getBBoxByArray, piMod } from './util';\nimport line from './line';\nimport { snapLength, nearestPoint } from './bezier';\nimport { Point } from './types';\n\nfunction cubicAt(p0: number, p1: number, p2: number, p3: number, t: number) {\n  const onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;\n}\n\nfunction derivativeAt(p0: number, p1: number, p2: number, p3: number, t: number) {\n  const onet = 1 - t;\n  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));\n}\n\nfunction extrema(p0: number, p1: number, p2: number, p3: number) {\n  const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n  const b = 6 * p0 - 12 * p1 + 6 * p2;\n  const c = 3 * p1 - 3 * p0;\n  const extremas = [];\n  let t1: number;\n  let t2: number;\n  let discSqrt: number;\n\n  if (isNumberEqual(a, 0)) {\n    if (!isNumberEqual(b, 0)) {\n      t1 = -c / b;\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n    }\n  } else {\n    const disc = b * b - 4 * a * c;\n    if (isNumberEqual(disc, 0)) {\n      extremas.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n      if (t2 >= 0 && t2 <= 1) {\n        extremas.push(t2);\n      }\n    }\n  }\n  return extremas;\n}\n\n// 分割贝塞尔曲线\nfunction divideCubic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number\n) {\n  // 划分点\n  const xt = cubicAt(x1, x2, x3, x4, t);\n  const yt = cubicAt(y1, y2, y3, y4, t);\n  // 计算两点之间的差值点\n  const c1 = line.pointAt(x1, y1, x2, y2, t);\n  const c2 = line.pointAt(x2, y2, x3, y3, t);\n  const c3 = line.pointAt(x3, y3, x4, y4, t);\n  const c12 = line.pointAt(c1.x, c1.y, c2.x, c2.y, t);\n  const c23 = line.pointAt(c2.x, c2.y, c3.x, c3.y, t);\n  return [\n    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],\n    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  iterationCount: number\n) {\n  if (iterationCount === 0) {\n    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n  }\n  const cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n  const left = cubics[0];\n  const right = cubics[1];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return cubicLength.apply(null, left) + cubicLength.apply(null, right);\n}\n\nexport default {\n  extrema,\n  box(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number) {\n    const xArr = [x1, x4];\n    const yArr = [y1, y4];\n    const xExtrema = extrema(x1, x2, x3, x4);\n    const yExtrema = extrema(y1, y2, y3, y4);\n    for (let i = 0; i < xExtrema.length; i++) {\n      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n    }\n    for (let i = 0; i < yExtrema.length; i++) {\n      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));\n    }\n    return getBBoxByArray(xArr, yArr);\n  },\n  length(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number) {\n    // 迭代三次，划分成 8 段求长度\n    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n  },\n  nearestPoint(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x3: number,\n    y3: number,\n    x4: number,\n    y4: number,\n    x0: number,\n    y0: number,\n    length?: number\n  ) {\n    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);\n  },\n  pointDistance(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x3: number,\n    y3: number,\n    x4: number,\n    y4: number,\n    x0: number,\n    y0: number,\n    length?: number\n  ) {\n    const point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n    return distance(point.x, point.y, x0, y0);\n  },\n  interpolationAt: cubicAt,\n  pointAt(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x3: number,\n    y3: number,\n    x4: number,\n    y4: number,\n    t: number\n  ): Point {\n    return {\n      x: cubicAt(x1, x2, x3, x4, t),\n      y: cubicAt(y1, y2, y3, y4, t),\n    };\n  },\n  divide(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number, t: number) {\n    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);\n  },\n  tangentAngle(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x3: number,\n    y3: number,\n    x4: number,\n    y4: number,\n    t: number\n  ) {\n    const dx = derivativeAt(x1, x2, x3, x4, t);\n    const dy = derivativeAt(y1, y2, y3, y4, t);\n    return piMod(Math.atan2(dy, dx));\n  },\n};\n","/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\n\nimport { distance, piMod } from './util';\nimport { Point, BBox } from './types';\n\nfunction copysign(v1: number, v2: number) {\n  const absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport default {\n  /**\n   * 包围盒计算\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {object} 包围盒\n   */\n  box(x: number, y: number, rx: number, ry: number): BBox {\n    return {\n      x: x - rx,\n      y: y - ry,\n      width: rx * 2,\n      height: ry * 2,\n    };\n  },\n  /**\n   * 计算周长，使用近似法\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {number} 椭圆周长\n   */\n  length(x: number, y: number, rx: number, ry: number) {\n    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  },\n  /**\n   * 距离椭圆最近的点\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {object} 椭圆上距离指定点最近的点\n   */\n  nearestPoint(x: number, y: number, rx: number, ry: number, x0: number, y0: number) {\n    const a = rx;\n    const b = ry;\n    // 假如椭圆半径为0则返回圆心\n    if (a === 0 || b === 0) {\n      return {\n        x,\n        y,\n      };\n    }\n    // 转换成 0， 0 为中心的椭圆计算\n    const relativeX = x0 - x;\n    const relativeY = y0 - y;\n    const px = Math.abs(relativeX);\n    const py = Math.abs(relativeY);\n    const squareA = a * a;\n    const squareB = b * b;\n    // const angle0 = Math.atan2(relativeY, relativeX);\n    let t = Math.PI / 4;\n    let nearestX: number; // 椭圆上的任一点\n    let nearestY: number;\n    // 迭代 4 次\n    for (let i = 0; i < 4; i++) {\n      nearestX = a * Math.cos(t);\n      nearestY = b * Math.sin(t);\n\n      const ex = ((squareA - squareB) * Math.cos(t) ** 3) / a;\n      const ey = ((squareB - squareA) * Math.sin(t) ** 3) / b;\n      const rx1 = nearestX - ex;\n      const ry1 = nearestY - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n      const r = Math.hypot(ry1, rx1);\n      const q = Math.hypot(qy, qx);\n\n      const delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n      const delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n\n      t += delta_t;\n      t = Math.min(Math.PI / 2, Math.max(0, t));\n    }\n\n    return {\n      x: x + copysign(nearestX, relativeX),\n      y: y + copysign(nearestY, relativeY),\n    };\n  },\n  /**\n   * 点到椭圆最近的距离\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {number} 点到椭圆的距离\n   */\n  pointDistance(x: number, y: number, rx: number, ry: number, x0: number, y0: number) {\n    const nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n  /**\n   * 根据比例获取点\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例，x轴方向为 0\n   * @return {object} 点\n   */\n  pointAt(x: number, y: number, rx: number, ry: number, t: number): Point {\n    const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    return {\n      x: x + rx * Math.cos(angle),\n      y: y + ry * Math.sin(angle),\n    };\n  },\n  /**\n   * 根据比例计算切线角度\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n   * @return {number} 角度，在 0 - 2PI 之间\n   */\n  tangentAngle(x: number, y: number, rx: number, ry: number, t: number) {\n    const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n    const tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n    // 也可以使用指定点的切线方程计算，成本有些高\n    // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n    // if (angle >= 0 && angle <= Math.PI) {\n    //   tangentAngle += Math.PI;\n    // }\n\n    return piMod(tangentAngle);\n  },\n};\n","import { distance, piMod } from './util';\nimport ellipse from './ellipse';\nimport { Point, BBox } from './types';\n\n// 偏导数 x\nfunction derivativeXAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number\n) {\n  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n\n// 偏导数 y\nfunction derivativeYAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number\n) {\n  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n\n// x 的极值\nfunction xExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n\n// y 的极值\nfunction yExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n\n// 根据角度求 x 坐标\nfunction xAt(cx: number, cy: number, rx: number, ry: number, xRotation: number, angle: number) {\n  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n\n// 根据角度求 y 坐标\nfunction yAt(cx: number, cy: number, rx: number, ry: number, xRotation: number, angle: number) {\n  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n\n// 获取点在椭圆上的角度\nfunction getAngle(rx: number, ry: number, x0: number, y0: number) {\n  const angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\n// 根据角度获取，x,y\nfunction getPoint(rx: number, ry: number, angle: number): Point {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle),\n  };\n}\n\n// 旋转\nfunction rotate(x: number, y: number, angle: number) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\n\nexport default {\n  /**\n   * 计算包围盒\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   * @return {object} 包围盒对象\n   */\n  box(cx: number, cy: number, rx: number, ry: number, xRotation: number, startAngle: number, endAngle: number): BBox {\n    const xDim = xExtrema(rx, ry, xRotation);\n    let minX = Infinity;\n    let maxX = -Infinity;\n    const xs = [startAngle, endAngle];\n    for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n      const xAngle = xDim + i;\n      if (startAngle < endAngle) {\n        if (startAngle < xAngle && xAngle < endAngle) {\n          xs.push(xAngle);\n        }\n      } else {\n        if (endAngle < xAngle && xAngle < startAngle) {\n          xs.push(xAngle);\n        }\n      }\n    }\n\n    for (let i = 0; i < xs.length; i++) {\n      const x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n      if (x < minX) {\n        minX = x;\n      }\n      if (x > maxX) {\n        maxX = x;\n      }\n    }\n\n    const yDim = yExtrema(rx, ry, xRotation);\n    let minY = Infinity;\n    let maxY = -Infinity;\n    const ys = [startAngle, endAngle];\n    for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n      const yAngle = yDim + i;\n      if (startAngle < endAngle) {\n        if (startAngle < yAngle && yAngle < endAngle) {\n          ys.push(yAngle);\n        }\n      } else {\n        if (endAngle < yAngle && yAngle < startAngle) {\n          ys.push(yAngle);\n        }\n      }\n    }\n\n    for (let i = 0; i < ys.length; i++) {\n      const y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n      if (y < minY) {\n        minY = y;\n      }\n      if (y > maxY) {\n        maxY = y;\n      }\n    }\n\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  },\n  /**\n   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\n   * 仅跟 rx, ry, startAngle, endAngle 相关\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   */\n  length(cx: number, cy: number, rx: number, ry: number, xRotation: number, startAngle: number, endAngle: number) {},\n  /**\n   * 获取指定点到圆弧的最近距离的点\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   * @param {number} x0         指定点的 x\n   * @param {number} y0         指定点的 y\n   * @return {object} 到指定点最近距离的点\n   */\n  nearestPoint(\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xRotation: number,\n    startAngle: number,\n    endAngle: number,\n    x0: number,\n    y0: number\n  ) {\n    // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n    const relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n    const [x1, y1] = relativeVector;\n    // 计算点到椭圆的最近的点\n    let relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);\n    // 获取点在椭圆上的角度\n    const angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n    // 点没有在圆弧上\n    if (angle < startAngle) {\n      // 小于起始圆弧\n      relativePoint = getPoint(rx, ry, startAngle);\n    } else if (angle > endAngle) {\n      // 大于结束圆弧\n      relativePoint = getPoint(rx, ry, endAngle);\n    }\n    // 旋转到 xRotation 的角度\n    const vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n    return {\n      x: vector[0] + cx,\n      y: vector[1] + cy,\n    };\n  },\n  pointDistance(\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xRotation: number,\n    startAngle: number,\n    endAngle: number,\n    x0: number,\n    y0: number\n  ) {\n    const nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n  pointAt(\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xRotation: number,\n    startAngle: number,\n    endAngle: number,\n    t: number\n  ): Point {\n    const angle = (endAngle - startAngle) * t + startAngle;\n    return {\n      x: xAt(cx, cy, rx, ry, xRotation, angle),\n      y: yAt(cx, cy, rx, ry, xRotation, angle),\n    };\n  },\n  tangentAngle(\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xRotation: number,\n    startAngle: number,\n    endAngle: number,\n    t: number\n  ) {\n    const angle = (endAngle - startAngle) * t + startAngle;\n    const dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n    const dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n    return piMod(Math.atan2(dy, dx));\n  },\n};\n","import line from './line';\nimport { distance } from './util';\nimport { Point, PointTuple, Segment } from './types';\n\nfunction analyzePoints(points: PointTuple[]) {\n  // 计算每段的长度和总的长度\n  let totalLength = 0;\n  const segments: Segment[] = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    const length = distance(from[0], from[1], to[0], to[1]);\n    const seg = {\n      from,\n      to,\n      length,\n    };\n    segments.push(seg);\n    totalLength += length;\n  }\n  return { segments, totalLength };\n}\n\nexport function lengthOfSegment(points: PointTuple[]) {\n  if (points.length < 2) {\n    return 0;\n  }\n  let totalLength = 0;\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nexport function pointAtSegments(points: PointTuple[], t: number): Point {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1],\n    };\n  }\n  // 计算比例\n  let startRatio = 0;\n  let point = null;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      const localRatio = (t - startRatio) / currentRatio;\n      point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nexport function angleAtSegments(points: PointTuple[], t: number) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 计算比例\n  let startRatio = 0;\n  let angle = 0;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\n\nexport function distanceAtSegment(points: PointTuple[], x: number, y: number) {\n  let minDistance = Infinity;\n  for (let i = 0; i < points.length - 1; i++) {\n    const point = points[i];\n    const nextPoint = points[i + 1];\n    const distance = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  }\n  return minDistance;\n}\n","import { pointAtSegments, angleAtSegments, distanceAtSegment, lengthOfSegment } from './segments';\nimport { getBBoxByArray } from './util';\nimport { PointTuple, BBox } from './types';\n\nexport default {\n  /**\n   * 计算多折线的包围盒\n   * @param {array} points 点的集合 [x,y] 的形式\n   * @return {object} 包围盒\n   */\n  box(points: PointTuple[]): BBox {\n    const xArr = [];\n    const yArr = [];\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      xArr.push(point[0]);\n      yArr.push(point[1]);\n    }\n    return getBBoxByArray(xArr, yArr);\n  },\n  /**\n   * 计算多折线的长度\n   * @param {array} points 点的集合 [x,y] 的形式\n   * @return {object} 多条边的长度\n   */\n  length(points: PointTuple[]) {\n    return lengthOfSegment(points);\n  },\n  /**\n   * 根据比例获取多折线的点\n   * @param {array} points 点的集合 [x,y] 的形式\n   * @param {number} t 在多折线的长度上的比例\n   * @return {object} 根据比例值计算出来的点\n   */\n  pointAt(points: PointTuple[], t: number) {\n    return pointAtSegments(points, t);\n  },\n  /**\n   * 指定点到多折线的距离\n   * @param {array} points 点的集合 [x,y] 的形式\n   * @param {number} x 指定点的 x\n   * @param {number} y 指定点的 y\n   * @return {number} 点到多折线的距离\n   */\n  pointDistance(points: PointTuple[], x: number, y: number) {\n    return distanceAtSegment(points, x, y);\n  },\n  /**\n   * 根据比例获取多折线的切线角度\n   * @param {array} points 点的集合 [x,y] 的形式\n   * @param {number} t 在多折线的长度上的比例\n   * @return {object} 根据比例值计算出来的角度\n   */\n  tangentAngle(points: PointTuple[], t: number) {\n    return angleAtSegments(points, t);\n  },\n};\n"],"names":["distance","x1","y1","x2","y2","dx","dy","Math","sqrt","isNumberEqual","v1","v2","abs","getBBoxByArray","xArr","yArr","minX","min","minY","x","y","width","max","height","getBBoxRange","maxX","maxY","piMod","angle","PI","box","length","pointAt","t","pointDistance","cross","this","pointToLine","d","vec2","u","a","tangentAngle","atan2","nearestPoint","tCallback","Infinity","v0","segNum","increaseRate","interval","i","_t","apply","concat","d1","count","prev","next","d2","quadraticAt","p0","p1","p2","onet","extrema","rst","derivativeAt","divideQuadratic","x3","y3","xt","yt","controlPoint1","line","controlPoint2","quadraticLength","iterationCount","quadratics","left","right","push","xExtrema","yExtrema","undefined","x0","y0","point","interpolationAt","divide","cubicAt","p3","t1","t2","discSqrt","b","c","extremas","disc","divideCubic","x4","y4","c1","c2","c3","c12","c23","cubicLength","totalLength","snapLength","cubics","copysign","absv","rx","ry","nearestX","nearestY","relativeX","relativeY","px","py","squareA","squareB","cos","sin","ex","ey","rx1","ry1","qx","qy","r","hypot","q","asin","xAt","cx","cy","xRotation","yAt","getPoint","rotate","startAngle","endAngle","xDim","atan","tan","xs","xAngle","yDim","ys","yAngle","relativeVector","relativePoint","ellipse","getAngle","vector","derivativeXAt","derivativeYAt","analyzePoints","points","segments","from","to","length_1","seg","lengthOfSegment","pointAtSegments","startRatio","currentRatio","localRatio","angleAtSegments","distanceAtSegment","minDistance","nextPoint","distance_1"],"sourceRoot":""}