{"version":3,"file":"static/js/5819.018e46e4.js","mappings":"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","sources":["../node_modules/@antv/g-canvas/src/util/arc-params.ts","../node_modules/@antv/g-canvas/src/util/arrow.ts","../node_modules/@antv/g-canvas/src/util/draw.ts","../node_modules/@antv/g-canvas/src/util/hit.ts","../node_modules/@antv/g-canvas/src/util/in-path/point-in-path.ts","../node_modules/@antv/g-canvas/src/util/in-path/polygon.ts","../node_modules/@antv/g-canvas/src/util/in-stroke/arc.ts","../node_modules/@antv/g-canvas/src/util/in-stroke/line.ts","../node_modules/@antv/g-canvas/src/util/in-stroke/polyline.ts","../node_modules/@antv/g-canvas/src/util/in-stroke/rect-radius.ts","../node_modules/@antv/g-canvas/src/util/in-stroke/rect.ts","../node_modules/@antv/g-canvas/src/util/parse.ts","../node_modules/@antv/g-canvas/src/util/path.ts","../node_modules/@antv/g-canvas/src/util/util.ts"],"sourcesContent":["import { mod, toRadian, isSamePoint } from './util';\n\n// 向量长度\nfunction vMag(v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n\n// u.v/|u||v|，计算夹角的余弦值\nfunction vRatio(u, v) {\n  // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\n  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\n}\n\n// 向量角度\nfunction vAngle(u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\n\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\nexport default function getArcParams(startPoint, params) {\n  let rx = params[1];\n  let ry = params[2];\n  const xRotation = mod(toRadian(params[3]), Math.PI * 2);\n  const arcFlag = params[4];\n  const sweepFlag = params[5];\n  // 弧形起点坐标\n  const x1 = startPoint[0];\n  const y1 = startPoint[1];\n  // 弧形终点坐标\n  const x2 = params[6];\n  const y2 = params[7];\n  const xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;\n  const yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;\n  const lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  const diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n\n  let f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\n\n  if (arcFlag === sweepFlag) {\n    f *= -1;\n  }\n  if (isNaN(f)) {\n    f = 0;\n  }\n\n  // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\n  const cxp = ry ? (f * rx * yp) / ry : 0;\n  const cyp = rx ? (f * -ry * xp) / rx : 0;\n\n  // 椭圆圆心坐标\n  const cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\n  const cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\n\n  // 起始点的单位向量\n  const u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  // 终止点的单位向量\n  const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  // 计算起始点和圆心的连线，与 x 轴正方向的夹角\n  const theta = vAngle([1, 0], u);\n\n  // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\n  let dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = Math.PI;\n  }\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n  if (sweepFlag === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * Math.PI;\n  }\n  if (sweepFlag === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * Math.PI;\n  }\n  return {\n    cx,\n    cy,\n    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\n    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,\n    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,\n    startAngle: theta,\n    endAngle: theta + dTheta,\n    xRotation,\n    arcFlag,\n    sweepFlag,\n  };\n}\n","import { Path } from '../shape';\n\nconst { sin, cos, atan2, PI } = Math;\n\nfunction _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {\n  const { stroke, lineWidth } = attrs;\n  const x = x1 - x2;\n  const y = y1 - y2;\n  const rad = atan2(y, x);\n  const arrowShape = new Path({\n    type: 'path',\n    canvas: shape.get('canvas'),\n    isArrowShape: true,\n    attrs: {\n      // 默认箭头的边长为 10，夹角为 60 度\n      path: `M${10 * cos(PI / 6)},${10 * sin(PI / 6)} L0,0 L${10 * cos(PI / 6)},-${10 * sin(PI / 6)}`,\n      // 使用 shape stroke 值\n      stroke,\n      lineWidth,\n    },\n  });\n  arrowShape.translate(x2, y2);\n  arrowShape.rotateAtPoint(x2, y2, rad);\n  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);\n}\n\n/**\n * 箭头 path 的设置要求\n * 1. 箭头顶点坐标需要为 (0, 0)\n * 2. 箭头夹角的中心分割线需要与 X 轴正方向对齐\n */\nfunction _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {\n  const { startArrow, endArrow, stroke, lineWidth } = attrs;\n  const arrowAttrs = isStart ? startArrow : endArrow;\n  const { d, fill: arrowFill, stroke: arrowStroke, lineWidth: arrowLineWidth, ...restAttrs } = arrowAttrs;\n  const x = x1 - x2;\n  const y = y1 - y2;\n  const rad = atan2(y, x);\n\n  if (d) {\n    x2 = x2 - cos(rad) * d;\n    y2 = y2 - sin(rad) * d;\n  }\n\n  const arrowShape = new Path({\n    type: 'path',\n    canvas: shape.get('canvas'),\n    isArrowShape: true,\n    attrs: {\n      ...restAttrs,\n      // 支持单独设置箭头的 stroke 和 lineWidth，若为空则使用 shape 的值\n      stroke: arrowStroke || stroke,\n      lineWidth: arrowLineWidth || lineWidth,\n      // 箭头是否填充需要手动设置，不会继承自 shape 的值\n      fill: arrowFill,\n    },\n  });\n\n  arrowShape.translate(x2, y2);\n  arrowShape.rotateAtPoint(x2, y2, rad);\n  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);\n}\n\n/**\n * 如果自定义箭头并且有 d 需要做偏移，如果直接画，线条会超出箭头尖端，因此需要根据箭头偏移 d, 返回线需要缩短的距离\n * |----------------\n * |<|--------------\n * |\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 箭头作用点 x\n * @param {number} y2 箭头作用点 y\n * @param {number} d  箭头沿线条方向的偏移距离\n * @return {{dx: number, dy: number}} 返回线条偏移距离\n */\nexport function getShortenOffset(x1, y1, x2, y2, d) {\n  const rad = atan2(y2 - y1, x2 - x1);\n  return {\n    dx: cos(rad) * d,\n    dy: sin(rad) * d,\n  };\n}\n\n/**\n * 绘制起始箭头\n * @param {IShape} shape 图形\n * @param {ShapeAttrs} attrs shape 的绘图属性\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 箭头作用点 x\n * @param {number} y2 箭头作用点 y\n */\nexport function addStartArrow(shape, attrs, x1, y1, x2, y2) {\n  if (typeof attrs.startArrow === 'object') {\n    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);\n  } else if (attrs.startArrow) {\n    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);\n  } else {\n    shape.set('startArrowShape', null);\n  }\n}\n\n/**\n * 绘制结束箭头\n * @param {IShape} shape 图形\n * @param {ShapeAttrs} attrs shape 的绘图属性\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 箭头作用点 x\n * @param {number} y2 箭头作用点 y\n */\nexport function addEndArrow(shape, attrs, x1, y1, x2, y2) {\n  if (typeof attrs.endArrow === 'object') {\n    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);\n  } else if (attrs.endArrow) {\n    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);\n  } else {\n    shape.set('startArrowShape', null);\n  }\n}\n","import { each, isArray, max, min } from '@antv/util';\nimport { IElement } from '../interfaces';\nimport { Region } from '../types';\nimport { parseStyle } from './parse';\nimport getArcParams from './arc-params';\nimport { mergeRegion, intersectRect } from './util';\nimport * as ArrowUtil from '../util/arrow';\n\nconst SHAPE_ATTRS_MAP = {\n  fill: 'fillStyle',\n  stroke: 'strokeStyle',\n  opacity: 'globalAlpha',\n};\n\nexport function applyAttrsToContext(context: CanvasRenderingContext2D, element: IElement) {\n  const attrs = element.attr();\n  for (const k in attrs) {\n    let v = attrs[k];\n    // 转换一下不与 canvas 兼容的属性名\n    const name = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\n    if (name === 'matrix' && v) {\n      // 设置矩阵\n      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\n    } else if (name === 'lineDash' && context.setLineDash) {\n      // 设置虚线，只支持数组形式，非数组形式不做任何操作\n      isArray(v) && context.setLineDash(v);\n    } else {\n      if (name === 'strokeStyle' || name === 'fillStyle') {\n        // 如果存在渐变、pattern 这个开销有些大\n        // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\n        v = parseStyle(context, element, v);\n      } else if (name === 'globalAlpha') {\n        // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\n        v = v * context.globalAlpha;\n      }\n      context[name] = v;\n    }\n  }\n}\n\nexport function drawChildren(context: CanvasRenderingContext2D, children: IElement[], region?: Region) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i] as IElement;\n    if (child.cfg.visible) {\n      child.draw(context, region);\n    } else {\n      child.skipDraw();\n    }\n  }\n}\n\n// 这个地方的逻辑比较复杂，简单画了一张图：https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE\nexport function checkRefresh(canvas, children: IElement[], region: Region) {\n  const refreshElements = canvas.get('refreshElements');\n  // 先遍历需要刷新的元素，将这些元素的父元素也设置 refresh\n  each(refreshElements, (el) => {\n    if (el !== canvas) {\n      let parent = el.cfg.parent;\n      while (parent && parent !== canvas && !parent.cfg.refresh) {\n        parent.cfg.refresh = true;\n        parent = parent.cfg.parent;\n      }\n    }\n  });\n  if (refreshElements[0] === canvas) {\n    setChildrenRefresh(children, region);\n  } else {\n    // 检查所有子元素是否可以刷新\n    checkChildrenRefresh(children, region);\n  }\n}\n// 检查所有的子元素是否应该更新\nexport function checkChildrenRefresh(children: IElement[], region: Region) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i] as IElement;\n    if (child.cfg.visible) {\n      // 先判断 hasChanged，因为它的优先级判断应该高于 refresh\n      if (child.cfg.hasChanged) {\n        // 如果节点发生了 change，则需要级联设置子元素的 refresh\n        child.cfg.refresh = true;\n        if (child.isGroup()) {\n          setChildrenRefresh(child.cfg.children, region);\n        }\n      } else if (child.cfg.refresh) {\n        // 如果当前图形/分组 refresh = true，说明其子节点存在 changed\n        if (child.isGroup()) {\n          checkChildrenRefresh(child.cfg.children, region);\n        }\n      } else {\n        // 这个分支说明此次局部刷新，所有的节点和父元素没有发生变化，仅需要检查包围盒（缓存）是否相交即可\n        const refresh = checkElementRefresh(child, region);\n        child.cfg.refresh = refresh;\n        if (refresh && child.isGroup()) {\n          // 如果需要刷新，说明子元素也需要刷新，继续进行判定\n          checkChildrenRefresh(child.cfg.children, region);\n        }\n      }\n    }\n  }\n}\n\n// 由于对改变的图形放入 refreshElements 时做了优化，判定父元素 changed 时不加入\n// 那么有可能会出现 elements 都为空，所以最终 group\nexport function clearChanged(elements: IElement[]) {\n  for (let i = 0; i < elements.length; i++) {\n    const el = elements[i];\n    el.cfg.hasChanged = false;\n    // 级联清理\n    if (el.isGroup() && !el.destroyed) {\n      clearChanged(el.cfg.children);\n    }\n  }\n}\n\n// 当某个父元素发生改变时，调用这个方法级联设置 refresh\nfunction setChildrenRefresh(children: IElement[], region: Region) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i] as IElement;\n    if (!child.cfg.visible) {\n      continue;\n    }\n    // let refresh = true;\n    // 获取缓存的 bbox，如果这个 bbox 还存在则说明父元素不是矩阵发生了改变\n    // const bbox = child.cfg.canvasBBox;\n    // if (bbox) {\n    //   // 如果这时候\n    //   refresh = intersectRect(bbox, region);\n    // }\n    child.cfg.refresh = true;\n    // 如果需要刷新当前节点，所有的子元素设置 refresh\n    if (child.isGroup()) {\n      setChildrenRefresh(child.get('children'), region);\n    }\n  }\n}\n\nfunction checkElementRefresh(shape: IElement, region: Region): boolean {\n  const bbox = shape.cfg.cacheCanvasBBox;\n  const isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);\n  return isAllow;\n}\n\n// 绘制 path\nexport function drawPath(shape, context, attrs, arcParamsCache) {\n  const { path, startArrow, endArrow } = attrs;\n  if (!path) {\n    return;\n  }\n  let currentPoint = [0, 0]; // 当前图形\n  let startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\n  let distance = {\n    dx: 0,\n    dy: 0,\n  };\n  context.beginPath();\n  for (let i = 0; i < path.length; i++) {\n    const params = path[i];\n    const command = params[0];\n    if (i === 0 && startArrow && startArrow.d) {\n      const tangent = shape.getStartTangent();\n      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\n    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\n      // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\n      const lastPath = path[i + 1];\n      if (lastPath[0] === 'Z') {\n        const tangent = shape.getEndTangent();\n        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n      }\n    } else if (i === path.length - 1 && endArrow && endArrow.d) {\n      if (path[0] !== 'Z') {\n        const tangent = shape.getEndTangent();\n        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n      }\n    }\n\n    const { dx, dy } = distance;\n    // V,H,S,T 都在前面被转换成标准形式\n    switch (command) {\n      case 'M':\n        context.moveTo(params[1] - dx, params[2] - dy);\n        startMovePoint = [params[1], params[2]];\n        break;\n      case 'L':\n        context.lineTo(params[1] - dx, params[2] - dy);\n        break;\n      case 'Q':\n        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\n        break;\n      case 'C':\n        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\n        break;\n      case 'A': {\n        let arcParams;\n        // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\n        if (arcParamsCache) {\n          arcParams = arcParamsCache[i];\n          if (!arcParams) {\n            arcParams = getArcParams(currentPoint, params);\n            arcParamsCache[i] = arcParams;\n          }\n        } else {\n          arcParams = getArcParams(currentPoint, params);\n        }\n        const { cx, cy, rx, ry, startAngle, endAngle, xRotation, sweepFlag } = arcParams;\n        // 直接使用椭圆的 api\n        if (context.ellipse) {\n          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\n        } else {\n          const r = rx > ry ? rx : ry;\n          const scaleX = rx > ry ? 1 : rx / ry;\n          const scaleY = rx > ry ? ry / rx : 1;\n          context.translate(cx, cy);\n          context.rotate(xRotation);\n          context.scale(scaleX, scaleY);\n          context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\n          context.scale(1 / scaleX, 1 / scaleY);\n          context.rotate(-xRotation);\n          context.translate(-cx, -cy);\n        }\n        break;\n      }\n      case 'Z':\n        context.closePath();\n        break;\n      default:\n        break;\n    }\n\n    // 有了 Z 后，当前节点从开始 M 的点开始\n    if (command === 'Z') {\n      currentPoint = startMovePoint;\n    } else {\n      const len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n  }\n}\n\n// 刷新图形元素(Shape 或者 Group)\nexport function refreshElement(element, changeType) {\n  const canvas = element.get('canvas');\n  // 只有存在于 canvas 上时生效\n  if (canvas) {\n    if (changeType === 'remove') {\n      // 一旦 remove，则无法在 element 上拿到包围盒\n      // destroy 后所有属性都拿不到，所以需要暂存一下\n      // 这是一段 hack 的代码\n      element._cacheCanvasBBox = element.get('cacheCanvasBBox');\n    }\n    // 防止反复刷新\n    if (!element.get('hasChanged')) {\n      // 但是始终要标记为 hasChanged，便于后面进行局部渲染\n      element.set('hasChanged', true);\n\n      // 本来只有局部渲染模式下，才需要记录更新的元素队列\n      // if (canvas.get('localRefresh')) {\n      //   canvas.refreshElement(element, changeType, canvas);\n      // }\n      // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\n      // 如果当前元素的父元素发生了改变，可以不放入队列，这句话大概能够提升 15% 的初次渲染性能\n      if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {\n        canvas.refreshElement(element, changeType, canvas);\n        if (canvas.get('autoDraw')) {\n          canvas.draw();\n        }\n      }\n    }\n  }\n}\n\nexport function getRefreshRegion(element): Region | undefined {\n  let region;\n  if (!element.destroyed) {\n    const cacheBox = element.get('cacheCanvasBBox');\n    const validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\n    const bbox = element.getCanvasBBox();\n    const validBBox = bbox && !!(bbox.width && bbox.height);\n    // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\n    if (validCache && validBBox) {\n      region = mergeRegion(cacheBox, bbox);\n    } else if (validCache) {\n      region = cacheBox;\n    } else if (validBBox) {\n      region = bbox;\n    }\n  } else {\n    // 因为元素已经销毁所以无法获取到缓存的包围盒\n    region = element['_cacheCanvasBBox'];\n  }\n  return region;\n}\n\nexport function getMergedRegion(elements): Region {\n  if (!elements.length) {\n    return null;\n  }\n  const minXArr = [];\n  const minYArr = [];\n  const maxXArr = [];\n  const maxYArr = [];\n  each(elements, (el: IElement) => {\n    const region = getRefreshRegion(el);\n    if (region) {\n      minXArr.push(region.minX);\n      minYArr.push(region.minY);\n      maxXArr.push(region.maxX);\n      maxYArr.push(region.maxY);\n    }\n  });\n  return {\n    minX: min(minXArr),\n    minY: min(minYArr),\n    maxX: max(maxXArr),\n    maxY: max(maxYArr),\n  };\n}\n\nexport function mergeView(region, viewRegion) {\n  if (!region || !viewRegion) {\n    return null;\n  }\n  // 不相交，则直接返回 null\n  if (!intersectRect(region, viewRegion)) {\n    return null;\n  }\n  return {\n    minX: Math.max(region.minX, viewRegion.minX),\n    minY: Math.max(region.minY, viewRegion.minY),\n    maxX: Math.min(region.maxX, viewRegion.maxX),\n    maxY: Math.min(region.maxY, viewRegion.maxY),\n  };\n}\n","import { IContainer, IElement, IGroup, IShape, isAllowCapture, multiplyVec2, invert } from '@antv/g-base';\n\nfunction invertFromMatrix(v: number[], matrix: number[]): number[] {\n  if (matrix) {\n    const invertMatrix = invert(matrix);\n    return multiplyVec2(invertMatrix, v);\n  }\n  return v;\n}\n\nfunction getRefXY(element: IElement, x: number, y: number) {\n  // @ts-ignore\n  const totalMatrix = element.getTotalMatrix();\n  if (totalMatrix) {\n    const [refX, refY] = invertFromMatrix([x, y, 1], totalMatrix);\n    return [refX, refY];\n  }\n  return [x, y];\n}\n\n// 拾取前的检测，只有通过检测才能继续拾取\nfunction preTest(element: IElement, x: number, y: number) {\n  // @ts-ignore\n  if (element.isCanvas && element.isCanvas()) {\n    return true;\n  }\n  // 不允许被拾取，则返回 null\n  // @ts-ignore\n  if (!isAllowCapture(element) || element.cfg.isInView === false) {\n    return false;\n  }\n\n  if (element.cfg.clipShape) {\n    // 如果存在 clip\n    const [refX, refY] = getRefXY(element, x, y);\n    if (element.isClipped(refX, refY)) {\n      return false;\n    }\n  }\n  // @ts-ignore ，这个地方调用过于频繁\n  const bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();\n  // 如果没有缓存 bbox，则说明不可见\n  // 注释掉的这段可能会加速拾取，上面的语句改写成 const bbox = element.cfg.cacheCanvasBBox;\n  // 这时候的拾取假设图形/分组在上一次绘制都在视窗内，但是上面已经判定了 isInView 所以意义不大\n  // 现在还调用 element.getCanvasBBox(); 一个很大的原因是便于单元测试\n  // if (!bbox) {\n  //   return false;\n  // }\n  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {\n    return false;\n  }\n  return true;\n}\n\n// 这个方法复写了 g-base 的 getShape\nexport function getShape(container: IContainer, x: number, y: number) {\n  // 没有通过检测，则返回 null\n  if (!preTest(container, x, y)) {\n    return null;\n  }\n  let shape = null;\n  const children = container.getChildren();\n  const count = children.length;\n  for (let i = count - 1; i >= 0; i--) {\n    const child = children[i];\n    if (child.isGroup()) {\n      shape = getShape(child as IGroup, x, y);\n    } else if (preTest(child, x, y)) {\n      const curShape = child as IShape;\n      const [refX, refY] = getRefXY(child, x, y);\n      // @ts-ignore\n      if (curShape.isInShape(refX, refY)) {\n        shape = child;\n      }\n    }\n    if (shape) {\n      break;\n    }\n  }\n  return shape;\n}\n","import { getOffScreenContext } from '@antv/g-base';\n\nexport default function isPointInPath(shape, x, y) {\n  const ctx = getOffScreenContext();\n  shape.createPath(ctx);\n  return ctx.isPointInPath(x, y);\n}\n","/**\n * @fileoverview 判断点是否在多边形内\n * @author dxq613@gmail.com\n */\n\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nconst tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n\n  return x < 0 ? -1 : 1;\n}\n\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n  if (\n    (q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n    Math.min(p1[0], p2[0]) <= q[0] &&\n    q[0] <= Math.max(p1[0], p2[0]) &&\n    Math.min(p1[1], p2[1]) <= q[1] &&\n    q[1] <= Math.max(p1[1], p2[1])\n  ) {\n    return true;\n  }\n  return false;\n}\n\n// 判断点P在多边形内-射线法\nexport default function isInPolygon(points, x, y) {\n  let isHit = false;\n  const n = points.length;\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (\n      dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n      dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0\n    ) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n}\n","import { distance } from '../util';\nexport default function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {\n  const angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\n  if (angle < startAngle || angle > endAngle) {\n    return false;\n  }\n  const point = {\n    x: cx + r * Math.cos(angle),\n    y: cy + r * Math.sin(angle),\n  };\n  return distance(point.x, point.y, x, y) <= lineWidth / 2;\n}\n","import { Line as LineUtil } from '@antv/g-math';\n\nexport default function inLine(x1, y1, x2, y2, lineWidth, x, y) {\n  const minX = Math.min(x1, x2);\n  const maxX = Math.max(x1, x2);\n  const minY = Math.min(y1, y2);\n  const maxY = Math.max(y1, y2);\n  const halfWidth = lineWidth / 2;\n  // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n  // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {\n    return false;\n  }\n  // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n  return LineUtil.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\n","import inLine from './line';\n\nexport default function inPolyline(points: any[], lineWidth: number, x: number, y: number, isClose: boolean) {\n  const count = points.length;\n  if (count < 2) {\n    return false;\n  }\n  for (let i = 0; i < count - 1; i++) {\n    const x1 = points[i][0];\n    const y1 = points[i][1];\n    const x2 = points[i + 1][0];\n    const y2 = points[i + 1][1];\n\n    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  // 如果封闭，则计算起始点和结束点的边\n  if (isClose) {\n    const first = points[0];\n    const last = points[count - 1];\n    if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import inLine from './line';\nimport inArc from './arc';\n\nexport default function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {\n  const halfWidth = lineWidth / 2;\n  return (\n    inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) ||\n    inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) ||\n    inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) ||\n    inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) ||\n    inArc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) ||\n    inArc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) ||\n    inArc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) ||\n    inArc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y)\n  );\n}\n","import { inBox } from '../util';\n\nexport default function inRect(minX, minY, width, height, lineWidth, x, y) {\n  const halfWidth = lineWidth / 2;\n  // 将四个边看做矩形来检测，比边的检测算法要快\n  return (\n    inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边\n    inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边\n    inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边\n    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)\n  ); // 左边\n}\n","import { IElement } from '@antv/g-base';\nimport { isString, each, isArray } from './util';\n\nconst regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nconst regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nconst regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nconst regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\n\nfunction addStop(steps, gradient) {\n  const arr: string[] = steps.match(regexColorStop);\n  each(arr, (item) => {\n    const itemArr = item.split(':');\n    gradient.addColorStop(itemArr[0], itemArr[1]);\n  });\n}\n/**\n * 将边和填充设置的颜色转换成线性渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nexport function parseLineGradient(context: CanvasRenderingContext2D, element: IElement, gradientStr: string) {\n  const arr = regexLG.exec(gradientStr);\n  const angle = (parseFloat(arr[1]) % 360) * (Math.PI / 180);\n  const steps = arr[2];\n  const box = element.getBBox();\n  let start;\n  let end;\n\n  if (angle >= 0 && angle < (1 / 2) * Math.PI) {\n    start = {\n      x: box.minX,\n      y: box.minY,\n    };\n    end = {\n      x: box.maxX,\n      y: box.maxY,\n    };\n  } else if ((1 / 2) * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.minY,\n    };\n    end = {\n      x: box.minX,\n      y: box.maxY,\n    };\n  } else if (Math.PI <= angle && angle < (3 / 2) * Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.maxY,\n    };\n    end = {\n      x: box.minX,\n      y: box.minY,\n    };\n  } else {\n    start = {\n      x: box.minX,\n      y: box.maxY,\n    };\n    end = {\n      x: box.maxX,\n      y: box.minY,\n    };\n  }\n\n  const tanTheta = Math.tan(angle);\n  const tanTheta2 = tanTheta * tanTheta;\n\n  const x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  const y = (tanTheta * (end.x - start.x + tanTheta * (end.y - start.y))) / (tanTheta2 + 1) + start.y;\n  const gradient = context.createLinearGradient(start.x, start.y, x, y);\n  addStop(steps, gradient);\n  return gradient;\n}\n\n/**\n * 将边和填充设置的颜色转换成圆形渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nexport function parseRadialGradient(context: CanvasRenderingContext2D, element: IElement, gradientStr: string) {\n  const arr = regexRG.exec(gradientStr);\n  const fx = parseFloat(arr[1]);\n  const fy = parseFloat(arr[2]);\n  const fr = parseFloat(arr[3]);\n  const steps = arr[4];\n  // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\n  if (fr === 0) {\n    const colors = steps.match(regexColorStop);\n    return colors[colors.length - 1].split(':')[1];\n  }\n  const box = element.getBBox();\n  const width = box.maxX - box.minX;\n  const height = box.maxY - box.minY;\n  const r = Math.sqrt(width * width + height * height) / 2;\n  const gradient = context.createRadialGradient(\n    box.minX + width * fx,\n    box.minY + height * fy,\n    0,\n    box.minX + width / 2,\n    box.minY + height / 2,\n    fr * r\n  );\n  addStop(steps, gradient);\n  return gradient;\n}\n\n/**\n * 边和填充设置的颜色转换成 pattern\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   patternStr   生成 pattern 的字符串\n */\nexport function parsePattern(context: CanvasRenderingContext2D, element: IElement, patternStr: string) {\n  // 在转换过程中进行了缓存\n  if (element.get('patternSource') && element.get('patternSource') === patternStr) {\n    return element.get('pattern');\n  }\n  let pattern;\n  let img;\n  const arr = regexPR.exec(patternStr);\n  let repeat = arr[1];\n  const source = arr[2];\n\n  // Function to be called when pattern loads\n  function onload() {\n    // Create pattern\n    pattern = context.createPattern(img, repeat);\n    element.set('pattern', pattern); // be a cache\n    element.set('patternSource', patternStr);\n  }\n\n  switch (repeat) {\n    case 'a':\n      repeat = 'repeat';\n      break;\n    case 'x':\n      repeat = 'repeat-x';\n      break;\n    case 'y':\n      repeat = 'repeat-y';\n      break;\n    case 'n':\n      repeat = 'no-repeat';\n      break;\n    default:\n      repeat = 'no-repeat';\n  }\n\n  img = new Image();\n  // If source URL is not a data URL\n  if (!source.match(/^data:/i)) {\n    // Set crossOrigin for this image\n    img.crossOrigin = 'Anonymous';\n  }\n  img.src = source;\n\n  if (img.complete) {\n    onload();\n  } else {\n    img.onload = onload;\n    // Fix onload() bug in IE9\n    img.src = img.src;\n  }\n\n  return pattern;\n}\n\nexport function parseStyle(context: CanvasRenderingContext2D, element: IElement, color: string | CanvasPattern) {\n  const bbox = element.getBBox();\n  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {\n    return color;\n  }\n\n  if (isString(color)) {\n    if (color[1] === '(' || color[2] === '(') {\n      if (color[0] === 'l') {\n        // regexLG.test(color)\n        return parseLineGradient(context, element, color);\n      }\n      if (color[0] === 'r') {\n        // regexRG.test(color)\n        return parseRadialGradient(context, element, color);\n      }\n      if (color[0] === 'p') {\n        // regexPR.test(color)\n        return parsePattern(context, element, color);\n      }\n    }\n    return color;\n  }\n\n  if (color instanceof CanvasPattern) {\n    return color;\n  }\n}\n\nexport function parseRadius(radius) {\n  let r1 = 0;\n  let r2 = 0;\n  let r3 = 0;\n  let r4 = 0;\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  }\n  return [r1, r2, r3, r4];\n}\n","/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nimport { PathUtil } from '@antv/g-base';\nimport { Quad as QuadUtil } from '@antv/g-math';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { ext } from '@antv/matrix-util';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { inBox } from './util';\nimport inLine from './in-stroke/line';\nimport inArc from './in-stroke/arc';\n\nconst { transform } = ext;\n\nfunction hasArc(path) {\n  let hasArc = false;\n  const count = path.length;\n  for (let i = 0; i < count; i++) {\n    const params = path[i];\n    const cmd = params[0];\n    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n      hasArc = true;\n      break;\n    }\n  }\n  return hasArc;\n}\n\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n  let isHit = false;\n  const halfWidth = lineWidth / 2;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const { currentPoint, params, prePoint, box } = segment;\n    // 如果在前面已经生成过包围盒，直接按照包围盒计算\n    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n      continue;\n    }\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n        break;\n      case 'Q':\n        const qDistance = QuadUtil.pointDistance(\n          prePoint[0],\n          prePoint[1],\n          params[1],\n          params[2],\n          params[3],\n          params[4],\n          x,\n          y\n        );\n        isHit = qDistance <= lineWidth / 2;\n        break;\n      case 'C':\n        const cDistance = CubicUtil.pointDistance(\n          prePoint[0], // 上一段结束位置, 即 C 的起始点\n          prePoint[1],\n          params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n          params[2],\n          params[3],\n          params[4],\n          params[5],\n          params[6],\n          x,\n          y,\n          length\n        );\n        isHit = cDistance <= lineWidth / 2;\n        break;\n      case 'A':\n        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n        const arcParams = segment.arcParams;\n        const { cx, cy, rx, ry, startAngle, endAngle, xRotation } = arcParams;\n        const p = [x, y, 1];\n        const r = rx > ry ? rx : ry;\n        const scaleX = rx > ry ? 1 : rx / ry;\n        const scaleY = rx > ry ? ry / rx : 1;\n        const m = transform(null, [\n          ['t', -cx, -cy],\n          ['r', -xRotation],\n          ['s', 1 / scaleX, 1 / scaleY],\n        ]);\n        vec3.transformMat3(p, p, m);\n        isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n        break;\n      default:\n        break;\n    }\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\n\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n  const count = path.length;\n  const polygons = [];\n  const polylines = [];\n  let points = []; // 防止第一个命令不是 'M'\n  for (let i = 0; i < count; i++) {\n    const params = path[i];\n    const cmd = params[0];\n    if (cmd === 'M') {\n      // 遇到 'M' 判定是否是新数组，新数组中没有点\n      if (points.length) {\n        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n        polylines.push(points);\n        points = []; // 创建新的点\n      }\n      points.push([params[1], params[2]]);\n    } else if (cmd === 'Z') {\n      if (points.length) {\n        // 存在点\n        polygons.push(points);\n        points = []; // 开始新的点集合\n      }\n      // 如果不存在点，同时 'Z'，则说明是错误，不处理\n    } else {\n      points.push([params[1], params[2]]);\n    }\n  }\n  // 说明 points 未放入 polygons 或者 polyline\n  // 仅当只有一个 M，没有 Z 时会发生这种情况\n  if (points.length > 0) {\n    polylines.push(points);\n  }\n  return {\n    polygons,\n    polylines,\n  };\n}\n\nexport default {\n  hasArc,\n  extractPolygons,\n  isPointInStroke,\n  ...PathUtil,\n};\n","export function getPixelRatio() {\n  return window ? window.devicePixelRatio : 1;\n}\n\n/**\n * 两点之间的距离\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 结束点 x\n * @param {number} y2 结束点 y\n */\nexport function distance(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * 是否在包围盒内\n * @param {number} minX   包围盒开始的点 x\n * @param {number} minY   包围盒开始的点 y\n * @param {number} width  宽度\n * @param {number} height 高度\n * @param {[type]} x      检测点的 x\n * @param {[type]} y      监测点的 y\n */\nexport function inBox(minX: number, minY: number, width: number, height: number, x, y) {\n  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\n}\n\nexport function intersectRect(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n\n// 合并两个区域\nexport function mergeRegion(region1, region2) {\n  if (!region1 || !region2) {\n    return region1 || region2;\n  }\n  return {\n    minX: Math.min(region1.minX, region2.minX),\n    minY: Math.min(region1.minY, region2.minY),\n    maxX: Math.max(region1.maxX, region2.maxX),\n    maxY: Math.max(region1.maxY, region2.maxY),\n  };\n}\n\n/**\n * 判断两个点是否重合，点坐标的格式为 [x, y]\n * @param {Array} point1 第一个点\n * @param {Array} point2 第二个点\n */\nexport function isSamePoint(point1, point2) {\n  return point1[0] === point2[0] && point1[1] === point2[1];\n}\n\nexport {\n  isNil,\n  isString,\n  isFunction,\n  isArray,\n  each,\n  toRadian,\n  mod,\n  isNumberEqual,\n  requestAnimationFrame,\n  clearAnimationFrame,\n} from '@antv/util';\n"],"names":["vMag","v","Math","sqrt","vRatio","u","vAngle","acos","getArcParams","startPoint","params","rx","ry","xRotation","mod","toRadian","PI","arcFlag","sweepFlag","x1","y1","x2","y2","xp","cos","sin","yp","lambda","diff","f","isNaN","cxp","cyp","cx","cy","theta","dTheta","isSamePoint","startAngle","endAngle","atan2","_addDefaultArrow","shape","attrs","isStart","stroke","lineWidth","rad","arrowShape","Path","type","canvas","get","isArrowShape","path","translate","rotateAtPoint","set","_addCustomizedArrow","startArrow","endArrow","arrowAttrs","d","arrowFill","arrowStroke","arrowLineWidth","restAttrs","fill","getShortenOffset","dx","dy","addStartArrow","addEndArrow","SHAPE_ATTRS_MAP","opacity","applyAttrsToContext","context","element","attr","k","name_1","transform","setLineDash","isArray","parseStyle","globalAlpha","drawChildren","children","region","i","length","child","cfg","visible","draw","skipDraw","checkRefresh","refreshElements","each","el","parent_1","parent","refresh","setChildrenRefresh","checkChildrenRefresh","hasChanged","isGroup","checkElementRefresh","clearChanged","elements","destroyed","bbox","cacheCanvasBBox","isInView","intersectRect","drawPath","arcParamsCache","currentPoint","startMovePoint","distance","beginPath","command","tangent","getStartTangent","ArrowUtil","getEndTangent","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","arcParams","ellipse","r","scaleX","scaleY","rotate","scale","arc","closePath","len","refreshElement","changeType","_cacheCanvasBBox","getMergedRegion","minXArr","minYArr","maxXArr","maxYArr","cacheBox","validCache","width","height","getCanvasBBox","validBBox","mergeRegion","getRefreshRegion","push","minX","minY","maxX","maxY","min","max","mergeView","viewRegion","getRefXY","x","y","totalMatrix","getTotalMatrix","matrix","invertMatrix","invert","multiplyVec2","invertFromMatrix","preTest","isCanvas","isAllowCapture","clipShape","refX","refY","isClipped","getShape","container","getChildren","curShape","isInShape","isPointInPath","ctx","getOffScreenContext","createPath","dcmp","abs","onSegment","p1","p2","q","isInPolygon","points","isHit","n","angle","point","inLine","halfWidth","LineUtil","inPolyline","isClose","count","first","last","rectWithRadius","radius","inArc","inRect","inBox","regexLG","regexRG","regexPR","regexColorStop","addStop","steps","gradient","arr","match","item","itemArr","split","addColorStop","color","getBBox","isString","gradientStr","start","end","exec","parseFloat","box","tanTheta","tan","tanTheta2","createLinearGradient","parseLineGradient","fx","fy","fr","colors","createRadialGradient","parseRadialGradient","patternStr","pattern","img","repeat","source","onload","createPattern","Image","crossOrigin","src","complete","parsePattern","CanvasPattern","parseRadius","r1","r2","r3","r4","ext","hasArc","cmd","extractPolygons","polygons","polylines","isPointInStroke","segments","segment","prePoint","QuadUtil","CubicUtil","p","m","vec3","PathUtil","getPixelRatio","window","devicePixelRatio","box1","box2","region1","region2","point1","point2"],"sourceRoot":""}