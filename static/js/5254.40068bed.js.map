{"version":3,"file":"static/js/5254.40068bed.js","mappings":"2LAQM,SAAUA,EAAmBC,GACjC,MAAI,CAACC,EAAAA,GAAAA,IAAeA,EAAAA,GAAAA,QAAkBC,SAASF,GACtC,CACLG,QAAS,EACTC,QAASJ,IAAcC,EAAAA,GAAAA,KAAiB,EAAI,EAC5CI,MAAO,CACLC,UAAW,SACXC,aAAcP,IAAcC,EAAAA,GAAAA,IAAgB,SAAW,QAKzD,CAACA,EAAAA,GAAAA,KAAgBA,EAAAA,GAAAA,OAAiBC,SAASF,GACtC,CACLG,QAASH,IAAcC,EAAAA,GAAAA,MAAkB,EAAI,EAC7CG,QAAS,EACTC,MAAO,CACLC,UAAWN,IAAcC,EAAAA,GAAAA,KAAiB,QAAU,OACpDM,aAAc,SACdC,OAAQC,KAAKC,GAAK,IAKjB,CAAC,CACT,CASK,SAAUC,EAAcC,EAAeC,EAAWC,GACtD,MAAO,CACLC,EAAGH,EAAOG,EAAIF,EAAIJ,KAAKO,IAAIF,GAC3BG,EAAGL,EAAOK,EAAIJ,EAAIJ,KAAKS,IAAIJ,GAE9B,C,gMCfD,SAASK,EAAyBC,GAChC,OAA6C,IAAtCC,MAAMC,KAAK,IAAIC,IAAIH,IAAQI,MACnC,CAED,SAASC,EAAIL,GACX,QAAQM,EAAAA,EAAAA,IAAIN,IAASO,EAAAA,EAAAA,IAAIP,IAAU,CACpC,CAWK,SAAUQ,EAAiBC,EAAiBC,EAAiBC,EAAgBC,GACjF,MAAO,CACLjB,EAAGc,EAAUE,EAAStB,KAAKO,IAAIgB,GAC/Bf,EAAGa,EAAUC,EAAStB,KAAKS,IAAIc,GAElC,CAYK,SAAUC,EACdJ,EACAC,EACAC,EACAG,EACAC,EACAC,QAAA,IAAAA,IAAAA,EAAAA,GAEA,IAAMC,EAAQT,EAAiBC,EAASC,EAASC,EAAQG,GACnDI,EAAMV,EAAiBC,EAASC,EAASC,EAAQI,GAEjDI,EAAaX,EAAiBC,EAASC,EAASM,EAAaF,GAC7DM,EAAWZ,EAAiBC,EAASC,EAASM,EAAaD,GAEjE,GAAIA,EAAmBD,IAAiC,EAAVzB,KAAKC,GAAQ,CAEzD,IAAM+B,EAAcb,EAAiBC,EAASC,EAASC,EAAQG,EAAqBzB,KAAKC,IACnFgC,EAAmBd,EAAiBC,EAASC,EAASM,EAAaF,EAAqBzB,KAAKC,IAC7FiC,EAAqB,CACzB,CAAC,IAAKN,EAAMtB,EAAGsB,EAAMpB,GACrB,CAAC,IAAKc,EAAQA,EAAQ,EAAG,EAAG,EAAGU,EAAY1B,EAAG0B,EAAYxB,GAC1D,CAAC,IAAKc,EAAQA,EAAQ,EAAG,EAAG,EAAGO,EAAIvB,EAAGuB,EAAIrB,GAC1C,CAAC,IAAKsB,EAAWxB,EAAGwB,EAAWtB,IAUjC,OARImB,IACFO,EAAmBC,KAAK,CAAC,IAAKR,EAAaA,EAAa,EAAG,EAAG,EAAGM,EAAiB3B,EAAG2B,EAAiBzB,IACtG0B,EAAmBC,KAAK,CAAC,IAAKR,EAAaA,EAAa,EAAG,EAAG,EAAGI,EAASzB,EAAGyB,EAASvB,KAGxF0B,EAAmBC,KAAK,CAAC,IAAKP,EAAMtB,EAAGsB,EAAMpB,IAC7C0B,EAAmBC,KAAK,CAAC,MAElBD,CACR,CAED,IAAME,EAAWV,EAAmBD,GAAsBzB,KAAKC,GAAK,EAAI,EAClEoC,EAAqB,CACzB,CAAC,IAAKT,EAAMtB,EAAGsB,EAAMpB,GACrB,CAAC,IAAKc,EAAQA,EAAQ,EAAGc,EAAU,EAAGP,EAAIvB,EAAGuB,EAAIrB,GACjD,CAAC,IAAKuB,EAASzB,EAAGyB,EAASvB,IAQ7B,OANImB,GACFU,EAAmBF,KAAK,CAAC,IAAKR,EAAaA,EAAa,EAAGS,EAAU,EAAGN,EAAWxB,EAAGwB,EAAWtB,IAEnG6B,EAAmBF,KAAK,CAAC,IAAKP,EAAMtB,EAAGsB,EAAMpB,IAC7C6B,EAAmBF,KAAK,CAAC,MAElBE,CACR,CAYK,SAAUC,EACdlB,EACAC,EACAC,EACAG,EACAC,GAEA,IAAME,EAAQT,EAAiBC,EAASC,EAASC,EAAQG,GACnDI,EAAMV,EAAiBC,EAASC,EAASC,EAAQI,GAEvD,IAAIa,EAAAA,EAAAA,IAAcb,EAAmBD,EAA8B,EAAVzB,KAAKC,IAAS,CACrE,IAAM+B,EAAcb,EAAiBC,EAASC,EAASC,EAAQG,EAAqBzB,KAAKC,IACzF,MAAO,CACL,CAAC,IAAK2B,EAAMtB,EAAGsB,EAAMpB,GACrB,CAAC,IAAKc,EAAQA,EAAQ,EAAG,EAAG,EAAGU,EAAY1B,EAAG0B,EAAYxB,GAC1D,CAAC,IAAKc,EAAQA,EAAQ,EAAG,EAAG,EAAGM,EAAMtB,EAAGsB,EAAMpB,GAC9C,CAAC,IAAKc,EAAQA,EAAQ,EAAG,EAAG,EAAGU,EAAY1B,EAAG0B,EAAYxB,GAC1D,CAAC,IAAKc,EAAQA,EAAQ,EAAG,EAAG,EAAGM,EAAMtB,EAAGsB,EAAMpB,GAC9C,CAAC,KAEJ,CACD,IAAM4B,EAAWV,EAAmBD,GAAsBzB,KAAKC,GAAK,EAAI,EACxE,MAAO,CACL,CAAC,IAAK2B,EAAMtB,EAAGsB,EAAMpB,GACrB,CAAC,IAAKc,EAAQA,EAAQ,EAAGc,EAAU,EAAGP,EAAIvB,EAAGuB,EAAIrB,GAEpD,CASK,SAAUgC,EAASC,EAAuBC,GAC9C,IAEIC,EACAC,EAFEC,EA7JR,SAAsBC,GACpB,IAAIC,EAAAA,EAAAA,IAAQD,GACV,OAAO,KAGT,IAAIE,EAAOF,EAAO,GAAGxC,EACjB2C,EAAOH,EAAO,GAAGxC,EACjB4C,EAAOJ,EAAO,GAAGtC,EACjB2C,EAAOL,EAAO,GAAGtC,EAQrB,OAPA4C,EAAAA,EAAAA,IAAKN,GAAQ,SAACO,GACZL,EAAOA,EAAOK,EAAM/C,EAAI+C,EAAM/C,EAAI0C,EAClCC,EAAOA,EAAOI,EAAM/C,EAAI+C,EAAM/C,EAAI2C,EAClCC,EAAOA,EAAOG,EAAM7C,EAAI6C,EAAM7C,EAAI0C,EAClCC,EAAOA,EAAOE,EAAM7C,EAAI6C,EAAM7C,EAAI2C,CACnC,IAEM,CACLH,KAAI,EACJC,KAAI,EACJC,KAAI,EACJC,KAAI,EACJ/B,SAAU4B,EAAOC,GAAQ,EACzB5B,SAAU6B,EAAOC,GAAQ,EAE5B,CAqIaG,CADGb,EAAWK,QAINS,EAA6Cb,EAAU,WACrEc,EAD2Dd,EAAU,SACzCa,EAWlC,OATIb,EAAWe,cACbd,EAAWE,EAAIM,KAAOK,EACtBZ,EAAaC,EAAIK,KAAOM,IAExBb,EAAWE,EAAII,KAAOO,EACtBZ,EAAaC,EAAIG,KAAOQ,GAInB,CACLZ,WAFFA,GAAcW,EAGZZ,SAJFA,GAAYY,EAMb,CAMK,SAAUG,EAAmBC,EAAuBC,GACxD,IAAIC,EAAAA,EAAAA,IAASF,KAAOE,EAAAA,EAAAA,IAASD,GAE3B,MAAO,CAACD,EAAIC,GAWd,GAAIlD,EAAaiD,IAAOjD,EAAakD,GAAK,MAAO,CAAC5C,EAAI2C,GAAK3C,EAAI4C,IAS/D,IAPA,IAGIE,EAEAC,EALAC,GAAK,EACL1D,EAAI,EACJE,EAAI,EAEJyD,EAAUN,EAAG5C,OAAS,EAEtBmD,EAAI,IACCF,EAAIL,EAAG5C,QACd+C,EAASG,EACTA,EAAUD,EACVE,GAAKH,EAAOJ,EAAGG,GAAUF,EAAGK,GAAWN,EAAGM,GAAWL,EAAGE,GACxDxD,IAAMqD,EAAGG,GAAUH,EAAGM,IAAYF,EAClCvD,IAAMoD,EAAGE,GAAUF,EAAGK,IAAYF,EAGpC,MAAO,CAACzD,GADR4D,GAAK,GACU1D,EAAI0D,EACpB,CAMK,SAAUC,EAAgBC,EAAqBC,GACnD,IAAMC,EAAcF,EAAYG,OAC1BC,EAAWH,EAAYE,OAM7B,OALAnB,EAAAA,EAAAA,IAAKkB,GAAa,SAACG,EAAGP,QACAQ,IAAhBF,EAASN,KACXM,EAASN,QAAKQ,EAEjB,IACMF,CACR,C,gJChOK,SAAUG,EAAgBC,EAAerF,GAC7C,IAAMsF,GAAYC,EAAAA,EAAAA,IAChB,CAAC,GACDC,EAAAA,EAAAA,IAAIH,EAAO,CAAC,aAAc,OAAQ,YAClCG,EAAAA,EAAAA,IAAIH,EAAO,CAAC,aAAc,OAAQrF,KAEpC,OAAOwF,EAAAA,EAAAA,IAAIF,EAAW,CAAC,QAAS,CAAC,EAClC,CAUK,SAAUG,EAAiBtC,EAAwBuC,EAAcC,EAAaC,GAClF,IAAMC,EAAQ,GACRC,EAAQJ,EAAMK,WAgCpB,OA/BI5C,EAAW6C,SAEbF,EAAMlD,KAAK,CACTqD,MAAO,EACPC,KAAM,GACNC,UAAW,KAGfL,EAAMM,QAAO,SAACC,EAAeC,EAAmBC,GAC9C,IAAMC,EAAeF,EAAYL,MACjC,GAAIL,EACFC,EAAMjD,KAAK,CACTW,OAAQ,CACNJ,EAAWsD,QAAgB,MAARd,EAAc,CAAE5E,EAAG,EAAGE,EAAGuF,GAAiB,CAAEzF,EAAGyF,EAAcvF,EAAG,IACnFkC,EAAWsD,QAAgB,MAARd,EAAc,CAAE5E,EAAG,EAAGE,EAAGuF,GAAiB,CAAEzF,EAAGyF,EAAcvF,EAAG,YAIvF,GAAIsF,EAAc,CAChB,IACMG,GADWL,EAAQJ,MACOO,GAAgB,EAChDX,EAAMjD,KAAK,CACTW,OAAQ,CACNJ,EAAWsD,QAAgB,MAARd,EAAc,CAAE5E,EAAG,EAAGE,EAAGyF,GAAgB,CAAE3F,EAAG2F,EAAazF,EAAG,IACjFkC,EAAWsD,QAAgB,MAARd,EAAc,CAAE5E,EAAG,EAAGE,EAAGyF,GAAgB,CAAE3F,EAAG2F,EAAazF,EAAG,MAGtF,CAEH,OAAOqF,CACR,GAAER,EAAM,IACFD,CACR,CAWK,SAAUc,EACdxD,EACAyD,EACAC,EACAjB,EACAD,GAEA,IAAMmB,EAAQF,EAAOG,OAAOvF,OACtBqE,EAAQ,GACRC,EAAQe,EAAOd,WAiCrB,OA/BAD,EAAMM,QAAO,SAACC,EAAeC,GAC3B,IAAMU,EAAWX,EAAUA,EAAQJ,MAAQK,EAAYL,MACjDO,EAAeF,EAAYL,MAC3BS,GAAeM,EAAWR,GAAgB,EA0BhD,MAzBY,MAARb,EAEFE,EAAMjD,KAAK,CACTW,OAAQ,CACNJ,EAAWsD,QAAQ,CACjB1F,EAAG6E,EAAYY,EAAeE,EAC9BzF,EAAG,IAELkC,EAAWsD,QAAQ,CACjB1F,EAAG6E,EAAYY,EAAeE,EAC9BzF,EAAG,OAKT4E,EAAMjD,KAAK,CACTW,QAAQ0D,EAAAA,EAAAA,IAAI5F,MAAMyF,EAAQ,IAAI,SAACI,EAASC,GACtC,OAAOhE,EAAWsD,QAAQ,CACxB1F,EAAGoG,EAAML,EACT7F,EAAG2E,EAAYY,EAAeE,GAEjC,MAIEJ,CACR,GAAER,EAAM,IACFD,CACR,CAQK,SAAUuB,EAAS9B,EAAgB+B,GACvC,IAAMC,GAAW9B,EAAAA,EAAAA,IAAI6B,EAAY,QACjC,GAAiB,OAAbC,EACF,OAAO,EAGT,IAAMC,GAAY/B,EAAAA,EAAAA,IAAIF,EAAW,QAEjC,aAAsBH,IAAbmC,GAAwC,OAAdC,EACpC,C,2JC5HK,SAAUC,EAAUvB,EAAe5D,EAAeC,GACtD,IAAMZ,EAAMjB,KAAKiB,IAAIW,EAAOC,GACtBX,EAAMlB,KAAKkB,IAAIU,EAAOC,GAE5B,OAAO2D,GAASvE,GAAOuE,GAAStE,CACjC,CAYK,SAAU8F,EAAOC,EAAwBC,EAAsBC,GACnE,IAAIC,EAAAA,EAAAA,IAASH,GACX,OAAOA,EAAOD,OAAOE,EAAcC,GAC9B,IAAIE,EAAAA,EAAAA,IAAQJ,GAAS,CAC1B,IAAMK,EAAeL,EAAOlG,OAC5B,GAAIuG,EAAeJ,EAEjB,IADA,IAAMnD,EAAOmD,EAAeI,EACnBtD,EAAI,EAAGA,EAAID,EAAMC,IACxBiD,EAAO9E,KAAKgF,EAGjB,CAED,OAAOF,CACR,CAQK,SAAUM,EAAcC,EAAQC,GAOpC,MANmB,kBAARD,GACTC,EAAKC,SAAQ,SAACC,UACLH,EAAIG,EACZ,IAGIH,CACR,CAQK,SAAUI,EAAKC,EAAoBC,EAAyBtB,G,aAAzB,IAAAsB,IAAAA,EAAAA,SAAyB,IAAAtB,IAAAA,EAAAA,IAA6BuB,K,IAC7F,IAAqB,eAAAF,GAAWG,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAA7B,IAAMf,EAAM,QACVT,EAAIyB,IAAIhB,KACXa,EAAY3F,KAAK8E,GACjBT,EAAI0B,IAAIjB,GAAQ,GAEnB,C,kGACD,OAAOa,CACR,C,uMC7DKK,EAAkB,CAAC,OAAQ,QAAS,OAAQ,OAAQ,UAmC1D,SAASC,EAAgBC,GACvB,IAAMC,EAASD,EAAOC,QAClBlB,EAAAA,EAAAA,IAASkB,IAAWC,EAAAA,EAAcD,KACpCD,EAAOC,OAASC,EAAAA,EAAcD,GAEjC,CAQK,SAAUE,EAAgBjJ,GAC9B,OAAOA,EAAUkJ,WAAWjJ,EAAAA,GAAAA,OAAmBD,EAAUkJ,WAAWjJ,EAAAA,GAAAA,OAAmB,WAAa,YACrG,CAiBK,SAAUkJ,EACdC,EACAC,EACArE,EACAsE,EACAC,GAEA,IAAM7D,EAAQV,EAAKwE,SAASxE,EAAKyE,MACjC,GAAI/D,EAAMgE,WAAY,CACpB,IAAMC,EAAQjE,EAAMkE,MACdC,EAAYR,EAASS,aAAa,SAClCC,EAAYV,EAASS,aAAa,SAClCE,EAAeZ,EAAKa,WAAWC,aAC/BC,EAAYd,EAASlG,WAAW6C,QAEtC,OAAON,EAAMK,WAAWkB,KAAI,SAACmD,EAAYC,G,MAC/BnE,EAA4BkE,EAAI,KAAnBE,EAAeF,EAAI,MAClCG,EAAOrE,EACPD,EAAQP,EAAM8E,OAAOF,GAGvBG,EAAyE,IAA7DrB,EAAKsB,gBAAgBf,EAAO,OAAGgB,EAAChB,GAAQ1D,EAAK0E,KAAKnJ,QAClEqC,EAAAA,EAAAA,IAAKuF,EAAKwB,OAAO,SAACC,G,MACXA,EAAQH,gBAAgBf,EAAO,OAAGgB,EAAChB,GAAQ1D,EAAK0E,KAAKnJ,SACxDiJ,GAAY,EAEf,IAGD,IAxFyBK,EAAyBzK,EAwF5C0K,GAAQC,EAAAA,EAAAA,GAAgBnB,EAAW5D,EAAO+D,GAC1CiB,GAAQD,EAAAA,EAAAA,GAAgBjB,EAAW9D,EAAO,SAC5C6C,EAASO,EAAS6B,eAAeD,EAAO,CAC1CF,MAAK,EACLI,UAAS,IAGPC,EAAY7B,EAchB,OAbI8B,EAAAA,EAAAA,IAAWD,KACbA,EAAYA,EAAUb,EAAMF,GAAKiB,EAAAA,EAAAA,IAAAA,CAAIf,KAAI,EAAEtE,MAAK,IAAKV,EAAAA,EAAAA,IAAQ,CAAC,EAAG+D,EAAaR,MApFtF,SAA4BA,EAAyBiC,GACnD,IAAMhC,EAASD,EAAOC,OACtB,IAAIlB,EAAAA,EAAAA,IAASkB,KAAgD,IAArCH,EAAgB2C,QAAQxC,GAAgB,CAC9D,IAAM+B,GAActF,EAAAA,EAAAA,IAAIsD,EAAQ,QAAS,CAAC,GACpC0C,GAAYhG,EAAAA,EAAAA,IAAIsF,EAAa,YAAa,GAC1CW,EAASX,EAAYW,QAAUX,EAAYY,MAAQX,EACzDjC,EAAOzI,OAAQkF,EAAAA,EAAAA,IAAQ,CAAC,EAAGuD,EAAOzI,MAAO,CAAEmL,UAAS,EAAEC,OAAM,EAAEC,KAAM,MACrE,CACF,CAiFKC,CADA7C,GAASvD,EAAAA,EAAAA,IAAQ,CAAC,EAAG+D,EAAaR,GAAQd,EAAAA,EAAAA,KAAK,WAAKoD,GAAa,CAAC,WACvCL,GACvBK,GAAaA,EAAU/K,QAEzByI,EAAOzI,OAzGgByK,EAyGchC,EAAOzI,MAzGIA,EAyGG+K,EAAU/K,OAxG/DgL,EAAAA,EAAAA,IAAWhL,GACNA,EAAMyK,IAERvF,EAAAA,EAAAA,IAAQ,CAAC,EAAGuF,EAAazK,KAuG5BwI,EAAgBC,GAET,CAAE8C,GAAI3F,EAAOsE,KAAI,EAAEtE,MAAK,EAAE6C,OAAM,EAAE2B,UAAS,EACnD,GACF,CACD,MAAO,EACR,CAUK,SAAUoB,EAAqBvC,EAAqBC,EAAoBuC,GAE5E,OAAOA,EAAY7E,KAAI,SAAC8E,EAAkB1B,GACxC,IAAIe,EAAY7B,GACZ8B,EAAAA,EAAAA,IAAWD,KACbA,EAAYA,EAAUW,EAAKxB,KAAMF,GAAO9E,EAAAA,EAAAA,IAAQ,CAAC,EAAG+D,EAAayC,KAGnE,IAAMC,GAAaX,EAAAA,EAAAA,IAAWU,EAAKjD,QAC/BiD,EAAKjD,OAAOiD,EAAKxB,KAAMF,GAAO9E,EAAAA,EAAAA,IAAQ,CAAC,EAAG+D,EAAayC,IACvDA,EAAKjD,OAEHA,GAASvD,EAAAA,EAAAA,IAAQ,CAAC,EAAG+D,EAAa8B,EAAWY,GAInD,OAHAnD,EAAgBC,GAEhBiD,EAAKjD,OAASA,EACPiD,CACR,GACF,CASK,SAAUE,EAAkB5G,EAAerF,GAC/C,IAAMkM,GAAc1G,EAAAA,EAAAA,IAAIH,EAAO,CAAC,aAAc,UAAW,CAAC,GAC1D,OAAOE,EAAAA,EAAAA,IAAQ,CAAC,GAAGC,EAAAA,EAAAA,IAAI0G,EAAa,CAAC,UAAW,CAAC,IAAI3G,EAAAA,EAAAA,IAAQ,CAAC,GAAGC,EAAAA,EAAAA,IAAI0G,EAAa,CAAClM,GAAY,CAAC,IACjG,C,wDC5KM,IAAMgJ,EAAgB,CAC3BmD,QAAS,SAACpL,EAAWE,EAAWJ,GAC9B,IAAMuL,EAASvL,EAAI,EAAKJ,KAAK4L,KAAK,GAClC,MAAO,CACL,CAAC,IAAKtL,EAAGE,EAAIJ,GACb,CAAC,IAAKE,EAAIqL,EAAOnL,EAAIJ,EAAI,GACzB,CAAC,IAAKE,EAAIqL,EAAOnL,EAAIJ,EAAI,GACzB,CAAC,IAAKE,EAAGE,EAAIJ,GACb,CAAC,IAAKE,EAAIqL,EAAOnL,EAAIJ,EAAI,GACzB,CAAC,IAAKE,EAAIqL,EAAOnL,EAAIJ,EAAI,GACzB,CAAC,KAEJ,EACDyL,OAAQ,SAACvL,EAAWE,EAAWJ,GAC7B,IAAM0L,EAAQ1L,EAAI,IAClB,MAAO,CAAC,CAAC,IAAKE,EAAIF,EAAGI,EAAIsL,GAAQ,CAAC,IAAKxL,EAAIF,EAAGI,EAAIsL,GAAQ,CAAC,IAAKxL,EAAIF,EAAGI,EAAIsL,GAAQ,CAAC,IAAKxL,EAAIF,EAAGI,EAAIsL,GAAQ,CAAC,KAC9G,EACDC,MAAO,SAACzL,EAAWE,EAAWJ,GAC5B,MAAO,CACL,CAAC,IAAKE,EAAIF,EAAGI,EAAIJ,GACjB,CAAC,IAAKE,EAAIF,EAAGI,EAAIJ,GACjB,CAAC,IAAKE,EAAIF,EAAGI,EAAIJ,GACjB,CAAC,IAAKE,EAAIF,EAAGI,EAAIJ,GAEpB,EACDuJ,KAAM,SAACrJ,EAAWE,EAAWJ,GAC3B,MAAO,CACL,CAAC,IAAKE,EAAIF,EAAI,EAAGI,EAAIJ,GACrB,CAAC,IAAKE,EAAIF,EAAI,EAAGI,EAAIJ,GACrB,CAAC,IAAKE,EAAGE,EAAIJ,GACb,CAAC,IAAKE,EAAGE,EAAIJ,GACb,CAAC,IAAKE,EAAIF,EAAI,EAAGI,EAAIJ,GACrB,CAAC,IAAKE,EAAIF,EAAI,EAAGI,EAAIJ,GAExB,EACD4L,KAAM,SAAC1L,EAAWE,EAAWJ,GAC3B,MAAO,CACL,CAAC,IAAKE,EAAIF,EAAGI,GACb,CAAC,IAAKF,EAAIF,EAAGI,GACb,CAAC,IAAKF,EAAGE,EAAIJ,GACb,CAAC,IAAKE,EAAGE,EAAIJ,GAEhB,EACD6L,OAAQ,SAAC3L,EAAWE,EAAWJ,GAC7B,MAAO,CACL,CAAC,IAAKE,EAAIF,EAAGI,GACb,CAAC,IAAKF,EAAIF,EAAGI,GAEhB,EACD0L,KAAM,SAAC5L,EAAWE,EAAWJ,GAC3B,MAAO,CACL,CAAC,IAAKE,EAAGE,EAAIJ,GACb,CAAC,IAAKE,EAAGE,EAAIJ,GAEhB,E,wGC/CG,SAAU+L,EAAcC,GAC5B,QAAQvI,EAAAA,EAAAA,IAASuI,MAAa/E,EAAAA,EAAAA,IAAQ+E,EACvC,CAQK,SAAUC,EAAaD,QAAA,IAAAA,IAAAA,EAAAA,GAC3B,IAAIE,GAAejF,EAAAA,EAAAA,IAAQ+E,GAAWA,EAAU,CAACA,GAEjD,OAAQE,EAAavL,QACnB,KAAK,EACHuL,EAAe,CAAC,EAAG,EAAG,EAAG,GACzB,MACF,KAAK,EACHA,EAAe,IAAI1L,MAAM,GAAGqK,KAAKqB,EAAa,IAC9C,MACF,KAAK,EACHA,GAAe,6BAAIA,IAAY,IAAAC,EAAAA,EAAAA,IAAKD,IAAY,GAChD,MACF,KAAK,EACHA,GAAe,6BAAIA,IAAY,IAAEA,EAAa,KAAE,GAChD,MACF,QAEEA,EAAeA,EAAaE,MAAM,EAAG,GAIzC,OAAOF,CACR,C,4OCnCKG,EACJ,uTAqBI,SAAUC,EAAezH,EAAc0H,EAA4BC,EAAkBC,GACzF,YAD2C,IAAAF,IAAAA,EAAAA,CAAAA,GACvCA,EAAS3D,KAAa2D,EAAS3D,KAGhB,aAAf/D,EAAM+D,MAAuB8D,EAAAA,GAAAA,SAAqBF,IAAa,CAAC,YAAYnN,SAASoN,IAGlF5H,EAAMgE,WAFJ,MAEyBhE,EAAM+D,IACzC,CAUK,SAAU+D,EAAmB5D,EAAwB6D,EAA2BL,GACpF,IAAMM,EAAYD,GAAQ,GAE1B,IAAInJ,EAAAA,EAAAA,IAASsF,KAAW+D,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,IAAWF,EAAW9D,MAAWpG,EAAAA,EAAAA,IAAQ4J,GAErE,OAAO,KADU5D,EAAAA,EAAAA,IAAS,YACnB,CAAa,CAClBI,MAAOA,EAAMiE,WACb9G,OAAQ,CAAC6C,KAIb,IAAM7C,GAAS+G,EAAAA,EAAAA,GAAYJ,EAAW9D,GAGhCH,GAAOjE,EAAAA,EAAAA,IAAI4H,EAAU,OA7C7B,SAAwBnH,GACtB,IAAIwD,EAAO,SAMX,OALIyD,EAAUa,KAAK9H,GACjBwD,EAAO,WACE5B,EAAAA,EAAAA,IAAS5B,KAClBwD,EAAO,OAEFA,CACR,CAqCoCuE,CAAejH,EAAO,KAEzD,OAAO,KADWyC,EAAAA,EAAAA,IAASC,GACpB,EAAa6B,EAAAA,EAAAA,IAAC,CACnB1B,MAAK,EACL7C,OAAM,GACHqG,GAEN,CASK,SAAUa,EAAUvI,EAAcwI,GACtC,GAAmB,aAAfxI,EAAM+D,MAAyC,aAAlByE,EAASzE,KAAqB,CAC7D,IAAMxB,EAAM,CAAC,EACb,IAAK,IAAMtD,KAAKuJ,EACVC,OAAOC,UAAUC,eAAeC,KAAKJ,EAAUvJ,KACjDsD,EAAItD,GAAKuJ,EAASvJ,IAItBe,EAAM6I,OAAOtG,EACd,CACF,CAQK,SAAUuG,EAAQ9I,GACtB,OAAOA,EAAM+I,OAAS/I,EAAMkE,KAC7B,CAQK,SAAU8E,EACdhJ,EACAvC,EACAkC,GAEQ,IAEJsJ,EADE7H,EADapB,EAAK,OACHlE,OAGrB,GAAc,IAAVsF,EACF6H,EAAQ,CAAC,GAAK,OACT,CACL,IACIC,EAAS,EAQTD,GANAE,EAAAA,EAAAA,IAAa1L,GACVA,EAAWe,aAKN,EADR0K,EAAU,EAAI9H,GADDtB,EAAAA,EAAAA,IAAIH,EAAO,yBAA0B,EAAI,MAEpC,EAAG,EAAIuJ,EAAS,GAJ1B,CAAC,EAAG,EAAI,EAAI9H,GAQd,CADR8H,EAAS,EAAI9H,EAAQ,EACJ,EAAI8H,EAExB,CACD,OAAOD,CACR,CAMK,SAAUG,EAAYpJ,GAE1B,IAAMqB,EAASrB,EAAMqB,OAAOgI,QAAO,SAAChD,GAAS,QAAC4B,EAAAA,EAAAA,IAAM5B,KAAUiD,MAAMjD,EAAK,IAEzE,OAAOtL,KAAKkB,IAAGsN,MAARxO,MAAIyO,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,IAAAA,IAAAA,EAAAA,EAAAA,IAAQnI,IAAM,KAAE4G,EAAAA,EAAAA,IAAMjI,EAAM/D,MAAQwN,IAAWzJ,EAAM/D,MAAG,GACpE,C,yGC3IK,SAAUyN,EAAUhO,GACxB,IAAMiO,GAAM,oBAAIjO,IAAK,GAErBiO,EAAIC,MAAK,SAACC,EAAWC,GACnB,OAAOD,EAAIC,CACZ,IAED,IAAMC,EAAMJ,EAAI7N,OAIhB,OAAY,IAARiO,EACK,EAILA,EAAM,IAAM,EACPJ,GAAKI,EAAM,GAAK,IAIjBJ,EAAII,EAAM,GAAKJ,EAAII,EAAM,EAAI,IAAM,CAC5C,CAMK,SAAUC,EAAQtO,GACtB,IAAMuO,GAAMvJ,EAAAA,EAAAA,IACVhF,GACA,SAACP,EAAW+O,GACV,OAAQ/O,GAAKmO,MAAMY,MAAStL,EAAAA,EAAAA,IAASsL,GAAO,EAAIA,EACjD,GACD,GAGF,OAAwB,IAAjBxO,EAAMI,OAAe,EAAImO,EAAMvO,EAAMI,MAC7C,C,4FC/BYqO,GAAmBC,EAAAA,EAAAA,KAC9B,SAAC5J,EAAW6J,QAAA,IAAAA,IAAAA,EAAAA,CAAAA,GACF,IAAAC,EAA6DD,EAAI,SAAvDE,EAAmDF,EAAI,WAA3CG,EAAuCH,EAAI,WAA/BI,EAA2BJ,EAAI,UAApBK,EAAgBL,EAAI,YACnEM,GAAMC,EAAAA,EAAAA,KAEZ,OADAD,EAAKN,KAAO,CAACI,EAAWC,EAAaF,EAAY,UAAGF,EAAQ,MAAMC,GAAYM,KAAK,KAC5EF,EAAKG,aAAY3I,EAAAA,EAAAA,IAAS3B,GAAQA,EAAO,IAAIuK,KACrD,IACD,SAACvK,EAAW6J,GAAoB,YAApB,IAAAA,IAAAA,EAAAA,CAAAA,IAAoB,SAAC7J,IAAI8G,EAAAA,EAAAA,KAAKjG,EAAAA,EAAAA,IAAOgJ,KAAK,GAAEQ,KAAK,GAAG,IAYrDG,EAAkB,SAACxK,EAAWyK,EAAkBZ,GAC3D,IAGIa,EAFEC,EAAYhB,EAAiB,MAAOE,GAOxCa,GAHG/I,EAAAA,EAAAA,IAAS3B,GAGDA,GAFA2H,EAAAA,EAAAA,IAAS3H,GAKtB,IAGI4K,EACAC,EAJAC,EAAYL,EAEV9P,EAAI,GAIV,GAAIgP,EAAiB3J,EAAM6J,IAASY,EAClC,OAAOzK,EAIT,KAEE4K,EAAcF,EAASK,OAAO,EAxBnB,OA2BXF,EAAelB,EAAiBiB,EAAaf,IAG1Bc,EAAYG,GACzBD,EAAeC,IAYrB,GAPAnQ,EAAE+B,KAAKkO,GAGPE,GAAaD,IACbH,EAAWA,EAASK,OAxCT,KA4CT,OAAOpQ,EAAE0P,KAAK,IAKlB,KAEEO,EAAcF,EAASK,OAAO,EAAG,MAGjCF,EAAelB,EAAiBiB,EAAaf,IAG1Bc,EAAYG,IAS/B,GALAnQ,EAAE+B,KAAKkO,GAEPE,GAAaD,IACbH,EAAWA,EAASK,OAAO,IAGzB,OAAOpQ,EAAE0P,KAAK,IAIlB,MAAO,UAAG1P,EAAE0P,KAAK,IAAG,MACrB,C,iLCpFD,SAASW,EAAUC,EAASC,EAAS1L,GACnC,IAAM2L,EAAS3L,EAAM4L,UAAUH,GACzBI,EAAS7L,EAAM4L,UAAUF,GAE/B,OAAOpO,EAAAA,EAAAA,IAAcqO,EAAQE,EAC9B,CAkBD,SAASC,EAAa/D,EAAY3J,EAAcuF,GAC9C,IAAMlG,EAAakG,EAASlG,WACtB0D,EAASwC,EAASoI,YAClBC,EAAS7K,EAAO+C,MAChB+H,EAAcxO,EAAWqH,OAAO1G,GAChC8N,EAAS/K,EAAO2D,OAAOmH,EAAY1Q,GAMzC,OAJe4Q,EAAAA,EAAAA,IAAKpE,GAAM,SAACxF,GACzB,IAAM6J,EAAa7J,EAAI8J,EAAAA,IACvB,OAAOD,EAAWJ,GAAQ,IAAME,GAAUE,EAAWJ,GAAQ,IAAME,CACpE,KACgBnE,EAAKA,EAAKjM,OAAS,EACrC,CAED,IAAMwQ,GAAelC,EAAAA,EAAAA,KAAQ,SAACpK,GAC5B,GAAIA,EAAMgE,WACR,OAAO,EAOT,IALA,IAAMuI,EAAcvM,EAAMqB,OACpBvF,EAASyQ,EAAYzQ,OACvBE,EAAMgE,EAAM4L,UAAUW,EAAY,IAClCtQ,EAAMD,EAED2I,EAAQ,EAAGA,EAAQ7I,EAAQ6I,IAAS,CAC3C,IAAMpE,EAAQgM,EAAY5H,GAEpB6H,EAAexM,EAAM4L,UAAUrL,GACjCiM,EAAexQ,IACjBA,EAAMwQ,GAEJA,EAAevQ,IACjBA,EAAMuQ,EAET,CACD,OAAQvQ,EAAMD,IAAQF,EAAS,EAChC,IA4BD,SAAS2Q,EAAqB9I,G,QAExB3D,EADE0M,EANR,SAAgC/I,GAC9B,IAAM+I,GAAarL,EAAAA,EAAAA,IAAOsC,EAAS+I,YACnC,OAAOrD,EAAAA,EAAAA,IAAOqD,GAAY,SAACC,GAAyB,eAAS9E,EAAAA,GAAa8E,EAAU5I,KAAK,GAC1F,CAGoB6I,CAAuBjJ,G,IAE1C,IAAwB,eAAA+I,GAAUG,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAA/B,IAAMF,EAAS,QACZG,EAAWH,EAAU7I,SAAS6I,EAAU5I,MAC9C,GAAI+I,GAAYA,EAASC,SAAU,CACjC,IAAMC,GAAclN,EAAAA,EAAAA,IAAI6D,EAASsJ,UAAWH,EAAS5I,OAErD,GAAyB,SADAuD,EAAAA,EAAAA,IAAeqF,EAAUE,EAAaL,EAAU5I,KAAMJ,EAASI,MACxD,CAE9B/D,EAAQ8M,EACR,KACD,CACF,CACF,C,kGAED,IAAM5L,EAASyC,EAASuJ,YAClB/L,EAASwC,EAASoI,YAExB,OAAO/L,GAASmB,GAAUD,CAC3B,CAwCK,SAAUiM,EAAgB/O,EAAc2J,EAAsBpE,GAClE,GAAoB,IAAhBoE,EAAKjM,OACP,OAAO,KAGT,IAAM8L,EAAejE,EAASI,KACxB7C,EAASyC,EAASuJ,YAClB/L,EAASwC,EAASoI,YAElBqB,EAASlM,EAAOgD,MAChB8H,EAAS7K,EAAO+C,MAElBmJ,EAAM,KAGV,GAAqB,YAAjBzF,GAA+C,UAAjBA,EAA0B,CAQ1D,IANA,IACMqE,EADatI,EAASlG,WACGqH,OAAO1G,GAChC/C,EAAI6F,EAAO4D,OAAOmH,EAAY5Q,GAC9BE,EAAI4F,EAAO2D,OAAOmH,EAAY1Q,GAEhCS,EAAMyN,IACD9E,EAAQ,EAAGA,EAAQoD,EAAKjM,OAAQ6I,IAAS,CAChD,IAAMpC,EAAMwF,EAAKpD,GACXyH,EAAa7J,EAAI8J,EAAAA,IACjBpD,EAAQlO,KAAAA,IAACqR,EAAWgB,GAAU/R,EAAM,GAAIN,KAAAA,IAACqR,EAAWJ,GAAUzQ,EAAM,GACtE0N,EAAQjN,IACVA,EAAMiN,EACNoE,EAAM9K,EAET,CAED,OAAO8K,CACR,CAGD,IAAMC,EAAQvF,EAAK,GACfwF,EAAOxF,EAAKA,EAAKjM,OAAS,GACxB0R,EAlLR,SAA0BpP,EAAcuF,GACtC,IAAMlG,EAAakG,EAASlG,WACtByD,EAASyC,EAASuJ,YAClBjE,EAAQ/H,EAAO+H,MACfwE,EAAWxE,EAAMA,EAAMnN,OAAS,GAChC4R,EAAWzE,EAAM,GAInBuE,EAFgB/P,EAAWqH,OAAO1G,GAEb/C,EAIzB,OAHIoC,EAAW6C,SAAWkN,GAAU,EAAIC,GAAY,IAClDD,EAASE,GAEJxM,EAAO0K,UAAU1K,EAAO4D,OAAO0I,GACvC,CAoKgBG,CAAiBvP,EAAOuF,GACjCiK,EAAcN,EAAMjB,EAAAA,IAAce,GAClCS,EAAcP,EAAMjB,EAAAA,IAAcL,GAClC8B,EAAaP,EAAKlB,EAAAA,IAAce,GAChCW,EAAW5M,EAAO4L,WAAY3K,EAAAA,EAAAA,IAAQyL,GAG5C,IAAIzL,EAAAA,EAAAA,IAAQwL,GAAc,CACxB,IAASjJ,EAAQ,EAAGA,EAAQoD,EAAKjM,OAAQ6I,IAAS,CAE1CyH,GADA4B,EAASjG,EAAKpD,IACM0H,EAAAA,IAE1B,GAAInL,EAAO0K,UAAUQ,EAAWgB,GAAQ,KAAOI,GAAUtM,EAAO0K,UAAUQ,EAAWgB,GAAQ,KAAOI,EAAQ,CAC1G,IAAIO,EAMG,CACLV,EAAMW,EACN,KACD,EAPM5L,EAAAA,EAAAA,IAAQiL,KACXA,EAAM,IAERA,EAAInQ,KAAK8Q,EAKZ,CACF,EACG5L,EAAAA,EAAAA,IAAQiL,KACVA,EAAMvB,EAAauB,EAAKjP,EAAOuF,GAElC,KAAM,CACL,IAAIsK,OAAI,EACR,GAAK/M,EAAO6L,UAA4B,YAAhB7L,EAAO6C,KAwBxB,CAEL,IACGyJ,EAAStM,EAAO0K,UAAUkC,IAAeN,EAAStM,EAAO0K,UAAUgC,MACnEJ,EAAStM,EAAOjF,KAAOuR,EAAStM,EAAOlF,KAGxC,OAAO,KAMT,IAHA,IAAIkS,EAAW,EACXC,EAAUpG,EAAKjM,OAAS,EACxBsS,OAAS,EACNF,GAAYC,GAAS,CAE1B,IAAM9H,EAAO0B,EADbqG,EAAYrT,KAAKsT,OAAOH,EAAWC,GAAW,IACjB9B,EAAAA,IAAce,GAC3C,GAAI5B,EAAUnF,EAAMmH,EAAQtM,GAC1B,OAAO6G,EAAKqG,GAGVlN,EAAO0K,UAAUvF,IAASnF,EAAO0K,UAAU4B,IAC7CU,EAAWE,EAAY,EACvBb,EAAOxF,EAAKqG,GACZH,EAAOlG,EAAKqG,EAAY,KAER,IAAZD,IACFZ,EAAOxF,EAAK,IAEdoG,EAAUC,EAAY,EAEzB,CACF,KAvDkD,CAEjD,IAASzJ,EAAQ,EAAGA,EAAQoD,EAAKjM,OAAQ6I,IAAS,CAChD,IAAMqJ,EAEN,GAAIxC,GADEY,GADA4B,EAASjG,EAAKpD,IACM0H,EAAAA,KACDe,GAASI,EAAQtM,GAAS,CACjD,IAAI6M,EAKG,CACLV,EAAMW,EACN,KACD,EAPM5L,EAAAA,EAAAA,IAAQiL,KACXA,EAAM,IAERA,EAAInQ,KAAK8Q,EAKZ,MAAU9M,EAAO0K,UAAUQ,EAAWgB,KAAYI,IACjDD,EAAOS,EACPC,EAAOlG,EAAKpD,EAAQ,GAEvB,EAEGvC,EAAAA,EAAAA,IAAQiL,KACVA,EAAMvB,EAAauB,EAAKjP,EAAOuF,GAElC,CAiCG4J,GAAQU,GAGRlT,KAAKuT,IAAIpN,EAAO0K,UAAU2B,EAAKlB,EAAAA,IAAce,IAAWI,GACxDzS,KAAKuT,IAAIpN,EAAO0K,UAAUqC,EAAK5B,EAAAA,IAAce,IAAWI,KAExDD,EAAOU,EAGZ,CAED,IAAMM,EAAWjC,EAAa3I,EAASuJ,aAKvC,OAJKG,GAAOtS,KAAKuT,IAAIpN,EAAO0K,UAAU2B,EAAKlB,EAAAA,IAAce,IAAWI,IAAWe,EAAW,IACxFlB,EAAME,GAGDF,CACR,CAUK,SAAUmB,EACdzG,EACApE,EACA8K,EACAC,G,aADA,IAAAD,IAAAA,EAAAA,SACA,IAAAC,IAAAA,GAAAA,GAEA,IAKI7J,EACAtE,EANE6L,EAAarE,EAAKsE,EAAAA,IAClBsC,EAhPR,SAAyBvC,EAAmBzI,EAAoB8K,GAC9D,IACMG,EADejL,EAASS,aAAa,YACfyK,YACtBC,EAASnL,EAASmL,OAElBC,GAAapJ,EAAAA,EAAAA,IAAW8I,KAAWA,EAAQG,EAAO,GAAKH,EACvDO,EAAaF,EAAOC,GAIpBJ,EAAeK,EAAaA,EAAWC,QAAQ7C,EAAW2C,IAAe3C,EAAW2C,IAAeA,EAEzG,OAAOpJ,EAAAA,EAAAA,IAAW8I,GAASA,EAAME,EAAcvC,GAAcuC,CAC9D,CAmOsBO,CAAgB9C,EAAYzI,EAAU8K,GACrDU,EAAgBxL,EAASwL,cACvB3K,EAAiBb,EAAShE,MAAK6E,aACjCrE,EAAQ,GAId,SAASiP,EAAQC,EAAUC,GACzB,GAAIZ,KAAazG,EAAAA,EAAAA,IAAMqH,IAA4B,KAAdA,EAAmB,CAEtD,IAAMjJ,EAAO,CACXoI,MAAOE,EACP5G,KAAMqE,EACNmD,YAAaxH,EACblD,KAAMwK,EACN9O,MAAO+O,EACPjK,MAAO0C,EAAK1C,OAASb,EACrBpB,QAAQ,GAGVjD,EAAMjD,KAAKmJ,EACZ,CACF,CAED,IAAImJ,EAAAA,EAAAA,IAASL,GAAgB,CACnB,IAAAP,EAAqBO,EAAa,OAA1BM,EAAaN,EAAa,SAC1C,GAAIM,EAAU,CAEZ,IAAMC,EAAiBd,EAAOrN,KAAI,SAAC2C,GACjC,OAAO6D,EAAKsE,EAAAA,IAAcnI,EAC3B,IACKyL,EAAMF,EAAQ,cAAAjG,EAAAA,EAAAA,IAAC,IAADA,EAAAA,EAAAA,IAAIkG,IAAc,IAChCE,GAAU,SACd7H,KAAMA,EAAKsE,EAAAA,IACXkD,YAAaxH,EACb0G,MAAOE,EACPtJ,MAAO0C,EAAK1C,OAASb,EACrBpB,QAAQ,GACLuM,GAGLxP,EAAMjD,KAAK0S,EACZ,KAAM,CACL,IAAMd,EAASnL,EAASmL,O,IACxB,IAAoB,eAAAF,GAAMiB,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAAvB,IAAM3L,EAAK,QACd,KAAK+D,EAAAA,EAAAA,IAAMmE,EAAWlI,IAAS,CAE7B,IAAMlE,EAAQ8O,EAAO5K,GAGrBkL,EAFAvK,GAAOiE,EAAAA,EAAAA,IAAQ9I,GACfO,EAAQP,EAAMiP,QAAQ7C,EAAWlI,IAElC,CACF,C,kGACF,CACF,KAAM,CACL,IAAM4L,EAAarD,EAAqB9I,GAExCpD,EA/PJ,SAAyB6L,EAAmB0D,GAC1C,IACMvP,EAAQ6L,EADA0D,EAAW5L,OAGzB,OAAI9B,EAAAA,EAAAA,IAAQ7B,GACIA,EAAMgB,KAAI,SAACwO,GACvB,OAAOD,EAAWb,QAAQc,EAC3B,IACYlF,KAAK,KAEbiF,EAAWb,QAAQ1O,EAC3B,CAoPWyP,CAAgB5D,EAAY0D,GACpCjL,EAlPJ,SAAwBuH,EAAmBzI,GACzC,IAAIsM,EACEC,EAAcvM,EAASwM,iBAK7B,GAJID,EAAYpU,SAEdmU,EAAYC,EAAY,IAEtBD,EAAW,CACb,IAAM/L,EAAQ+L,EAAU/L,MACxB,OAAO+L,EAAUhB,QAAQ7C,EAAWlI,GACrC,CAED,IAAM4L,EAAarD,EAAqB9I,GACxC,OAAOmF,EAAAA,EAAAA,IAAQgH,EAChB,CAoOUM,CAAehE,EAAYzI,GAClCyL,EAAQvK,EAAMtE,EACf,CACD,OAAOJ,CACR,CAED,SAASkQ,EAA0B1M,EAAoBvF,EAAOqQ,EAAO6B,G,QAC3D5B,EAAY4B,EAAU,QACxBC,EAAS,GACTC,EAAY7M,EAAS6M,UAC3B,KAAK1S,EAAAA,EAAAA,IAAQ0S,GAAY,CACvB7M,EAASiG,KAAK4G,G,IACd,IAAmB,eAAAA,GAASC,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAAzB,IACGzC,EAASb,EAAgB/O,EADlB,QAC+BuF,GAC5C,GAAIqK,EAAQ,CACV,IAAM0C,EAAY/M,EAASgN,aAAa3C,GAClC4C,EAAUjN,EAASkN,YAAYH,GACrC,GAAsB,YAAlB/M,EAASI,MAAsB6M,EAAQE,QAAS,CAGlD,IAAM3Q,EAAQqO,EAAgBR,EAAQrK,EAAU8K,EAAOC,GACnDvO,EAAMrE,QACRyU,EAAOrT,KAAKiD,EAEf,CACF,CACF,C,kGACF,CAED,OAAOoQ,CACR,CAED,SAASQ,EAA0BpN,EAAUvF,EAAOqQ,EAAO6B,GACjD,IAAA5B,EAAY4B,EAAU,QACxBC,EAAS,GAEThL,EADY5B,EAASqN,UACHC,SAAS7S,EAAM/C,EAAG+C,EAAM7C,GAChD,GAAIgK,GAASA,EAAMzF,IAAI,YAAcyF,EAAMzF,IAAI,UAAW,CACxD,IACMK,EAAQqO,EADMjJ,EAAMzF,IAAI,UAAUyP,YACG5L,EAAU8K,EAAOC,GACxDvO,EAAMrE,QACRyU,EAAOrT,KAAKiD,EAEf,CAED,OAAOoQ,CACR,CAKK,SAAUW,EAAkBxN,EAAYtF,EAAckS,G,QACpDC,EAAS,GAETY,EAAazN,EAAKyN,WAChBC,EAA4Bd,EAAU,OAA9B7B,EAAoB6B,EAAU,MAAvBe,EAAaf,EAAU,S,IAC9C,IAAuB,eAAAa,GAAUG,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAA9B,IAAM3N,EAAQ,QACjB,GAAIA,EAASmN,UAAsC,IAA3BnN,EAASwL,cAAyB,CAExD,IAAMvH,EAAejE,EAASI,KAC1BwN,OAAY,GAGdA,EAFE,CAAC,QAAS,OAAQ,WAAW/W,SAASoN,GAEzBmJ,EAA0BpN,EAAUvF,EAAOqQ,EAAO6B,GACxD,CAAC,OAAQ,OAAQ,OAAQ,WAAW9V,SAASoN,KAIvC,IAAXwJ,EAFWf,EAA0B1M,EAAUvF,EAAOqQ,EAAO6B,GAKhDS,EAA0BpN,EAAUvF,EAAOqQ,EAAO6B,IAGpDxU,SACXuV,GACFE,EAAaC,UAGfjB,EAAOrT,KAAKqU,GAEf,CACF,C,kGAED,OAAOhB,CACR,CAEK,SAAUkB,EAA4B/N,EAAYtF,EAAckS,G,QAChEC,EAASW,EAAkBxN,EAAMtF,EAAOkS,G,IAG5C,IAAwB,eAAA5M,EAAKwB,OAAKwM,EAAAA,EAAAA,QAAA,OAAAA,EAAAA,EAAAA,OAAE,CAA/B,IAAMC,EAAS,QAClBpB,EAASA,EAAOqB,OAAOV,EAAkBS,EAAWvT,EAAOkS,GAC5D,C,kGAED,OAAOC,CACR,C,qIC9dKsB,E,SAAyDC,GAUzD,SAAUlG,EAAUgF,EAA0BvV,EAAWE,GAC7D,IAAMwW,EAASF,EAAUjB,EAAQoB,YAAa,CAAC,CAAC,IAAK3W,EAAGE,KACxDqV,EAAQqB,UAAUF,EACnB,CAsBK,SAAUjX,EAAO8V,EAA0BsB,GAC/C,IAAMH,EAhBF,SAA0BnB,EAAmBsB,GAC3C,MAAWtB,EAAQtR,OAAjBjE,EAAC,IAAEE,EAAC,IAMZ,OALesW,EAAUjB,EAAQoB,YAAa,CAC5C,CAAC,KAAM3W,GAAIE,GACX,CAAC,IAAK2W,GACN,CAAC,IAAK7W,EAAGE,IAGZ,CAQgB4W,CAAgBvB,EAASsB,GACxCtB,EAAQqB,UAAUF,EACnB,CAeK,SAAUK,EAAKxB,EAA0ByB,GAC7C,IAAMC,EAAO1B,EAAQ2B,UACflX,GAAKiX,EAAKvU,KAAOuU,EAAKtU,MAAQ,EAC9BzC,GAAK+W,EAAKrU,KAAOqU,EAAKpU,MAAQ,EACpC0S,EAAQ4B,cAAc,CAACnX,EAAGE,EAAG,IAE7B,IAAMwW,EAASF,EAAUjB,EAAQoB,YAAa,CAC5C,CAAC,KAAM3W,GAAIE,GACX,CAAC,IAAK8W,EAAOA,GACb,CAAC,IAAKhX,EAAGE,KAEXqV,EAAQqB,UAAUF,EACnB,C,kLC7DK,SAAUU,EAAcC,EAAK7I,EAAGrK,GACpC,IAAMmT,EAAqB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAErD,OADAC,EAAAA,GAAqBD,EAAUnT,GACxBoT,EAAAA,GAAcF,EAAKC,EAAU9I,EACrC,CAEK,SAAUgJ,EAAWH,EAAK7I,EAAGiJ,GACjC,IAAMC,EAAsB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEtD,OADAH,EAAAA,GAAkBG,EAAWD,GACtBF,EAAAA,GAAcF,EAAKK,EAAWlJ,EACtC,CAEK,SAAUmJ,EAAUN,EAAK7I,EAAGrK,GAChC,IAAMyT,EAAqB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAErD,OADAL,EAAAA,GAAiBK,EAAUzT,GACpBoT,EAAAA,GAAcF,EAAKO,EAAUpJ,EACrC,CAUK,SAAUgI,EAAUqB,EAAaC,GAGrC,IAFA,IAToBT,EAAK7I,EAAGuJ,EAStBrB,EAASmB,EAAI,GAAGtB,OAAOsB,GAAK,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEnDnU,EAAI,EAAGgL,EAAMoJ,EAAQrX,OAAQiD,EAAIgL,EAAKhL,IAAK,CAClD,IAAMsU,EAASF,EAAQpU,GACvB,OAAQsU,EAAO,IACb,IAAK,IACHZ,EAAcV,EAAQA,EAAQ,CAAEsB,EAAO,GAAIA,EAAO,KAClD,MACF,IAAK,IACHL,EAAUjB,EAAQA,EAAQ,CAAEsB,EAAO,GAAIA,EAAO,KAC9C,MACF,IAAK,IACHR,EAAWd,EAAQA,EAAQsB,EAAO,IAClC,MACF,IAAK,IAvBWX,EAwBDX,EAxBMlI,EAwBEkI,EAxBCqB,EAwBOC,EAAO,GAvBnCT,EAAAA,GAAcF,EAAKU,EAAIvJ,GA4B7B,CAED,OAAOkI,CACR,CAkBK,SAAUuB,EAAQ7H,EAAsBC,EAAsB6H,GAClE,IAAMC,EAAMC,EAAAA,GAAWhI,EAAIC,GACrBgI,EAZF,SAAoBjI,EAAcC,GACtC,OAAOD,EAAG,GAAKC,EAAG,GAAKA,EAAG,GAAKD,EAAG,EACnC,CAU0BnR,CAAUmR,EAAIC,IAAO,EAC9C,OAAI6H,EACEG,EACe,EAAV3Y,KAAKC,GAASwY,EAEhBA,EAGLE,EACKF,EAEQ,EAAVzY,KAAKC,GAASwY,CACtB,C","sources":["../node_modules/@antv/g2/src/util/facet.ts","../node_modules/@antv/g2/src/util/graphics.ts","../node_modules/@antv/g2/src/util/grid.ts","../node_modules/@antv/g2/src/util/helper.ts","../node_modules/@antv/g2/src/util/legend.ts","../node_modules/@antv/g2/src/util/marker.ts","../node_modules/@antv/g2/src/util/padding.ts","../node_modules/@antv/g2/src/util/scale.ts","../node_modules/@antv/g2/src/util/stat.ts","../node_modules/@antv/g2/src/util/text.ts","../node_modules/@antv/g2/src/util/tooltip.ts","../node_modules/@antv/g2/src/util/transform.ts","../node_modules/@antv/matrix-util/src/ext.ts"],"sourcesContent":["import { DIRECTION } from '../constant';\nimport { Point } from '../dependents';\nimport { FacetTitle } from '../interface';\n\n/**\n * @ignore\n * 获取 facet title 的最佳默认配置，防止\n */\nexport function getFactTitleConfig(direction: DIRECTION): FacetTitle {\n  if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction)) {\n    return {\n      offsetX: 0,\n      offsetY: direction === DIRECTION.TOP ? -8 : 8,\n      style: {\n        textAlign: 'center',\n        textBaseline: direction === DIRECTION.TOP ? 'bottom' : 'top',\n      },\n    };\n  }\n\n  if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction)) {\n    return {\n      offsetX: direction === DIRECTION.LEFT ? -8 : 8,\n      offsetY: 0,\n      style: {\n        textAlign: direction === DIRECTION.LEFT ? 'right' : 'left',\n        textBaseline: 'middle',\n        rotate: Math.PI / 2, // 文本阅读习惯从上往下\n      },\n    };\n  }\n\n  return {};\n}\n\n/**\n * @ignore\n * 根据角度，获取 ○ 上的点\n * @param center\n * @param r\n * @param angle\n */\nexport function getAnglePoint(center: Point, r: number, angle: number): Point {\n  return {\n    x: center.x + r * Math.cos(angle),\n    y: center.y + r * Math.sin(angle),\n  };\n}\n","import { BBox } from '@antv/g-svg';\nimport { each, isEmpty, isNumber, isNumberEqual, max, min } from '@antv/util';\nimport { Coordinate, IShape, Point } from '../dependents';\nimport { ShapeInfo } from '../interface';\n\n// 获取图形的包围盒\nfunction getPointsBox(points) {\n  if (isEmpty(points)) {\n    return null;\n  }\n\n  let minX = points[0].x;\n  let maxX = points[0].x;\n  let minY = points[0].y;\n  let maxY = points[0].y;\n  each(points, (point) => {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n\n  return {\n    minX,\n    maxX,\n    minY,\n    maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n  };\n}\n\nfunction uniqueValues<T = number>(array: T[]) {\n  return Array.from(new Set(array)).length === 1;\n}\n\nfunction mid(array: number[]) {\n  return (min(array) + max(array)) / 2;\n}\n\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\nexport function polarToCartesian(centerX: number, centerY: number, radius: number, angleInRadian: number) {\n  return {\n    x: centerX + radius * Math.cos(angleInRadian),\n    y: centerY + radius * Math.sin(angleInRadian),\n  };\n}\n\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getSectorPath(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  startAngleInRadian: number,\n  endAngleInRadian: number,\n  innerRadius: number = 0\n) {\n  const start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  const end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  const innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n  const innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n\n  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n    // 整个圆是分割成两个圆\n    const middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    const innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n    const circlePathCommands = [\n      ['M', start.x, start.y],\n      ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 1, end.x, end.y],\n      ['M', innerStart.x, innerStart.y],\n    ];\n    if (innerRadius) {\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n    }\n\n    circlePathCommands.push(['M', start.x, start.y]);\n    circlePathCommands.push(['Z']);\n\n    return circlePathCommands;\n  }\n\n  const arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  const sectorPathCommands = [\n    ['M', start.x, start.y],\n    ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n    ['L', innerEnd.x, innerEnd.y],\n  ];\n  if (innerRadius) {\n    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n  }\n  sectorPathCommands.push(['L', start.x, start.y]);\n  sectorPathCommands.push(['Z']);\n\n  return sectorPathCommands;\n}\n\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getArcPath(\n  centerX: number,\n  centerY: number,\n  radius: number,\n  startAngleInRadian: number,\n  endAngleInRadian: number\n) {\n  const start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  const end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n\n  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n    const middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    return [\n      ['M', start.x, start.y],\n      ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 1, start.x, start.y],\n      ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],\n      ['A', radius, radius, 0, 1, 0, start.x, start.y],\n      ['Z'],\n    ];\n  }\n  const arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  return [\n    ['M', start.x, start.y],\n    ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n  ];\n}\n\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\nexport function getAngle(shapeModel: ShapeInfo, coordinate: Coordinate) {\n  const points = shapeModel.points;\n  const box = getPointsBox(points);\n  let endAngle;\n  let startAngle;\n  const { startAngle: coordStartAngle, endAngle: coordEndAngle } = coordinate;\n  const diffAngle = coordEndAngle - coordStartAngle;\n\n  if (coordinate.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle,\n    endAngle,\n  };\n}\n\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\nexport function getPolygonCentroid(xs: number | number[], ys: number | number[]) {\n  if (isNumber(xs) && isNumber(ys)) {\n    // 普通色块图，xs 和 ys 是数值\n    return [xs, ys];\n  }\n\n  xs = xs as number[];\n  ys = ys as number[];\n  // 当这个 polygon 的点在一条线上的时候\n  // 也就是说 xs 里面的值都相同，比如：[1, 1, 1, 1]\n  // 或者说 ys 里面的值都相同，比如：[0, 0, 0, 0]\n  // 下面计算得到的 k = 0\n  // 导致返回的值是 [NaN, NaN]\n  // 所以这里做相应的处理\n  if (uniqueValues(xs) || uniqueValues(ys)) return [mid(xs), mid(ys)];\n\n  let i = -1;\n  let x = 0;\n  let y = 0;\n  let former;\n  let current = xs.length - 1;\n  let diff;\n  let k = 0;\n  while (++i < xs.length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n  k *= 3;\n  return [x / k, y / k];\n}\n\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\nexport function getReplaceAttrs(sourceShape: IShape, targetShape: IShape) {\n  const originAttrs = sourceShape.attr();\n  const newAttrs = targetShape.attr();\n  each(originAttrs, (v, k) => {\n    if (newAttrs[k] === undefined) {\n      newAttrs[k] = undefined;\n    }\n  });\n  return newAttrs;\n}\n","import { deepMix, get, map } from '@antv/util';\nimport { DIRECTION } from '../constant';\nimport { Coordinate, Scale, Tick } from '../dependents';\n\n/**\n * @ignore\n * get the grid theme by type, will mix the common cfg of axis\n * @param theme\n * @param direction\n * @returns theme object\n */\nexport function getGridThemeCfg(theme: object, direction: DIRECTION | 'common'): object {\n  const axisTheme = deepMix(\n    {},\n    get(theme, ['components', 'axis', 'common']),\n    get(theme, ['components', 'axis', direction])\n  );\n  return get(axisTheme, ['grid'], {});\n}\n\n/**\n * @ignore\n * get axis grid items\n * @param coordinate\n * @param scale\n * @param dim\n * @return items\n */\nexport function getLineGridItems(coordinate: Coordinate, scale: Scale, dim: string, alignTick?: boolean) {\n  const items = [];\n  const ticks = scale.getTicks();\n  if (coordinate.isPolar) {\n    // 补全 ticks\n    ticks.push({\n      value: 1,\n      text: '',\n      tickValue: '',\n    });\n  }\n  ticks.reduce((preTick: Tick, currentTick: Tick, currentIndex) => {\n    const currentValue = currentTick.value;\n    if (alignTick) {\n      items.push({\n        points: [\n          coordinate.convert(dim === 'y' ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),\n          coordinate.convert(dim === 'y' ? { x: 1, y: currentValue } : { x: currentValue, y: 1 }),\n        ],\n      });\n    } else {\n      if (currentIndex) {\n        const preValue = preTick.value;\n        const middleValue = (preValue + currentValue) / 2;\n        items.push({\n          points: [\n            coordinate.convert(dim === 'y' ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),\n            coordinate.convert(dim === 'y' ? { x: 1, y: middleValue } : { x: middleValue, y: 1 }),\n          ],\n        });\n      }\n    }\n    return currentTick;\n  }, ticks[0]);\n  return items;\n}\n\n/**\n * @ignore\n * get\n * @param coordinate\n * @param xScale\n * @param yScale\n * @param dim\n * @returns items\n */\nexport function getCircleGridItems(\n  coordinate: Coordinate,\n  xScale: Scale,\n  yScale: Scale,\n  alignTick: boolean,\n  dim: string\n) {\n  const count = xScale.values.length;\n  const items = [];\n  const ticks = yScale.getTicks();\n\n  ticks.reduce((preTick: Tick, currentTick: Tick) => {\n    const preValue = preTick ? preTick.value : currentTick.value; // 只有一项数据时取当前值\n    const currentValue = currentTick.value;\n    const middleValue = (preValue + currentValue) / 2;\n    if (dim === 'x') {\n      // 如果是 x 轴作为半径轴，那么只需要取圆弧收尾两个即可\n      items.push({\n        points: [\n          coordinate.convert({\n            x: alignTick ? currentValue : middleValue,\n            y: 0,\n          }),\n          coordinate.convert({\n            x: alignTick ? currentValue : middleValue,\n            y: 1,\n          }),\n        ],\n      });\n    } else {\n      items.push({\n        points: map(Array(count + 1), (__: any, idx: number) => {\n          return coordinate.convert({\n            x: idx / count,\n            y: alignTick ? currentValue : middleValue,\n          });\n        }),\n      });\n    }\n\n    return currentTick;\n  }, ticks[0]);\n  return items;\n}\n\n/**\n * @ignore\n * show grid or not\n * @param axisTheme\n * @param axisOption\n */\nexport function showGrid(axisTheme: any, axisOption: any): boolean {\n  const userGrid = get(axisOption, 'grid');\n  if (userGrid === null) {\n    return false;\n  }\n\n  const themeGrid = get(axisTheme, 'grid');\n\n  return !(userGrid === undefined && themeGrid === null);\n}\n","import { isArray, isString } from '@antv/util';\n\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value: number, start: number, end: number): boolean {\n  const min = Math.min(start, end);\n  const max = Math.max(start, end);\n\n  return value >= min && value <= max;\n}\n\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source: string | any[], targetLength: number, padValue: any) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    const sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      const diff = targetLength - sourceLength;\n      for (let i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n\n  return source;\n}\n\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit<T = any>(obj: T, keys: string[]): T {\n  if (typeof obj === 'object') {\n    keys.forEach((key: string) => {\n      delete obj[key];\n    });\n  }\n\n  return obj;\n}\n\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray: any[], targetArray: any[] = [], map: Map<any, boolean> = new Map()) {\n  for (const source of sourceArray) {\n    if (!map.has(source)) {\n      targetArray.push(source);\n      map.set(source, true);\n    }\n  }\n  return targetArray;\n}\n","import { LegendMarkerCfg } from '@antv/component';\nimport { deepMix, isString, each, get, isFunction } from '@antv/util';\nimport View from '../chart/view';\nimport { DIRECTION } from '../constant';\nimport { Attribute, ShapeAttrs, Tick } from '../dependents';\nimport Geometry from '../geometry/base';\nimport { LegendCfg, LegendItem, MarkerCfg } from '../interface';\nimport { getMappingValue } from './attr';\nimport { omit } from './helper';\nimport { MarkerSymbols } from './marker';\n\n/** 线条形 marker symbol */\nconst STROKES_SYMBOLS = ['line', 'cross', 'tick', 'plus', 'hyphen'];\n\n/**\n * 处理用户配置的 marker style\n * @param markerStyle\n * @param userMarker.style\n * @returns {ShapeAttrs} newStyle\n */\nfunction handleUserMarkerStyle(markerStyle: ShapeAttrs, style: MarkerCfg['style']): ShapeAttrs {\n  if (isFunction(style)) {\n    return style(markerStyle);\n  }\n  return deepMix({}, markerStyle, style);\n}\n\n/**\n * 根据 marker 是否为线条形 symbol, 来调整下样式\n * @param symbol\n * @param style\n * @param color\n */\nfunction adpatorMarkerStyle(marker: LegendMarkerCfg, color: string): void {\n  const symbol = marker.symbol;\n  if (isString(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {\n    const markerStyle = get(marker, 'style', {});\n    const lineWidth = get(markerStyle, 'lineWidth', 1);\n    const stroke = markerStyle.stroke || markerStyle.fill || color;\n    marker.style = deepMix({}, marker.style, { lineWidth, stroke, fill: null });\n  }\n}\n\n/**\n * 设置 marker 的 symbol，将 字符串的 symbol 转换为真正的绘制命令\n * @param marker\n */\nfunction setMarkerSymbol(marker: LegendMarkerCfg): void {\n  const symbol = marker.symbol;\n  if (isString(symbol) && MarkerSymbols[symbol]) {\n    marker.symbol = MarkerSymbols[symbol];\n  }\n}\n\n/**\n * @ignore\n * get the legend layout from direction\n * @param direction\n * @returns layout 'horizontal' | 'vertical'\n */\nexport function getLegendLayout(direction: DIRECTION): 'vertical' | 'horizontal' {\n  return direction.startsWith(DIRECTION.LEFT) || direction.startsWith(DIRECTION.RIGHT) ? 'vertical' : 'horizontal';\n}\n\n/** item of @antv/component legend  */\ntype ComponentLegendItem = Omit<LegendItem, 'marker'> & {\n  marker: any;\n};\n\n/**\n * @ignore\n * get the legend items\n * @param view\n * @param geometry\n * @param attr\n * @param themeMarker\n * @param markerCfg\n * @returns legend items\n */\nexport function getLegendItems(\n  view: View,\n  geometry: Geometry,\n  attr: Attribute,\n  themeMarker: object,\n  userMarker: LegendCfg['marker']\n): ComponentLegendItem[] {\n  const scale = attr.getScale(attr.type);\n  if (scale.isCategory) {\n    const field = scale.field;\n    const colorAttr = geometry.getAttribute('color');\n    const shapeAttr = geometry.getAttribute('shape');\n    const defaultColor = view.getTheme().defaultColor;\n    const isInPolar = geometry.coordinate.isPolar;\n\n    return scale.getTicks().map((tick: Tick, index: number) => {\n      const { text, value: scaleValue } = tick;\n      const name = text;\n      const value = scale.invert(scaleValue);\n\n      // 通过过滤图例项的数据，来看是否 unchecked\n      let unchecked = view.filterFieldData(field, [{ [field]: value }]).length === 0;\n      each(view.views, (subView) => {\n        if (!subView.filterFieldData(field, [{ [field]: value }]).length) {\n          unchecked = true;\n        }\n      });\n\n      // @ts-ignore\n      const color = getMappingValue(colorAttr, value, defaultColor);\n      const shape = getMappingValue(shapeAttr, value, 'point');\n      let marker = geometry.getShapeMarker(shape, {\n        color,\n        isInPolar,\n      });\n\n      let markerCfg = userMarker;\n      if (isFunction(markerCfg)) {\n        markerCfg = markerCfg(name, index, { name, value, ...deepMix({}, themeMarker, marker) });\n      }\n\n      // the marker configure order should be ensure\n      marker = deepMix({}, themeMarker, marker, omit({ ...markerCfg }, ['style']));\n      adpatorMarkerStyle(marker, color);\n      if (markerCfg && markerCfg.style) {\n        // handle user's style settings\n        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);\n      }\n      setMarkerSymbol(marker);\n\n      return { id: value, name, value, marker, unchecked };\n    });\n  }\n  return [];\n}\n\n/**\n *\n * @ignore\n * custom legend 的 items 获取\n * @param themeMarker\n * @param userMarker\n * @param customItems\n */\nexport function getCustomLegendItems(themeMarker: object, userMarker: object, customItems: LegendItem[]) {\n  // 如果有自定义的 item，那么就直接使用，并合并主题的 marker 配置\n  return customItems.map((item: LegendItem, index: number) => {\n    let markerCfg = userMarker;\n    if (isFunction(markerCfg)) {\n      markerCfg = markerCfg(item.name, index, deepMix({}, themeMarker, item));\n    }\n\n    const itemMarker = isFunction(item.marker)\n      ? item.marker(item.name, index, deepMix({}, themeMarker, item))\n      : item.marker;\n\n    const marker = deepMix({}, themeMarker, markerCfg, itemMarker);\n    setMarkerSymbol(marker);\n\n    item.marker = marker;\n    return item;\n  });\n}\n\n/**\n * get the legend cfg from theme, will mix the common cfg of legend theme\n *\n * @param theme view theme object\n * @param direction legend direction\n * @returns legend theme cfg\n */\nexport function getLegendThemeCfg(theme: object, direction: string): object {\n  const legendTheme = get(theme, ['components', 'legend'], {});\n  return deepMix({}, get(legendTheme, ['common'], {}), deepMix({}, get(legendTheme, [direction], {})));\n}\n","/** @ignore */\nexport const MarkerSymbols = {\n  hexagon: (x: number, y: number, r: number) => {\n    const diffX = (r / 2) * Math.sqrt(3);\n    return [\n      ['M', x, y - r],\n      ['L', x + diffX, y - r / 2],\n      ['L', x + diffX, y + r / 2],\n      ['L', x, y + r],\n      ['L', x - diffX, y + r / 2],\n      ['L', x - diffX, y - r / 2],\n      ['Z'],\n    ];\n  },\n  bowtie: (x: number, y: number, r: number) => {\n    const diffY = r - 1.5;\n    return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];\n  },\n  cross: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y - r],\n      ['L', x + r, y + r],\n      ['M', x + r, y - r],\n      ['L', x - r, y + r],\n    ];\n  },\n  tick: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r / 2, y - r],\n      ['L', x + r / 2, y - r],\n      ['M', x, y - r],\n      ['L', x, y + r],\n      ['M', x - r / 2, y + r],\n      ['L', x + r / 2, y + r],\n    ];\n  },\n  plus: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y],\n      ['L', x + r, y],\n      ['M', x, y - r],\n      ['L', x, y + r],\n    ];\n  },\n  hyphen: (x: number, y: number, r: number) => {\n    return [\n      ['M', x - r, y],\n      ['L', x + r, y],\n    ];\n  },\n  line: (x: number, y: number, r: number) => {\n    return [\n      ['M', x, y - r],\n      ['L', x, y + r],\n    ];\n  },\n};\n","import { isArray, isNumber } from '@antv/util';\nimport { Padding, ViewPadding } from '../interface';\n\n/**\n * @ignore\n * 是否是自动 padding\n * @param padding\n */\nexport function isAutoPadding(padding: ViewPadding): padding is 'auto' {\n  return !isNumber(padding) && !isArray(padding);\n}\n\n/**\n * @ignore\n * padding 的解析逻辑\n * @param padding\n * @return [ top, right, bottom, left ]\n */\nexport function parsePadding(padding: number[] | number = 0): Padding {\n  let paddingArray = isArray(padding) ? padding : [padding];\n\n  switch (paddingArray.length) {\n    case 0:\n      paddingArray = [0, 0, 0, 0];\n      break;\n    case 1:\n      paddingArray = new Array(4).fill(paddingArray[0]);\n      break;\n    case 2:\n      paddingArray = [...paddingArray, ...paddingArray];\n      break;\n    case 3:\n      paddingArray = [...paddingArray, paddingArray[1]];\n      break;\n    default:\n      // 其他情况，只去四个\n      paddingArray = paddingArray.slice(0, 4);\n      break;\n  }\n\n  return paddingArray as [number, number, number, number];\n}\n","import { firstValue, get, isEmpty, isNil, isNumber, isString, valuesOfKey } from '@antv/util';\nimport { GROUP_ATTRS } from '../constant';\nimport { getScale, Scale, Coordinate } from '../dependents';\nimport { LooseObject, ScaleOption, ViewCfg } from '../interface';\nimport { isFullCircle } from './coordinate';\n\nconst dateRegex =\n  /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\\2(?:29))(\\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;\n\n/**\n * 获取字段对应数据的类型\n * @param field 数据字段名\n * @param data 数据源\n * @returns default type 返回对应的数据类型\n */\nfunction getDefaultType(value: any): string {\n  let type = 'linear';\n  if (dateRegex.test(value)) {\n    type = 'timeCat';\n  } else if (isString(value)) {\n    type = 'cat';\n  }\n  return type;\n}\n\n/**\n * using the scale type if user specified, otherwise infer the type\n */\nexport function inferScaleType(scale: Scale, scaleDef: ScaleOption = {}, attrType: string, geometryType: string): string {\n  if (scaleDef.type) return scaleDef.type;\n  // identity scale 直接返回\n  // geometry 类型有: edge,heatmap,interval,line,path,point,polygon,schema,voilin等；理论上，interval 下，可以用 linear scale 作为分组字段\n  if (scale.type !== 'identity' && GROUP_ATTRS.includes(attrType) && ['interval'].includes(geometryType)) {\n    return 'cat';\n  }\n  return scale.isCategory ? 'cat' : scale.type;\n}\n\n/**\n * @ignore\n * 为指定的 `field` 字段数据创建 scale\n * @param field 字段名\n * @param [data] 数据集，可为空\n * @param [scaleDef] 列定义，可为空\n * @returns scale 返回创建的 Scale 实例\n */\nexport function createScaleByField(field: string | number, data?: LooseObject[] | [], scaleDef?: ScaleOption): Scale {\n  const validData = data || [];\n\n  if (isNumber(field) || (isNil(firstValue(validData, field)) && isEmpty(scaleDef))) {\n    const Identity = getScale('identity');\n    return new Identity({\n      field: field.toString(),\n      values: [field],\n    });\n  }\n\n  const values = valuesOfKey(validData, field);\n\n  // 如果已经定义过这个度量 (fix-later 单纯从数据中，推断 scale type 是不精确的)\n  const type = get(scaleDef, 'type', getDefaultType(values[0]));\n  const ScaleCtor = getScale(type);\n  return new ScaleCtor({\n    field,\n    values,\n    ...scaleDef,\n  });\n}\n\n/**\n * @ignore\n * 同步 scale\n * @todo 是否可以通过 scale.update() 方法进行更新\n * @param scale 需要同步的 scale 实例\n * @param newScale 同步源 Scale\n */\nexport function syncScale(scale: Scale, newScale: Scale) {\n  if (scale.type !== 'identity' && newScale.type !== 'identity') {\n    const obj = {};\n    for (const k in newScale) {\n      if (Object.prototype.hasOwnProperty.call(newScale, k)) {\n        obj[k] = newScale[k];\n      }\n    }\n\n    scale.change(obj);\n  }\n}\n\n/**\n * @ignore\n * get the scale name, if alias exist, return alias, or else field\n * @param scale\n * @returns the name of field\n */\nexport function getName(scale: Scale): string {\n  return scale.alias || scale.field;\n}\n\n/**\n * 根据 scale values 和 coordinate 获取分类默认 range\n * @param scale 需要获取的 scale 实例\n * @param coordinate coordinate 实例\n * @param theme theme\n */\nexport function getDefaultCategoryScaleRange(\n  scale: Scale,\n  coordinate: Coordinate,\n  theme: ViewCfg['theme']\n): Scale['range'] {\n  const { values } = scale;\n  const count = values.length;\n  let range;\n\n  if (count === 1) {\n    range = [0.5, 1]; // 只有一个分类时,防止计算出现 [0.5,0.5] 的状态\n  } else {\n    let widthRatio = 1;\n    let offset = 0;\n\n    if (isFullCircle(coordinate)) {\n      if (!coordinate.isTransposed) {\n        range = [0, 1 - 1 / count];\n      } else {\n        widthRatio = get(theme, 'widthRatio.multiplePie', 1 / 1.3);\n        offset = (1 / count) * widthRatio;\n        range = [offset / 2, 1 - offset / 2];\n      }\n    } else {\n      offset = 1 / count / 2; // 两边留下分类空间的一半\n      range = [offset, 1 - offset]; // 坐标轴最前面和最后面留下空白防止绘制柱状图时\n    }\n  }\n  return range;\n}\n\n/**\n * @function y轴scale的max\n * @param {yScale}\n */\nexport function getMaxScale(scale: Scale) {\n  // 过滤values[]中 NaN/undefined/null 等\n  const values = scale.values.filter((item) => !isNil(item) && !isNaN(item));\n\n  return Math.max(...values, isNil(scale.max) ? -Infinity : scale.max);\n}\n","import { reduce, isNumber } from '@antv/util';\n\n/**\n * 获得中位数\n * @param array\n */\nexport function getMedian(array: number[]) {\n  const arr = [...array];\n  // 先排序\n  arr.sort((a: number, b: number) => {\n    return a - b;\n  });\n\n  const len = arr.length;\n\n  // median\n  // 0\n  if (len === 0) {\n    return 0;\n  }\n\n  // 奇数\n  if (len % 2 === 1) {\n    return arr[(len - 1) / 2];\n  }\n\n  // 偶数\n  return (arr[len / 2] + arr[len / 2 - 1]) / 2;\n}\n\n/**\n * 获得平均值\n * @param array\n */\nexport function getMean(array: number[]) {\n  const sum = reduce(\n    array,\n    (r: number, num: number) => {\n      return (r += isNaN(num) || !isNumber(num) ? 0 : num);\n    },\n    0\n  );\n\n  return array.length === 0 ? 0 : sum / array.length;\n}\n","import { isString, memoize, values, toString } from '@antv/util';\nimport * as CSS from 'csstype';\nimport { getCanvasContext } from './context';\n\ntype FontFace = CSS.Properties;\n\ntype Font = Pick<FontFace, 'fontFamily' | 'fontWeight' | 'fontStyle' | 'fontVariant'> & {\n  fontSize?: number;\n};\n\n/**\n * 计算文本在画布中的宽度\n */\nexport const measureTextWidth = memoize(\n  (text: any, font: Font = {}): number => {\n    const { fontSize, fontFamily, fontWeight, fontStyle, fontVariant } = font;\n    const ctx = getCanvasContext();\n    ctx!.font = [fontStyle, fontVariant, fontWeight, `${fontSize}px`, fontFamily].join(' ');\n    return ctx!.measureText(isString(text) ? text : '').width;\n  },\n  (text: any, font: Font = {}) => [text, ...values(font)].join('')\n);\n\n/**\n * 获取文本的 ... 文本。\n * 算法（减少每次 measureText 的长度，measureText 的性能跟字符串时间相关）：\n * 1. 先通过 STEP 逐步计算，找到最后一个小于 maxWidth 的字符串\n * 2. 然后对最后这个字符串二分计算\n * @param text 需要计算的文本, 由于历史原因 除了支持string，还支持空值,number和数组等\n * @param maxWidth\n * @param font\n */\nexport const getEllipsisText = (text: any, maxWidth: number, font?: Font) => {\n  const STEP = 16; // 每次 16，调参工程师\n  const DOT_WIDTH = measureTextWidth('...', font);\n\n  let leftText;\n\n  if (!isString(text)) {\n    leftText = toString(text);\n  } else {\n    leftText = text;\n  }\n\n  let leftWidth = maxWidth;\n\n  const r = []; // 最终的分段字符串\n  let currentText;\n  let currentWidth;\n\n  if (measureTextWidth(text, font) <= maxWidth) {\n    return text;\n  }\n\n  // 首先通过 step 计算，找出最大的未超出长度的\n  while (true) {\n    // 更新字符串\n    currentText = leftText.substr(0, STEP);\n\n    // 计算宽度\n    currentWidth = measureTextWidth(currentText, font);\n\n    // 超出剩余宽度，则停止\n    if (currentWidth + DOT_WIDTH > leftWidth) {\n      if (currentWidth > leftWidth) {\n        break;\n      }\n    }\n\n    r.push(currentText);\n\n    // 没有超出，则计算剩余宽度\n    leftWidth -= currentWidth;\n    leftText = leftText.substr(STEP);\n\n    // 字符串整体没有超出\n    if (!leftText) {\n      return r.join('');\n    }\n  }\n\n  // 最下的最后一个 STEP，使用 1 递增（用二分效果更高）\n  while (true) {\n    // 更新字符串\n    currentText = leftText.substr(0, 1);\n\n    // 计算宽度\n    currentWidth = measureTextWidth(currentText, font);\n\n    // 超出剩余宽度，则停止\n    if (currentWidth + DOT_WIDTH > leftWidth) {\n      break;\n    }\n\n    r.push(currentText);\n    // 没有超出，则计算剩余宽度\n    leftWidth -= currentWidth;\n    leftText = leftText.substr(1);\n\n    if (!leftText) {\n      return r.join('');\n    }\n  }\n\n  return `${r.join('')}...`;\n};\n","import {\n  contains,\n  filter,\n  find,\n  isArray,\n  isEmpty,\n  isFunction,\n  isNil,\n  isNumberEqual,\n  isObject,\n  memoize,\n  get,\n  values,\n} from '@antv/util';\nimport { View } from '../chart';\nimport { FIELD_ORIGIN, GROUP_ATTRS } from '../constant';\nimport { Attribute, Scale } from '../dependents';\nimport Geometry from '../geometry/base';\nimport { Data, Datum, MappingDatum, Point, TooltipCfg, TooltipTitle } from '../interface';\nimport { getName, inferScaleType } from './scale';\n\nfunction snapEqual(v1: any, v2: any, scale: Scale) {\n  const value1 = scale.translate(v1);\n  const value2 = scale.translate(v2);\n\n  return isNumberEqual(value1, value2);\n}\n\nfunction getXValueByPoint(point: Point, geometry: Geometry): number {\n  const coordinate = geometry.coordinate;\n  const xScale = geometry.getXScale();\n  const range = xScale.range;\n  const rangeMax = range[range.length - 1];\n  const rangeMin = range[0];\n\n  const invertPoint = coordinate.invert(point);\n\n  let xValue = invertPoint.x;\n  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {\n    xValue = rangeMin; // 极坐标下，scale 的 range 被做过特殊处理\n  }\n  return xScale.translate(xScale.invert(xValue));\n}\n\nfunction filterYValue(data: Data, point: Point, geometry: Geometry) {\n  const coordinate = geometry.coordinate;\n  const yScale = geometry.getYScale();\n  const yField = yScale.field;\n  const invertPoint = coordinate.invert(point);\n  const yValue = yScale.invert(invertPoint.y);\n\n  const result = find(data, (obj: Datum) => {\n    const originData = obj[FIELD_ORIGIN];\n    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;\n  });\n  return result || data[data.length - 1];\n}\n\nconst getXDistance = memoize((scale: Scale) => {\n  if (scale.isCategory) {\n    return 1;\n  }\n  const scaleValues = scale.values; // values 是无序的\n  const length = scaleValues.length;\n  let min = scale.translate(scaleValues[0]);\n  let max = min;\n\n  for (let index = 0; index < length; index++) {\n    const value = scaleValues[index];\n    // 时间类型需要 translate\n    const numericValue = scale.translate(value);\n    if (numericValue < min) {\n      min = numericValue;\n    }\n    if (numericValue > max) {\n      max = numericValue;\n    }\n  }\n  return (max - min) / (length - 1);\n});\n\n/**\n * 获得 tooltip 的 title\n * @param originData\n * @param geometry\n * @param title\n */\nfunction getTooltipTitle(originData: Datum, geometry: Geometry, title: TooltipTitle): string {\n  const positionAttr = geometry.getAttribute('position');\n  const fields = positionAttr.getFields();\n  const scales = geometry.scales;\n\n  const titleField = isFunction(title) || !title ? fields[0] : title;\n  const titleScale = scales[titleField];\n\n  // 如果创建了该字段对应的 scale，则通过 scale.getText() 方式取值，因为用户可能对数据进行了格式化\n  // 如果没有对应的 scale，则从原始数据中取值，如果原始数据中仍不存在，则直接放回 title 值\n  const tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;\n\n  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;\n}\n\nfunction getAttributesForLegend(geometry: Geometry) {\n  const attributes = values(geometry.attributes);\n  return filter(attributes, (attribute: Attribute) => contains(GROUP_ATTRS, attribute.type));\n}\n\nfunction getTooltipValueScale(geometry: Geometry) {\n  const attributes = getAttributesForLegend(geometry);\n  let scale;\n  for (const attribute of attributes) {\n    const tmpScale = attribute.getScale(attribute.type);\n    if (tmpScale && tmpScale.isLinear) {\n      const tmpScaleDef = get(geometry.scaleDefs, tmpScale.field);\n      const inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry.type);\n      if (inferedScaleType !== 'cat') {\n        // 如果指定字段是非 position 的，同时是连续的\n        scale = tmpScale;\n        break;\n      }\n    }\n  }\n\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  return scale || yScale || xScale;\n}\n\nfunction getTooltipValue(originData: Datum, valueScale: Scale) {\n  const field = valueScale.field;\n  const value = originData[field];\n\n  if (isArray(value)) {\n    const texts = value.map((eachValue) => {\n      return valueScale.getText(eachValue);\n    });\n    return texts.join('-');\n  }\n  return valueScale.getText(value);\n}\n\n// 根据原始数据获取 tooltip item 中 name 值\nfunction getTooltipName(originData: Datum, geometry: Geometry) {\n  let nameScale: Scale;\n  const groupScales = geometry.getGroupScales();\n  if (groupScales.length) {\n    // 如果存在分组类型，取第一个分组类型\n    nameScale = groupScales[0];\n  }\n  if (nameScale) {\n    const field = nameScale.field;\n    return nameScale.getText(originData[field]);\n  }\n\n  const valueScale = getTooltipValueScale(geometry);\n  return getName(valueScale);\n}\n\n/**\n * @ignore\n * Finds data from geometry by point\n * @param point canvas point\n * @param data an item of geometry.dataArray\n * @param geometry\n * @returns\n */\nexport function findDataByPoint(point: Point, data: MappingDatum[], geometry: Geometry) {\n  if (data.length === 0) {\n    return null;\n  }\n\n  const geometryType = geometry.type;\n  const xScale = geometry.getXScale();\n  const yScale = geometry.getYScale();\n\n  const xField = xScale.field;\n  const yField = yScale.field;\n\n  let rst = null;\n\n  // 热力图采用最小逼近策略查找 point 击中的数据\n  if (geometryType === 'heatmap' || geometryType === 'point') {\n    // 将 point 画布坐标转换为原始数据值\n    const coordinate = geometry.coordinate;\n    const invertPoint = coordinate.invert(point); // 转换成归一化的数据\n    const x = xScale.invert(invertPoint.x); // 转换为原始值\n    const y = yScale.invert(invertPoint.y); // 转换为原始值\n\n    let min = Infinity;\n    for (let index = 0; index < data.length; index++) {\n      const obj = data[index];\n      const originData = obj[FIELD_ORIGIN];\n      const range = (originData[xField] - x) ** 2 + (originData[yField] - y) ** 2;\n      if (range < min) {\n        min = range;\n        rst = obj;\n      }\n    }\n\n    return rst;\n  }\n\n  // 其他 Geometry 类型按照 x 字段数据进行查找\n  const first = data[0];\n  let last = data[data.length - 1];\n  const xValue = getXValueByPoint(point, geometry);\n  const firstXValue = first[FIELD_ORIGIN][xField];\n  const firstYValue = first[FIELD_ORIGIN][yField];\n  const lastXValue = last[FIELD_ORIGIN][xField];\n  const isYArray = yScale.isLinear && isArray(firstYValue); // 考虑 x 维度相同，y 是数组区间的情况\n\n  // 如果 x 的值是数组\n  if (isArray(firstXValue)) {\n    for (let index = 0; index < data.length; index++) {\n      const record = data[index];\n      const originData = record[FIELD_ORIGIN];\n      // xValue 在 originData[xField] 的数值区间内\n      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {\n        if (isYArray) {\n          // 层叠直方图场景，x 和 y 都是数组区间\n          if (!isArray(rst)) {\n            rst = [];\n          }\n          rst.push(record);\n        } else {\n          rst = record;\n          break;\n        }\n      }\n    }\n    if (isArray(rst)) {\n      rst = filterYValue(rst, point, geometry);\n    }\n  } else {\n    let next;\n    if (!xScale.isLinear && xScale.type !== 'timeCat') {\n      // x 轴对应的数据为非线性以及非时间类型的数据采用遍历查找\n      for (let index = 0; index < data.length; index++) {\n        const record = data[index];\n        const originData = record[FIELD_ORIGIN];\n        if (snapEqual(originData[xField], xValue, xScale)) {\n          if (isYArray) {\n            if (!isArray(rst)) {\n              rst = [];\n            }\n            rst.push(record);\n          } else {\n            rst = record;\n            break;\n          }\n        } else if (xScale.translate(originData[xField]) <= xValue) {\n          last = record;\n          next = data[index + 1];\n        }\n      }\n\n      if (isArray(rst)) {\n        rst = filterYValue(rst, point, geometry);\n      }\n    } else {\n      // x 轴对应的数据为线性以及时间类型，进行二分查找，性能更好\n      if (\n        (xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) &&\n        (xValue > xScale.max || xValue < xScale.min)\n      ) {\n        // 不在数据范围内\n        return null;\n      }\n\n      let firstIdx = 0;\n      let lastIdx = data.length - 1;\n      let middleIdx;\n      while (firstIdx <= lastIdx) {\n        middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n        const item = data[middleIdx][FIELD_ORIGIN][xField];\n        if (snapEqual(item, xValue, xScale)) {\n          return data[middleIdx];\n        }\n\n        if (xScale.translate(item) <= xScale.translate(xValue)) {\n          firstIdx = middleIdx + 1;\n          last = data[middleIdx];\n          next = data[middleIdx + 1];\n        } else {\n          if (lastIdx === 0) {\n            last = data[0];\n          }\n          lastIdx = middleIdx - 1;\n        }\n      }\n    }\n\n    if (last && next) {\n      // 计算最逼近的\n      if (\n        Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) >\n        Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)\n      ) {\n        last = next;\n      }\n    }\n  }\n\n  const distance = getXDistance(geometry.getXScale()); // 每个分类间的平均间距\n  if (!rst && Math.abs(xScale.translate(last[FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {\n    rst = last;\n  }\n\n  return rst;\n}\n\n/**\n * @ignore\n * Gets tooltip items\n * @param data\n * @param geometry\n * @param [title]\n * @returns\n */\nexport function getTooltipItems(\n  data: MappingDatum,\n  geometry: Geometry,\n  title: TooltipTitle = '',\n  showNil: boolean = false\n) {\n  const originData = data[FIELD_ORIGIN];\n  const tooltipTitle = getTooltipTitle(originData, geometry, title);\n  const tooltipOption = geometry.tooltipOption;\n  const { defaultColor } = geometry.theme;\n  const items = [];\n  let name;\n  let value;\n\n  function addItem(itemName, itemValue) {\n    if (showNil || (!isNil(itemValue) && itemValue !== '')) {\n      // 值为 null的时候，忽视\n      const item = {\n        title: tooltipTitle,\n        data: originData, // 原始数据\n        mappingData: data, // 映射后的数据\n        name: itemName,\n        value: itemValue,\n        color: data.color || defaultColor,\n        marker: true,\n      };\n\n      items.push(item);\n    }\n  }\n\n  if (isObject(tooltipOption)) {\n    const { fields, callback } = tooltipOption;\n    if (callback) {\n      // 用户定义了回调函数\n      const callbackParams = fields.map((field: string) => {\n        return data[FIELD_ORIGIN][field];\n      });\n      const cfg = callback(...callbackParams);\n      const itemCfg = {\n        data: data[FIELD_ORIGIN], // 原始数据\n        mappingData: data, // 映射后的数据\n        title: tooltipTitle,\n        color: data.color || defaultColor,\n        marker: true, // 默认展示 marker\n        ...cfg,\n      };\n\n      items.push(itemCfg);\n    } else {\n      const scales = geometry.scales;\n      for (const field of fields) {\n        if (!isNil(originData[field])) {\n          // 字段数据为null, undefined 时不显示\n          const scale = scales[field];\n          name = getName(scale);\n          value = scale.getText(originData[field]);\n          addItem(name, value);\n        }\n      }\n    }\n  } else {\n    const valueScale = getTooltipValueScale(geometry);\n    // 字段数据为null ,undefined时不显示\n    value = getTooltipValue(originData, valueScale);\n    name = getTooltipName(originData, geometry);\n    addItem(name, value);\n  }\n  return items;\n}\n\nfunction getTooltipItemsByFindData(geometry: Geometry, point, title, tooltipCfg: TooltipCfg) {\n  const { showNil } = tooltipCfg;\n  const result = [];\n  const dataArray = geometry.dataArray;\n  if (!isEmpty(dataArray)) {\n    geometry.sort(dataArray); // 先进行排序，便于 tooltip 查找\n    for (const data of dataArray) {\n      const record = findDataByPoint(point, data, geometry);\n      if (record) {\n        const elementId = geometry.getElementId(record);\n        const element = geometry.elementsMap[elementId];\n        if (geometry.type === 'heatmap' || element.visible) {\n          // Heatmap 没有 Element\n          // 如果图形元素隐藏了，怎不再 tooltip 上展示相关数据\n          const items = getTooltipItems(record, geometry, title, showNil);\n          if (items.length) {\n            result.push(items);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getTooltipItemsByHitShape(geometry, point, title, tooltipCfg: TooltipCfg) {\n  const { showNil } = tooltipCfg;\n  const result = [];\n  const container = geometry.container;\n  const shape = container.getShape(point.x, point.y);\n  if (shape && shape.get('visible') && shape.get('origin')) {\n    const mappingData = shape.get('origin').mappingData;\n    const items = getTooltipItems(mappingData, geometry, title, showNil);\n    if (items.length) {\n      result.push(items);\n    }\n  }\n\n  return result;\n}\n\n/**\n * 不进行递归查找\n */\nexport function findItemsFromView(view: View, point: Point, tooltipCfg: TooltipCfg) {\n  const result = [];\n  // 先从 view 本身查找\n  const geometries = view.geometries;\n  const { shared, title, reversed } = tooltipCfg;\n  for (const geometry of geometries) {\n    if (geometry.visible && geometry.tooltipOption !== false) {\n      // geometry 可见同时未关闭 tooltip\n      const geometryType = geometry.type;\n      let tooltipItems;\n      if (['point', 'edge', 'polygon'].includes(geometryType)) {\n        // 始终通过图形拾取\n        tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n      } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {\n        // 如果是 'area', 'line', 'path'，始终通过数据查找方法查找 tooltip\n        tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n      } else {\n        if (shared !== false) {\n          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);\n        } else {\n          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);\n        }\n      }\n      if (tooltipItems.length) {\n        if (reversed) {\n          tooltipItems.reverse();\n        }\n        // geometry 有可能会有多个 item，因为用户可以设置 geometry.tooltip('x*y*z')\n        result.push(tooltipItems);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function findItemsFromViewRecurisive(view: View, point: Point, tooltipCfg: TooltipCfg) {\n  let result = findItemsFromView(view, point, tooltipCfg);\n\n  // 递归查找，并合并结果\n  for (const childView of view.views) {\n    result = result.concat(findItemsFromView(childView, point, tooltipCfg));\n  }\n\n  return result;\n}\n","import { ext } from '@antv/matrix-util';\nimport { IElement, IGroup, IShape } from '../dependents';\n\nconst transform: (m: number[], actions: any[][]) => number[] = ext.transform;\n\nexport { transform };\n\n/**\n * 对元素进行平移操作。\n * @param element 进行变换的元素\n * @param x x 方向位移\n * @param y y 方向位移\n */\nexport function translate(element: IGroup | IShape, x: number, y: number) {\n  const matrix = transform(element.getMatrix(), [['t', x, y]]);\n  element.setMatrix(matrix);\n}\n\n/**\n * 获取元素旋转矩阵 (以元素的左上角为旋转点)\n * @param element 进行变换的元素\n * @param rotateRadian 旋转弧度\n */\nexport function getRotateMatrix(element: IElement, rotateRadian: number) {\n  const { x, y } = element.attr();\n  const matrix = transform(element.getMatrix(), [\n    ['t', -x, -y],\n    ['r', rotateRadian],\n    ['t', x, y],\n  ]);\n  return matrix;\n}\n\n/**\n * 对元素进行旋转操作。\n * @param element 进行变换的元素\n * @param rotateRadian 旋转弧度\n */\nexport function rotate(element: IGroup | IShape, rotateRadian: number) {\n  const matrix = getRotateMatrix(element, rotateRadian);\n  element.setMatrix(matrix);\n}\n\n/**\n * 获取元矩阵。\n * @returns identity matrix\n */\nexport function getIdentityMatrix(): number[] {\n  return [1, 0, 0, 0, 1, 0, 0, 0, 1];\n}\n\n/**\n * 围绕图形中心点进行缩放\n * @param element 进行缩放的图形元素\n * @param ratio 缩放比例\n */\nexport function zoom(element: IGroup | IShape, ratio: number) {\n  const bbox = element.getBBox();\n  const x = (bbox.minX + bbox.maxX) / 2;\n  const y = (bbox.minY + bbox.maxY) / 2;\n  element.applyToMatrix([x, y, 1]);\n\n  const matrix = transform(element.getMatrix(), [\n    ['t', -x, -y],\n    ['s', ratio, ratio],\n    ['t', x, y],\n  ]);\n  element.setMatrix(matrix);\n}\n","/**\n * @description 扩展方法，提供 gl-matrix 为提供的方法\n * */\nimport { mat3, vec2 } from 'gl-matrix';\n\ntype mat3Type = [number, number, number, number, number, number, number, number, number];\n\nexport function leftTranslate(out, a, v) {\n  const transMat: mat3Type = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n  mat3.fromTranslation(transMat, v);\n  return mat3.multiply(out, transMat, a);\n}\n\nexport function leftRotate(out, a, rad) {\n  const rotateMat: mat3Type = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n  mat3.fromRotation(rotateMat, rad);\n  return mat3.multiply(out, rotateMat, a);\n}\n\nexport function leftScale(out, a, v) {\n  const scaleMat: mat3Type = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n  mat3.fromScaling(scaleMat, v);\n  return mat3.multiply(out, scaleMat, a);\n}\n\nfunction leftMultiply(out, a, a1) {\n  return mat3.multiply(out, a1, a);\n}\n/**\n * 根据 actions 来做 transform\n * @param m\n * @param actions\n */\nexport function transform(m: number[], actions: any[][]) {\n  const matrix = m ? [].concat(m) : [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\n  for (let i = 0, len = actions.length; i < len; i++) {\n    const action = actions[i];\n    switch (action[0]) {\n      case 't':\n        leftTranslate(matrix, matrix, [ action[1], action[2] ]);\n        break;\n      case 's':\n        leftScale(matrix, matrix, [ action[1], action[2] ]);\n        break;\n      case 'r':\n        leftRotate(matrix, matrix, action[1]);\n        break;\n      case 'm':\n        leftMultiply(matrix, matrix, action[1]);\n        break;\n      default:\n        break;\n    }\n  }\n\n  return matrix;\n}\n\n/**\n * 向量 v1 到 向量 v2 夹角的方向\n * @param  {Array} v1 向量\n * @param  {Array} v2 向量\n * @return {Boolean} >= 0 顺时针 < 0 逆时针\n */\nexport function direction(v1: number[], v2: number[]): number {\n  return v1[0] * v2[1] - v2[0] * v1[1];\n}\n\n/**\n * 二维向量 v1 到 v2 的夹角\n * @param v1\n * @param v2\n * @param direct\n */\nexport function angleTo(v1: [number, number], v2: [number, number], direct: boolean): number {\n  const ang = vec2.angle(v1, v2);\n  const angleLargeThanPI = direction(v1, v2) >= 0;\n  if (direct) {\n    if (angleLargeThanPI) {\n      return Math.PI * 2 - ang;\n    }\n    return ang;\n  }\n\n  if (angleLargeThanPI) {\n    return ang;\n  }\n  return Math.PI * 2 - ang;\n}\n\n/**\n * 计算二维向量的垂直向量\n * @param out\n * @param v\n * @param flag\n */\nexport function vertical(out: number[], v: number[], flag: boolean): number[] {\n  if (flag) {\n    out[0] = v[1];\n    out[1] = -1 * v[0];\n  } else {\n    out[0] = -1 * v[1];\n    out[1] = v[0];\n  }\n\n  return out;\n}\n"],"names":["getFactTitleConfig","direction","DIRECTION","includes","offsetX","offsetY","style","textAlign","textBaseline","rotate","Math","PI","getAnglePoint","center","r","angle","x","cos","y","sin","uniqueValues","array","Array","from","Set","length","mid","min","max","polarToCartesian","centerX","centerY","radius","angleInRadian","getSectorPath","startAngleInRadian","endAngleInRadian","innerRadius","start","end","innerStart","innerEnd","middlePoint","innerMiddlePoint","circlePathCommands","push","arcSweep","sectorPathCommands","getArcPath","isNumberEqual","getAngle","shapeModel","coordinate","endAngle","startAngle","box","points","isEmpty","minX","maxX","minY","maxY","each","point","getPointsBox","coordStartAngle","diffAngle","isTransposed","getPolygonCentroid","xs","ys","isNumber","former","diff","i","current","k","getReplaceAttrs","sourceShape","targetShape","originAttrs","attr","newAttrs","v","undefined","getGridThemeCfg","theme","axisTheme","deepMix","get","getLineGridItems","scale","dim","alignTick","items","ticks","getTicks","isPolar","value","text","tickValue","reduce","preTick","currentTick","currentIndex","currentValue","convert","middleValue","getCircleGridItems","xScale","yScale","count","values","preValue","map","__","idx","showGrid","axisOption","userGrid","themeGrid","isBetween","padEnd","source","targetLength","padValue","isString","isArray","sourceLength","omit","obj","keys","forEach","key","uniq","sourceArray","targetArray","Map","sourceArray_1_1","has","set","STROKES_SYMBOLS","setMarkerSymbol","marker","symbol","MarkerSymbols","getLegendLayout","startsWith","getLegendItems","view","geometry","themeMarker","userMarker","getScale","type","isCategory","field_1","field","colorAttr_1","getAttribute","shapeAttr_1","defaultColor_1","getTheme","defaultColor","isInPolar_1","tick","index","scaleValue","name","invert","unchecked","filterFieldData","_a","views","subView","markerStyle","color","getMappingValue","shape","getShapeMarker","isInPolar","markerCfg","isFunction","__assign","indexOf","lineWidth","stroke","fill","adpatorMarkerStyle","id","getCustomLegendItems","customItems","item","itemMarker","getLegendThemeCfg","legendTheme","hexagon","diffX","sqrt","bowtie","diffY","cross","plus","hyphen","line","isAutoPadding","padding","parsePadding","paddingArray","__read","slice","dateRegex","inferScaleType","scaleDef","attrType","geometryType","GROUP_ATTRS","createScaleByField","data","validData","isNil","firstValue","toString","valuesOfKey","test","getDefaultType","syncScale","newScale","Object","prototype","hasOwnProperty","call","change","getName","alias","getDefaultCategoryScaleRange","range","offset","isFullCircle","getMaxScale","filter","isNaN","apply","__spreadArray","Infinity","getMedian","arr","sort","a","b","len","getMean","sum","num","measureTextWidth","memoize","font","fontSize","fontFamily","fontWeight","fontStyle","fontVariant","ctx","getCanvasContext","join","measureText","width","getEllipsisText","maxWidth","leftText","DOT_WIDTH","currentText","currentWidth","leftWidth","substr","snapEqual","v1","v2","value1","translate","value2","filterYValue","getYScale","yField","invertPoint","yValue","find","originData","FIELD_ORIGIN","getXDistance","scaleValues","numericValue","getTooltipValueScale","attributes","attribute","getAttributesForLegend","attributes_1_1","tmpScale","isLinear","tmpScaleDef","scaleDefs","getXScale","findDataByPoint","xField","rst","first","last","xValue","rangeMax","rangeMin","getXValueByPoint","firstXValue","firstYValue","lastXValue","isYArray","record","next","firstIdx","lastIdx","middleIdx","floor","abs","distance","getTooltipItems","title","showNil","tooltipTitle","fields","getFields","scales","titleField","titleScale","getText","getTooltipTitle","tooltipOption","addItem","itemName","itemValue","mappingData","isObject","callback","callbackParams","cfg","itemCfg","fields_1_1","valueScale","eachValue","getTooltipValue","nameScale","groupScales","getGroupScales","getTooltipName","getTooltipItemsByFindData","tooltipCfg","result","dataArray","dataArray_1_1","elementId","getElementId","element","elementsMap","visible","getTooltipItemsByHitShape","container","getShape","findItemsFromView","geometries","shared","reversed","geometries_1_1","tooltipItems","reverse","findItemsFromViewRecurisive","_c","childView","concat","transform","ext","matrix","getMatrix","setMatrix","rotateRadian","getRotateMatrix","zoom","ratio","bbox","getBBox","applyToMatrix","leftTranslate","out","transMat","mat3","leftRotate","rad","rotateMat","leftScale","scaleMat","m","actions","a1","action","angleTo","direct","ang","vec2","angleLargeThanPI"],"sourceRoot":""}