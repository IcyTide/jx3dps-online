{"version":3,"file":"static/js/1893.191faff4.js","mappings":"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","sources":["../node_modules/@antv/g2/src/geometry/label/layout/pie/util.ts","../node_modules/@antv/g2/src/geometry/label/layout/point/adjust-position.ts","../node_modules/@antv/g2/src/geometry/label/layout/worker/hide-overlap.ts","../node_modules/@antv/g2/src/geometry/label/pie.ts","../node_modules/@antv/g2/src/geometry/label/polar.ts","../node_modules/@antv/g2/src/geometry/label/util/createWorker.ts","../node_modules/@antv/g2/src/geometry/label/util/index.ts","../node_modules/@antv/g2/src/geometry/line.ts","../node_modules/@antv/g2/src/geometry/path.ts"],"sourcesContent":["import { PolarLabelItem } from '../../interface';\n\n/**\n * 碰撞检测算法\n */\nexport function antiCollision(\n  items: PolarLabelItem[],\n  labelHeight: number,\n  plotRange: { minY: number; maxY: number; minX: number; maxX: number }\n) {\n  const labels = items.filter((item) => !item.invisible);\n\n  // sorted by y, mutable\n  labels.sort((a, b) => a.y - b.y);\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const startY = plotRange.minY;\n  const endY = plotRange.maxY;\n  let totalHeight = Math.abs(startY - endY);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null,\n    };\n  });\n\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}\n","import { groupBy, keys, map } from '@antv/util';\nimport { IElement, IGroup, IShape, BBox } from '../../../../dependents';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { findLabelTextShape } from '../../util';\n\n/**\n * point-adjust-position layout 的配置类型\n */\nexport interface PointAdjustPositionLayoutCfg {\n  offset?: number;\n}\n\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\nfunction sortLabels(geometry: Geometry, labels: IGroup[]) {\n  const yField = geometry.getXYFields()[1];\n  const result: IGroup[] = [];\n  const sortedLabels = labels.sort((left, right) => left.get('data')[yField] - left.get('data')[yField]);\n\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.shift());\n  }\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.pop());\n  }\n  result.push(...sortedLabels);\n\n  return result;\n}\n\nfunction hasSome(dones: IGroup[], current: IGroup, compare: (left: IGroup, right: IGroup) => boolean): boolean {\n  return dones.some((done) => compare(done, current));\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nfunction getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\nfunction checkShapeOverlap(dones: IGroup[], current: IGroup): boolean {\n  return hasSome(dones, current, (left, right) => {\n    const leftText = findLabelTextShape(left);\n    const rightText = findLabelTextShape(right);\n\n    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n  });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\nexport function pointAdjustPosition(\n  items: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox,\n  cfg: PointAdjustPositionLayoutCfg\n): void {\n  if (shapes.length === 0) {\n    return;\n  }\n\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'point') {\n    return;\n  }\n  const [xField, yField] = geometry.getXYFields();\n  const groupedLabels = groupBy(labels, (label) => label.get('data')[xField]);\n  const dones: IGroup[] = [];\n  const offset = (cfg && cfg.offset) || items[0]?.offset || 12;\n\n  map(keys(groupedLabels).reverse(), (xValue) => {\n    const sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n    while (sortedCollections.length) {\n      const current = sortedCollections.shift();\n      const textShape = findLabelTextShape(current);\n      if (\n        hasSome(\n          dones,\n          current,\n          (left, right) =>\n            left.get('data')[xField] === right.get('data')[xField] &&\n            left.get('data')[yField] === right.get('data')[yField]\n        )\n      ) {\n        // 重复位置，直接隐藏\n        textShape.set('visible', false);\n        continue;\n      }\n      const upFail = checkShapeOverlap(dones, current);\n      let downFail: boolean = false;\n      if (upFail) {\n        textShape.attr('y', textShape.attr('y') + 2 * offset);\n        downFail = checkShapeOverlap(dones, current);\n      }\n      if (downFail) {\n        textShape.set('visible', false);\n        continue;\n      }\n      dones.push(current);\n    }\n  });\n}\n","const onmessage = function (e) {\n  type Item = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rotation?: number;\n    visible?: boolean;\n  };\n\n  // Copy from src/util/collision-detect.ts\n  function generateUtils() {\n    type Vec2 = [number, number];\n\n    type Point = { x: number; y: number };\n\n    /**\n     * 定义投影对象\n     */\n    type Projection = { min: number; max: number };\n\n    function dot(a, b) {\n      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n    }\n    /**\n     * 1. 获取投影轴\n     */\n    function getAxes(points: Point[] /** 多边形的关键点 */): Vec2[] {\n      // 目前先处理 平行矩形 的场景, 其他多边形不处理\n      if (points.length > 4) {\n        return [];\n      }\n      // 获取向量\n      const vector = (start: Point, end: Point): Vec2 => {\n        return [end.x - start.x, end.y - start.y];\n      };\n\n      // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n      const AB = vector(points[0], points[1]);\n      const BC = vector(points[1], points[2]);\n\n      return [AB, BC];\n    }\n\n    /**\n     * 绕指定点顺时针旋转后的点坐标\n     * 默认绕原点旋转\n     */\n    function rotateAtPoint(point: Point, deg = 0, origin = { x: 0, y: 0 }): Point {\n      const { x, y } = point;\n      return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n      };\n    }\n\n    /**\n     * @private\n     * 转化为顶点坐标数组\n     *\n     * @param {Object} box\n     */\n    function getRectPoints(box: Item): Point[] {\n      const points = [\n        { x: box.x, y: box.y },\n        { x: box.x + box.width, y: box.y },\n        { x: box.x + box.width, y: box.y + box.height },\n        { x: box.x, y: box.y + box.height },\n      ];\n\n      const rotation = box.rotation;\n      if (rotation) {\n        return [\n          rotateAtPoint(points[0], rotation, points[0]),\n          rotateAtPoint(points[1], rotation, points[0]),\n          rotateAtPoint(points[2], rotation, points[0]),\n          rotateAtPoint(points[3], rotation, points[0]),\n        ];\n      }\n\n      return points;\n    }\n\n    /**\n     * 2. 获取多边形在投影轴上的投影\n     *\n     * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n     * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n     */\n    function getProjection(points: Point[] /** 多边形的关键点 */, axis: Vec2): Projection {\n      // 目前先处理矩形的场景\n      if (points.length > 4) {\n        return { min: 0, max: 0 };\n      }\n\n      const scalars = [];\n      points.forEach((point) => {\n        scalars.push(dot([point.x, point.y], axis));\n      });\n\n      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };\n    }\n\n    function isProjectionOverlap(projection1: Projection, projection2: Projection): boolean {\n      return projection1.max > projection2.min && projection1.min < projection2.max;\n    }\n\n    function isValidNumber(d: number) {\n      return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n    }\n\n    function isValidBox(box: Item) {\n      return ['x', 'y', 'width', 'height'].every(attr => isValidNumber(box[attr]))\n    }\n\n    function isIntersectRect(box1: Item, box2: Item, margin: number = 0): boolean {\n      return !(\n        box2.x > box1.x + box1.width + margin ||\n        box2.x + box2.width < box1.x - margin ||\n        box2.y > box1.y + box1.height + margin ||\n        box2.y + box2.height < box1.y - margin\n      );\n    }\n    function intersect(box1: Item, box2: Item, margin: number = 0) {\n      if (!isValidBox(box1) || !isValidBox(box2)) return false;\n\n      // Quick detect, if rotation is null or zero.\n      if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n      }\n\n      // 分别获取 4 个关键点\n      const rect1Points = getRectPoints(box1);\n      const rect2Points = getRectPoints(box2);\n\n      // 获取所有投影轴\n      const axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n\n      for (let i = 0; i < axes.length; i++) {\n        const axis = axes[i];\n        const projection1 = getProjection(rect1Points, axis);\n        const projection2 = getProjection(rect2Points, axis);\n\n        if (!isProjectionOverlap(projection1, projection2)) return false;\n      }\n\n      return true;\n    }\n    return { intersect }\n  }\n  const { intersect } = generateUtils();\n\n  // Label layouts.\n  function hideOverlap(items: Item[]) {\n    const boxes = items.slice();\n    for (let i = 0; i < boxes.length; i++) {\n      const box1 = boxes[i];\n      if (box1.visible) {\n        for (let j = i + 1; j < boxes.length; j++) {\n          const box2 = boxes[j];\n          if (box1 !== box2 && box2.visible) {\n            if (intersect(box1, box2)) {\n              box2.visible = false;\n            }\n          }\n        }\n      }\n    }\n    return boxes;\n  }\n\n  const methods = {\n    'hide-overlap': hideOverlap,\n  }\n\n  // Main\n  try {\n    const eventData = JSON.parse(e.data);\n    if (!eventData || !eventData.type || !methods[eventData.type]) return;\n\n    const { type, items } = eventData;\n    const result = methods[type](items);\n    self.postMessage(result);\n  } catch (e) {\n    throw e;\n  }\n}\n\nconst code = `\n   self.onmessage = ${onmessage.toString()}\n`\nexport { code };\n","import { deepMix, get, isArray } from '@antv/util';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport { LabelItem } from './interface';\nimport PolarLabel from './polar';\n\n/**\n * 饼图 label\n */\nexport default class PieLabel extends PolarLabel {\n  public defaultLayout = 'distribute';\n\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const cfg = super.getDefaultLabelCfg(offset, position);\n    return deepMix({}, cfg, get(this.geometry.theme, 'pieLabels', {}));\n  }\n\n  /** @override */\n  protected getLabelOffset(offset: string | number): number {\n    return super.getLabelOffset(offset) || 0;\n  }\n\n  protected getLabelRotate(angle: number, offset: number, isLabelLimit: boolean) {\n    let rotate;\n    if (offset < 0) {\n      rotate = angle;\n      if (rotate > Math.PI / 2) {\n        rotate = rotate - Math.PI;\n      }\n      if (rotate < -Math.PI / 2) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n\n    let align;\n    if (point.angle <= Math.PI / 2 && point.x >= center.x) {\n      align = 'left';\n    } else {\n      align = 'right';\n    }\n    if (point.offset <= 0) {\n      if (align === 'right') {\n        align = 'left';\n      } else {\n        align = 'right';\n      }\n    }\n    return align;\n  }\n\n  protected getArcPoint(point) {\n    return point;\n  }\n\n  protected getPointAngle(point) {\n    const coordinate = this.getCoordinate();\n    const startPoint = {\n      x: isArray(point.x) ? point.x[0] : point.x,\n      y: point.y[0],\n    };\n    const endPoint = {\n      x: isArray(point.x) ? point.x[1] : point.x,\n      y: point.y[1],\n    };\n    let angle;\n    const startAngle = getAngleByPoint(coordinate, startPoint);\n    if (point.points && point.points[0].y === point.points[1].y) {\n      angle = startAngle;\n    } else {\n      let endAngle = getAngleByPoint(coordinate, endPoint);\n      if (startAngle >= endAngle) {\n        // 100% pie slice\n        endAngle = endAngle + Math.PI * 2;\n      }\n      angle = startAngle + (endAngle - startAngle) / 2;\n    }\n    return angle;\n  }\n\n  /** @override */\n  protected getCirclePoint(angle: number, offset: number) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    const r = coordinate.getRadius() + offset;\n    return {\n      ...polarToCartesian(center.x, center.y, r, angle),\n      angle,\n      r,\n    };\n  }\n}\n","import { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { MappingDatum, Point } from '../../interface';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, PolarLabelItem, LabelPointCfg, Writeable } from './interface';\n\nconst HALF_PI = Math.PI / 2;\n\n/**\n * 极坐标下的图形 label\n */\nexport default class PolarLabel extends GeometryLabel {\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      let r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  }\n\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  public getLabelItems(mapppingArray: MappingDatum[]): PolarLabelItem[] {\n    const items = super.getLabelItems(mapppingArray);\n    const yScale = this.geometry.getYScale();\n\n    return map(items, (item) => {\n      if (item && yScale) {\n        const percent = yScale.scale(get(item.data, yScale.field));\n        return { ...item, percent };\n      }\n      return item;\n    });\n  }\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    let align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      const center = coordinate.getCenter();\n      const offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  }\n\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    let factor = 1;\n    let arcPoint;\n    const content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points as Point[]);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    const offset = labelCfg.offset * factor;\n    const middleAngle = this.getPointAngle(arcPoint);\n    const isLabelEmit = labelCfg.labelEmit;\n    const labelPositionCfg: Writeable<LabelPointCfg> = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate\n      ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n      : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y,\n    };\n    return labelPositionCfg;\n  }\n\n  /**\n   * 获取圆弧的位置\n   */\n  protected getArcPoint(mappingData: MappingDatum, index: number = 0): Point {\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y,\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n    };\n  }\n\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  protected getPointAngle(point: Point): number {\n    return getAngleByPoint(this.getCoordinate(), point);\n  }\n\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  protected getCirclePoint(angle: number, offset: number, point: Point, isLabelEmit: boolean) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    let r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return {\n        ...center,\n        r,\n      };\n    }\n\n    let labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      const appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r,\n    };\n  }\n\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  protected getLabelRotate(angle: number, offset: number, isLabelEmit: boolean) {\n    let rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  // 获取中心的位置\n  private getMiddlePoint(points: Point[]) {\n    const coordinate = this.getCoordinate();\n    const count = points.length;\n    let middlePoint = {\n      x: 0,\n      y: 0,\n    };\n    each(points, (point: Point) => {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }\n\n  // 是否居中\n  private isToMiddle(mappingData: MappingDatum) {\n    return (mappingData.x as number[]).length > 2;\n  }\n}\n","import { isFunction } from '@antv/util';\n\nclass MyWorker {\n  queue: any[] = [];\n  worker: Worker;\n\n  constructor(url) {\n    this.worker = new Worker(url);\n    this.worker.onmessage = (e: MessageEvent) => {\n      this.queue.shift()?.resolve(e);\n    };\n    this.worker.onmessageerror = (e: MessageEvent) => {\n      console.warn('[AntV G2] Web worker is not available');\n      this.queue.shift()?.reject(e);\n    };\n  }\n\n  post(params, onError?: () => any): Promise<MessageEvent> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ resolve, reject });\n      try {\n        this.worker.postMessage(params);\n      } catch (e) {\n        console.warn('[AntV G2] Web worker is not available');\n        isFunction(onError) && onError();\n      }\n    });\n  }\n\n  destroy() {\n    this.worker.terminate();\n  }\n}\n\nexport function createWorker(f: any) {\n  if (typeof window === 'undefined') return;\n\n  let blob;\n  try {\n    blob = new Blob([f.toString()], { type: 'application/javascript' });\n  } catch (e) {\n    // @ts-ignore\n    blob = new window.BlobBuilder();\n    blob.append(f.toString());\n    blob = blob.getBlob();\n  }\n\n  return new MyWorker(URL.createObjectURL(blob));\n}\n","/**\n * @file utils of label\n */\n\nimport { isNil, isNumber, some } from '@antv/util';\nimport { IElement, IGroup, BBox } from '../../../dependents';\nimport { rotate } from '../../../util/transform';\n\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label: IGroup): IElement {\n  return label.find((el) => el.get('type') === 'text');\n}\n\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(\n  labelGroup: IGroup,\n  labelItem: { rotate?: number;[key: string]: any },\n  padding: number | number[] = [0, 0, 0, 0]\n): { x: number; y: number; width: number; height: number; rotation: number } {\n  const content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    const labelShape = content.clone();\n\n    // revert rotate\n    if (labelItem?.rotate) {\n      rotate(labelShape as IGroup, -labelItem.rotate);\n    }\n\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    const { x, y, width, height } = labelShape.getCanvasBBox();\n\n    labelShape.destroy();\n\n    let boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: labelItem?.rotate || 0,\n    };\n  }\n\n  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur: IElement, dones: IElement[]) {\n  const box = cur.getBBox();\n  return some(dones, (done) => {\n    const target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}\n","import Path, { PathCfg } from './path';\n/** 引入 Path 对应的 ShapeFactory */\nimport './shape/line';\n\n/**\n * Line 几何标记。\n * 常用于折线图的绘制。\n */\nexport default class Line extends Path {\n  public type: string = 'line';\n\n  constructor(cfg: PathCfg) {\n    super(cfg);\n\n    const { sortable = false } = cfg; // 关闭默认的 X 轴数据排序\n    this.sortable = sortable;\n  }\n}\n","import { FIELD_ORIGIN } from '../constant';\nimport { MappingDatum, ShapeInfo } from '../interface';\nimport Geometry, { GeometryCfg } from './base';\nimport Element from './element';\n/** 引入对应的 ShapeFactory */\nimport './shape/line';\nimport { isModelChange } from './util/is-model-change';\nimport { diff } from './util/diff';\n\n/** Path 构造函数参数类型 */\nexport interface PathCfg extends GeometryCfg {\n  /** 是否连接空值 */\n  connectNulls?: boolean;\n  /** 单个孤立数据点是否展示 */\n  showSinglePoint?: boolean;\n}\n\n/**\n * Path 几何标记。\n * 用于绘制路径图等。\n */\nexport default class Path extends Geometry {\n  public readonly type: string = 'path';\n  public readonly shapeType: string = 'line';\n  /** 是否连接空值 */\n  public connectNulls: boolean;\n  /** 单个孤立数据点是否展示 */\n  public showSinglePoint: boolean;\n\n  constructor(cfg: PathCfg) {\n    super(cfg);\n\n    const { connectNulls = false, showSinglePoint = true } = cfg;\n    this.connectNulls = connectNulls;\n    this.showSinglePoint = showSinglePoint;\n  }\n\n  /**\n   * 创建所有的 Element 实例，对于 Path、Line、Area，一组数据对应一个 Element。\n   * @param mappingData\n   * @param [isUpdate]\n   * @returns elements\n   */\n  protected updateElements(mappingDataArray: MappingDatum[][], isUpdate: boolean = false) {\n    // Path 的每个 element 对应一组数据\n    const keyData = new Map<string, MappingDatum[]>();\n    const keyIndex = new Map<string, number>();\n    const keys: string[] = [];\n\n    let index = 0;\n    for (let i = 0; i < mappingDataArray.length; i++) {\n      const mappingData = mappingDataArray[i];\n      const key = this.getElementId(mappingData);\n      keys.push(key);\n      keyData.set(key, mappingData);\n      keyIndex.set(key, index);\n      index++;\n    }\n\n    this.elements = new Array(index);\n\n    const { added, updated, removed } = diff(this.lastElementsMap, keys);\n\n    for (const key of added) {\n      const mappingData = keyData.get(key);\n      const shapeFactory = this.getShapeFactory();\n      const shapeCfg = this.getShapeInfo(mappingData);\n      const i = keyIndex.get(key);\n      const element = new Element({\n        shapeFactory,\n        container: this.container,\n        offscreenGroup: this.getOffscreenGroup(),\n        elementIndex: i,\n      });\n      element.geometry = this;\n      element.animate = this.animateOption;\n      element.draw(shapeCfg, isUpdate); // 绘制 shape\n      this.elementsMap[key] = element;\n      this.elements[i] = element;\n    }\n\n    for (const key of updated) {\n      const mappingData = keyData.get(key);\n      const element = this.lastElementsMap[key];\n      const i = keyIndex.get(key);\n      const shapeCfg = this.getShapeInfo(mappingData);\n      const preShapeCfg = element.getModel();\n      if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {\n        element.animate = this.animateOption;\n        // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n        element.update(shapeCfg); // 更新对应的 element\n      }\n      this.elementsMap[key] = element;\n      this.elements[i] = element;\n    }\n\n    for (const key of removed) {\n      const element = this.lastElementsMap[key];\n      // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n      element.animate = this.animateOption;\n      element.destroy();\n    }\n  }\n\n  /**\n   * 获取组成一条线（一组数据）的所有点以及数据\n   * @param mappingData 映射后的数组\n   */\n  protected getPointsAndData(mappingData: MappingDatum[]) {\n    const points = [];\n    const data = [];\n\n    for (let i = 0, len = mappingData.length; i < len; i++) {\n      const obj = mappingData[i];\n      points.push({\n        x: obj.x,\n        y: obj.y,\n      });\n      data.push(obj[FIELD_ORIGIN]);\n    }\n\n    return {\n      points,\n      data,\n    };\n  }\n\n  private getShapeInfo(mappingData: MappingDatum[]): ShapeInfo {\n    const shapeCfg = this.getDrawCfg(mappingData[0]);\n    const { points, data } = this.getPointsAndData(mappingData);\n    shapeCfg.mappingData = mappingData;\n    shapeCfg.data = data;\n    shapeCfg.isStack = !!this.getAdjust('stack');\n    shapeCfg.points = points;\n    shapeCfg.connectNulls = this.connectNulls;\n    shapeCfg.showSinglePoint = this.showSinglePoint;\n\n    return shapeCfg;\n  }\n}\n"],"names":["antiCollision","items","labelHeight","plotRange","labels","filter","item","invisible","sort","a","b","y","i","overlapping","startY","minY","endY","maxY","totalHeight","Math","abs","Number","MIN_VALUE","boxes","map","label","content","size","targets","pos","forEach","box","target","min","apply","max","length","previousBox","concat","splice","posInCompositeBox","hasSome","dones","current","compare","some","done","checkShapeOverlap","left","right","margin","leftText","findLabelTextShape","rightText","getCanvasBBox","x","width","height","pointAdjustPosition","shapes","region","cfg","element","_a","get","geometry","type","getXYFields","xField","yField","groupedLabels","groupBy","offset","_b","keys","reverse","xValue","sortedCollections","result","sortedLabels","push","shift","pop","__spreadArray","sortLabels","textShape","set","downFail","attr","code","e","intersect","getAxes","points","vector","start","end","rotateAtPoint","point","deg","origin","cos","sin","getRectPoints","rotation","getProjection","axis","scalars","isProjectionOverlap","projection1","projection2","isValidBox","every","d","isNaN","Infinity","box1","box2","isIntersectRect","rect1Points","rect2Points","axes","generateUtils","methods","slice","visible","j","eventData","JSON","parse","data","self","postMessage","toString","_this","__extends","PieLabel","position","_super","getDefaultLabelCfg","call","deepMix","this","theme","getLabelOffset","angle","isLabelLimit","rotate","PI","align","center","getCoordinate","getCenter","coordinate","startPoint","isArray","endPoint","startAngle","getAngleByPoint","endAngle","r","getRadius","polarToCartesian","PolarLabel","HALF_PI","actualOffset","isNumber","isString","indexOf","innerRadius","parseFloat","mapppingArray","getLabelItems","yScale","getYScale","percent","scale","field","labelEmit","isTransposed","labelCfg","mappingData","index","arcPoint","factor","isToMiddle","getMiddlePoint","getArcPoint","middleAngle","getPointAngle","isLabelEmit","labelPositionCfg","getCirclePoint","color","autoRotate","getLabelRotate","getDistanceToCenter","labelAngle","asin","count","middlePoint","each","convert","GeometryLabel","url","queue","worker","Worker","onmessage","resolve","onmessageerror","console","warn","reject","MyWorker","params","onError","Promise","isFunction","terminate","createWorker","f","window","blob","Blob","BlobBuilder","append","getBlob","URL","createObjectURL","find","el","getLabelBackgroundInfo","labelGroup","labelItem","padding","getChildren","labelShape","clone","destroy","boxPadding","isNil","Array","fill","cur","getBBox","sortable","Path","connectNulls","showSinglePoint","mappingDataArray","isUpdate","keyData","Map","keyIndex","key","getElementId","elements","diff","lastElementsMap","added","updated","removed","added_1_1","shapeFactory","getShapeFactory","shapeCfg","getShapeInfo","Element","container","offscreenGroup","getOffscreenGroup","elementIndex","animate","animateOption","draw","elementsMap","updated_1_1","preShapeCfg","getModel","isCoordinateChanged","isModelChange","update","removed_1_1","len","obj","FIELD_ORIGIN","getDrawCfg","getPointsAndData","isStack","getAdjust","Geometry"],"sourceRoot":""}