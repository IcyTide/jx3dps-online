{"version":3,"file":"static/js/2357.6205bf2c.js","mappings":"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","sources":["../node_modules/@antv/scale/src/tick-method/register.ts","../node_modules/@antv/scale/src/base.ts","../node_modules/@antv/scale/src/category/base.ts","../node_modules/@antv/scale/src/util/time.ts","../node_modules/@antv/scale/src/util/bisector.ts","../node_modules/@antv/scale/src/category/time.ts","../node_modules/@antv/scale/src/continuous/base.ts","../node_modules/@antv/scale/src/continuous/linear.ts","../node_modules/@antv/scale/src/util/math.ts","../node_modules/@antv/scale/src/continuous/log.ts","../node_modules/@antv/scale/src/continuous/pow.ts","../node_modules/@antv/scale/src/continuous/time.ts","../node_modules/@antv/scale/src/continuous/quantize.ts","../node_modules/@antv/scale/src/continuous/quantile.ts","../node_modules/@antv/scale/src/factory.ts","../node_modules/@antv/scale/src/identity/index.ts","../node_modules/@antv/scale/src/tick-method/cat.ts","../node_modules/@antv/scale/src/util/d3-linear.ts","../node_modules/@antv/scale/src/util/interval.ts","../node_modules/@antv/scale/src/util/strict-limit.ts","../node_modules/@antv/scale/src/util/pretty-number.ts","../node_modules/@antv/scale/src/util/extended.ts","../node_modules/@antv/scale/src/util/pretty.ts","../node_modules/@antv/scale/src/tick-method/quantile.ts","../node_modules/@antv/scale/src/tick-method/time-pretty.ts","../node_modules/@antv/scale/src/tick-method/index.ts","../node_modules/@antv/scale/src/tick-method/time-cat.ts","../node_modules/@antv/scale/src/tick-method/linear.ts","../node_modules/@antv/scale/src/tick-method/r-prettry.ts","../node_modules/@antv/scale/src/tick-method/time.ts","../node_modules/@antv/scale/src/tick-method/log.ts","../node_modules/@antv/scale/src/tick-method/pow.ts","../node_modules/@antv/scale/src/tick-method/d3-linear.ts","../node_modules/@antv/scale/src/index.ts"],"sourcesContent":["import { TickMethod } from '../types';\ninterface MethodMap {\n  [key: string]: TickMethod;\n}\nconst methodCache: MethodMap = {};\n\n/**\n * 获取计算 ticks 的方法\n * @param key 键值\n * @returns 计算 ticks 的方法\n */\nexport function getTickMethod(key: string): TickMethod {\n  return methodCache[key];\n}\n\n/**\n * 注册计算 ticks 的方法\n * @param key 键值\n * @param method 方法\n */\nexport function registerTickMethod(key: string, method: TickMethod) {\n  methodCache[key] = method;\n}\n","import { assign, isEmpty, isFunction, isNil, isNumber, isObject, isString, map } from '@antv/util';\nimport { getTickMethod } from './tick-method/register';\nimport { ScaleConfig, Tick } from './types';\nexport default abstract class Scale {\n  /**\n   * 度量的类型\n   */\n  public type: string = 'base';\n  /**\n   * 是否分类类型的度量\n   */\n  public isCategory?: boolean = false;\n  /**\n   * 是否线性度量，有linear, time 度量\n   */\n  public isLinear?: boolean = false;\n  /**\n   * 是否连续类型的度量，linear,time,log, pow, quantile, quantize 都支持\n   */\n  public isContinuous?: boolean = false;\n  /**\n   * 是否是常量的度量，传入和传出一致\n   */\n  public isIdentity: boolean = false;\n\n  public field?: ScaleConfig['field'];\n  public alias?: ScaleConfig['alias'];\n  public values: ScaleConfig['values'] = [];\n  public min?: ScaleConfig['min'];\n  public max?: ScaleConfig['max'];\n  public minLimit?: ScaleConfig['minLimit'];\n  public maxLimit?: ScaleConfig['maxLimit'];\n  public range: ScaleConfig['range'] = [0, 1];\n  public ticks: ScaleConfig['ticks'] = [];\n  public tickCount: ScaleConfig['tickCount'];\n  public tickInterval: ScaleConfig['tickInterval'];\n  public formatter?: ScaleConfig['formatter'];\n  public tickMethod?: ScaleConfig['tickMethod'];\n  protected __cfg__: ScaleConfig; // 缓存的旧配置, 用于 clone\n\n  constructor(cfg: ScaleConfig) {\n    this.__cfg__ = cfg;\n    this.initCfg();\n    this.init();\n  }\n\n  // 对于原始值的必要转换，如分类、时间字段需转换成数值，用transform/map命名可能更好\n  public translate(v: any) {\n    return v;\n  }\n\n  /** 将定义域转换为值域 */\n  public abstract scale(value: any): number;\n\n  /** 将值域转换为定义域 */\n  public abstract invert(scaled: number): any;\n\n  /** 重新初始化 */\n  public change(cfg: ScaleConfig) {\n    // 覆盖配置项，而不替代\n    assign(this.__cfg__, cfg);\n    this.init();\n  }\n\n  public clone(): Scale {\n    return this.constructor(this.__cfg__);\n  }\n\n  /** 获取坐标轴需要的ticks */\n  public getTicks(): Tick[] {\n    return map(this.ticks, (tick: any, idx: number) => {\n      if (isObject(tick)) {\n        // 仅当符合Tick类型时才有意义\n        return tick as Tick;\n      }\n      return {\n        text: this.getText(tick, idx),\n        tickValue: tick, // 原始value\n        value: this.scale(tick), // scaled\n      };\n    });\n  }\n\n  /** 获取Tick的格式化结果 */\n  public getText(value: any, key?: number): string {\n    const formatter = this.formatter;\n    const res = formatter ? formatter(value, key) : value;\n    if (isNil(res) || !isFunction(res.toString)) {\n      return '';\n    }\n    return res.toString();\n  }\n\n  // 获取配置项中的值，当前 scale 上的值可能会被修改\n  protected getConfig(key) {\n    return this.__cfg__[key];\n  }\n\n  // scale初始化\n  protected init(): void {\n    assign(this, this.__cfg__);\n    this.setDomain();\n    if (isEmpty(this.getConfig('ticks'))) {\n      this.ticks = this.calculateTicks();\n    }\n  }\n\n  // 子类上覆盖某些属性，不能直接在类上声明，否则会被覆盖\n  protected initCfg() {}\n\n  protected setDomain(): void {}\n\n  protected calculateTicks(): any[] {\n    const tickMethod = this.tickMethod;\n    let ticks = [];\n    if (isString(tickMethod)) {\n      const method = getTickMethod(tickMethod);\n      if (!method) {\n        throw new Error('There is no method to to calculate ticks!');\n      }\n      ticks = method(this);\n    } else if (isFunction(tickMethod)) {\n      ticks = tickMethod(this);\n    }\n    return ticks;\n  }\n\n  // range 的最小值\n  protected rangeMin() {\n    return this.range[0];\n  }\n\n  // range 的最大值\n  protected rangeMax() {\n    return this.range[1];\n  }\n\n  /** 定义域转 0~1 */\n  protected calcPercent(value: any, min: number, max: number): number {\n    if (isNumber(value)) {\n      return (value - min) / (max - min);\n    }\n    return NaN;\n  }\n\n  /** 0~1转定义域 */\n  protected calcValue(percent: number, min: number, max: number): number {\n    return min + percent * (max - min);\n  }\n}\n","import { indexOf, isNil, isNumber } from '@antv/util';\nimport Base from '../base';\n\n/**\n * 分类度量\n * @class\n */\nclass Category extends Base {\n  public readonly type: string = 'cat';\n  public readonly isCategory: boolean = true;\n\n  // 用于缓存 translate 函数\n  private translateIndexMap;\n\n  private buildIndexMap() {\n    if (!this.translateIndexMap) {\n      this.translateIndexMap = new Map();\n      // 重新构建缓存\n      for (let i = 0; i < this.values.length; i ++) {\n        this.translateIndexMap.set(this.values[i], i);\n      }\n    }\n  }\n\n  public translate(value: any): number {\n    // 按需构建 map\n    this.buildIndexMap();\n    // 找得到\n    let idx = this.translateIndexMap.get(value);\n    \n    if (idx === undefined) {\n      idx = isNumber(value) ? value : NaN;\n    }\n    return idx;\n  }\n\n  public scale(value: any): number {\n    const order = this.translate(value);\n    // 分类数据允许 0.5 范围内调整\n    // if (order < this.min - 0.5 || order > this.max + 0.5) {\n    //   return NaN;\n    // }\n    const percent = this.calcPercent(order, this.min, this.max);\n    return this.calcValue(percent, this.rangeMin(), this.rangeMax());\n  }\n\n  public invert(scaledValue: number) {\n    const domainRange = this.max - this.min;\n    const percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());\n    const idx = Math.round(domainRange * percent) + this.min;\n    if (idx < this.min || idx > this.max) {\n      return NaN;\n    }\n    return this.values[idx];\n  }\n\n  public getText(value: any, ...args: any[]): string {\n    let v = value;\n    // value为index\n    if (isNumber(value) && !this.values.includes(value)) {\n      v = this.values[v];\n    }\n    return super.getText(v, ...args);\n  }\n  // 复写属性\n  protected initCfg() {\n    this.tickMethod = 'cat';\n  }\n  // 设置 min, max\n  protected setDomain() {\n    // 用户有可能设置 min\n    if (isNil(this.getConfig('min'))) {\n      this.min = 0;\n    }\n    if (isNil(this.getConfig('max'))) {\n      const size = this.values.length;\n      this.max = size > 1 ? size - 1 : size;\n    }\n\n    // scale.init 的时候清除缓存\n    if (this.translateIndexMap) {\n      this.translateIndexMap = undefined;\n    }\n  }\n}\n\nexport default Category;\n","import { isDate, isString, last } from '@antv/util';\nimport fecha from 'fecha';\nimport * as fecha1 from 'fecha';\n\nimport bisector from './bisector';\nconst FORMAT_METHOD = 'format';\n\nexport function timeFormat(time, mask) { // 由于 fecha 包的 typescript 定义有问题，所以暂时兼容一下\n  const method = fecha1[FORMAT_METHOD] || fecha[FORMAT_METHOD];\n  return method(time, mask);\n}\n/**\n * 转换成时间戳\n * @param value 时间值\n */\nexport function toTimeStamp(value: any): number {\n  if (isString(value)) {\n    if (value.indexOf('T') > 0) {\n      value = new Date(value).getTime();\n    } else {\n      // new Date('2010/01/10') 和 new Date('2010-01-10') 的差别在于:\n      // 如果仅有年月日时，前者是带有时区的: Fri Jan 10 2020 02:40:13 GMT+0800 (中国标准时间)\n      // 后者会格式化成 Sun Jan 10 2010 08:00:00 GMT+0800 (中国标准时间)\n      value = new Date(value.replace(/-/gi, '/')).getTime();\n    }\n  }\n  if (isDate(value)) {\n    value = value.getTime();\n  }\n  return value;\n}\n\nconst SECOND = 1000;\nconst MINUTE = 60 * SECOND;\nconst HOUR = 60 * MINUTE;\nconst DAY = 24 * HOUR;\nconst MONTH = DAY * 31;\nconst YEAR = DAY * 365;\n\nexport { SECOND, MINUTE, HOUR, DAY, MONTH, YEAR };\ntype Interval = [string, number]; // [defaultMomentFormat, interval]\nconst intervals: Interval[] = [\n  ['HH:mm:ss', SECOND],\n  ['HH:mm:ss', SECOND * 10],\n  ['HH:mm:ss', SECOND * 30],\n  ['HH:mm', MINUTE],\n  ['HH:mm', MINUTE * 10],\n  ['HH:mm', MINUTE * 30],\n  ['HH', HOUR],\n  ['HH', HOUR * 6],\n  ['HH', HOUR * 12],\n  ['YYYY-MM-DD', DAY],\n  ['YYYY-MM-DD', DAY * 4],\n  ['YYYY-WW', DAY * 7],\n  ['YYYY-MM', MONTH],\n  ['YYYY-MM', MONTH * 4],\n  ['YYYY-MM', MONTH * 6],\n  ['YYYY', DAY * 380], // 借鉴echarts，保证每个周期累加时不会碰到恰巧不够的问题\n];\n\nexport function getTickInterval(min: number, max: number, tickCount: number): Interval {\n  const target = (max - min) / tickCount;\n  const idx = bisector((o: Interval) => o[1])(intervals, target) - 1;\n  let interval: Interval = intervals[idx];\n  if (idx < 0) {\n    interval = intervals[0];\n  } else if (idx >= intervals.length) {\n    interval = last(intervals);\n  }\n  return interval;\n}\n","import { isNil } from '@antv/util';\n\ntype GetterFunc<T> = (o: T) => number;\n\n/**\n * 二分右侧查找\n * https://github.com/d3/d3-array/blob/master/src/bisector.js\n */\nexport default function<T>(getter: GetterFunc<T>) {\n  /**\n   * x: 目标值\n   * lo: 起始位置\n   * hi: 结束位置\n   */\n  return function(a: T[], x: number, _lo?: number, _hi?: number) {\n    let lo = isNil(_lo) ? 0 : _lo;\n    let hi = isNil(_hi) ? a.length : _hi;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (getter(a[mid]) > x) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return lo;\n  };\n}\n","import { each, isNumber } from '@antv/util';\nimport { timeFormat, toTimeStamp } from '../util/time';\nimport Category from './base';\n\n/**\n * 时间分类度量\n * @class\n */\nclass TimeCat extends Category {\n  public readonly type: string = 'timeCat';\n  public mask;\n  /**\n   * @override\n   */\n  public translate(value) {\n    value = toTimeStamp(value);\n    let index = this.values.indexOf(value);\n    if (index === -1) {\n      if (isNumber(value) && value < this.values.length) {\n        index = value;\n      } else {\n        index = NaN;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * 由于时间类型数据需要转换一下，所以复写 getText\n   * @override\n   */\n  public getText(value: string | number, tickIndex?: number) {\n    const index = this.translate(value);\n    if (index > -1) {\n      let result = this.values[index];\n      const formatter = this.formatter;\n      result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);\n      return result;\n    }\n    return value;\n  }\n  protected initCfg() {\n    this.tickMethod = 'time-cat';\n    this.mask = 'YYYY-MM-DD';\n    this.tickCount = 7; // 一般时间数据会显示 7， 14， 30 天的数字\n  }\n\n  protected setDomain() {\n    const values = this.values;\n    // 针对时间分类类型，会将时间统一转换为时间戳\n    each(values, (v, i) => {\n      values[i] = toTimeStamp(v);\n    });\n    values.sort((v1, v2) => {\n      return v1 - v2;\n    });\n    super.setDomain();\n  }\n}\n\nexport default TimeCat;\n","import { filter, getRange, head, isNil, last } from '@antv/util';\nimport Base from '../base';\n\n/**\n * 连续度量的基类\n * @class\n */\nexport default abstract class Continuous extends Base {\n  public isContinuous?: boolean = true;\n  public nice: boolean;\n\n  public scale(value: any): number {\n    if (isNil(value)) {\n      return NaN;\n    }\n    const rangeMin = this.rangeMin();\n    const rangeMax = this.rangeMax();\n    const max = this.max;\n    const min = this.min;\n    if (max === min) {\n      return rangeMin;\n    }\n    const percent = this.getScalePercent(value);\n    return rangeMin + percent * (rangeMax - rangeMin);\n  }\n\n  protected init() {\n    super.init();\n    // init 完成后保证 min, max 包含 ticks 的范围\n    const ticks = this.ticks;\n    const firstTick = head(ticks);\n    const lastTick = last(ticks);\n    if (firstTick < this.min) {\n      this.min = firstTick;\n    }\n    if (lastTick > this.max) {\n      this.max = lastTick;\n    }\n    // strict-limit 方式\n    if (!isNil(this.minLimit)) {\n      this.min = firstTick;\n    }\n    if (!isNil(this.maxLimit)) {\n      this.max = lastTick;\n    }\n  }\n\n  protected setDomain() {\n    const { min, max } = getRange(this.values);\n    if (isNil(this.min)) {\n      this.min = min;\n    }\n    if (isNil(this.max)) {\n      this.max = max;\n    }\n    if (this.min > this.max) {\n      this.min = min;\n      this.max = max;\n    }\n  }\n\n  protected calculateTicks(): any[] {\n    let ticks = super.calculateTicks();\n    if (!this.nice) {\n      ticks = filter(ticks, (tick) => {\n        return tick >= this.min && tick <= this.max;\n      });\n    }\n    return ticks;\n  }\n\n  // 计算原始值值占的百分比\n  protected getScalePercent(value) {\n    const max = this.max;\n    const min = this.min;\n    return (value - min) / (max - min);\n  }\n\n  protected getInvertPercent(value) {\n    return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());\n  }\n}\n","import Continuous from './base';\n\n/**\n * 线性度量\n * @class\n */\nexport default class Linear extends Continuous {\n  public minTickInterval: number;\n  public type = 'linear';\n  public readonly isLinear: boolean = true;\n\n  public invert(value: number): any {\n    const percent = this.getInvertPercent(value);\n    return this.min + percent * (this.max - this.min);\n  }\n\n  protected initCfg() {\n    this.tickMethod = 'wilkinson-extended';\n    this.nice = false;\n  }\n}\n","import { each, isNil } from '@antv/util';\n\n// 求以a为次幂，结果为b的基数，如 x^^a = b;求x\n// 虽然数学上 b 不支持负数，但是这里需要支持 负数\nexport function calBase(a: number, b: number) {\n  const e = Math.E;\n  let value;\n  if (b >= 0) {\n    value = Math.pow(e, Math.log(b) / a); // 使用换底公式求底\n  } else {\n    value = Math.pow(e, Math.log(-b) / a) * -1; // 使用换底公式求底\n  }\n  return value;\n}\n\nexport function log(a: number, b: number) {\n  if (a === 1) {\n    return 1;\n  }\n  return Math.log(b) / Math.log(a);\n}\n\nexport function getLogPositiveMin(values, base, max?: number) {\n  if (isNil(max)) {\n    max = Math.max.apply(null, values);\n  }\n  let positiveMin = max;\n  each(values, (value) => {\n    if (value > 0 && value < positiveMin) {\n      positiveMin = value;\n    }\n  });\n  if (positiveMin === max) {\n    positiveMin = max / base;\n  }\n  if (positiveMin > 1) {\n    positiveMin = 1;\n  }\n  return positiveMin;\n}\n\nfunction digitLength(num: number) {\n  // Get digit length of e\n  const eSplit = num.toString().split(/[eE]/);\n  const len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);\n  return len > 0 ? len : 0;\n}\n\n/**\n * 高精度加法，解决 0.1 + 0.2 !== 0.3 的经典问题\n *\n * @param num1 加数\n * @param num2 被加数\n * @return {number} 返回值\n */\nexport function precisionAdd(num1: number, num2: number) {\n  const num1Digits = digitLength(num1);\n  const num2Digits = digitLength(num2);\n  const baseNum = 10 ** Math.max(num1Digits, num2Digits);\n  return (num1 * baseNum + num2 * baseNum) / baseNum;\n}\n","import { getLogPositiveMin, log } from '../util/math';\nimport Continuous from './base';\n/**\n * Log 度量，处理非均匀分布\n */\nclass Log extends Continuous {\n  public readonly type: string = 'log';\n  public base: number;\n  // 用于解决 min: 0 的场景下的问题\n  private positiveMin: number;\n\n  /**\n   * @override\n   */\n  public invert(value: number) {\n    const base = this.base;\n    const max = log(base, this.max);\n    const rangeMin = this.rangeMin();\n    const range = this.rangeMax() - rangeMin;\n    let min;\n    const positiveMin = this.positiveMin;\n    if (positiveMin) {\n      if (value === 0) {\n        return 0;\n      }\n      min = log(base, positiveMin / base);\n      const appendPercent = (1 / (max - min)) * range; // 0 到 positiveMin的占比\n      if (value < appendPercent) {\n        // 落到 0 - positiveMin 之间\n        return (value / appendPercent) * positiveMin;\n      }\n    } else {\n      min = log(base, this.min);\n    }\n    const percent = (value - rangeMin) / range;\n    const tmp = percent * (max - min) + min;\n    return Math.pow(base, tmp);\n  }\n\n  protected initCfg() {\n    this.tickMethod = 'log';\n    this.base = 10;\n    this.tickCount = 6;\n    this.nice = true;\n  }\n\n  // 设置\n  protected setDomain() {\n    super.setDomain();\n    const min = this.min;\n    if (min < 0) {\n      throw new Error('When you use log scale, the minimum value must be greater than zero!');\n    }\n    if (min === 0) {\n      this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);\n    }\n  }\n\n  // 根据当前值获取占比\n  protected getScalePercent(value: number) {\n    const max = this.max;\n    let min = this.min;\n    if (max === min) {\n      return 0;\n    }\n    // 如果值小于等于0，则按照0处理\n    if (value <= 0) {\n      return 0;\n    }\n    const base = this.base;\n    const positiveMin = this.positiveMin;\n    // 如果min == 0, 则根据比0大的最小值，计算比例关系。这个最小值作为坐标轴上的第二个tick，第一个是0但是不显示\n    if (positiveMin) {\n      min = (positiveMin * 1) / base;\n    }\n    let percent;\n    // 如果数值小于次小值，那么就计算 value / 次小值 占整体的比例\n    if (value < positiveMin) {\n      percent = value / positiveMin / (log(base, max) - log(base, min));\n    } else {\n      percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));\n    }\n    return percent;\n  }\n}\n\nexport default Log;\n","import { calBase } from '../util/math';\nimport Continuous from './base';\n\n/**\n * Pow 度量，处理非均匀分布\n */\nclass Pow extends Continuous {\n  public readonly type: string = 'pow';\n  /**\n   * 指数\n   */\n  public exponent: number;\n\n  /**\n   * @override\n   */\n  public invert(value: number) {\n    const percent = this.getInvertPercent(value);\n    const exponent = this.exponent;\n    const max = calBase(exponent, this.max);\n    const min = calBase(exponent, this.min);\n    const tmp = percent * (max - min) + min;\n    const factor = tmp >= 0 ? 1 : -1;\n    return Math.pow(tmp, exponent) * factor;\n  }\n\n  protected initCfg() {\n    this.tickMethod = 'pow';\n    this.exponent = 2;\n    this.tickCount = 5;\n    this.nice = true;\n  }\n\n  // 获取度量计算时，value占的定义域百分比\n  protected getScalePercent(value: number) {\n    const max = this.max;\n    const min = this.min;\n    if (max === min) {\n      return 0;\n    }\n    const exponent = this.exponent;\n    const percent =\n      (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));\n    return percent;\n  }\n}\n\nexport default Pow;\n","import { each, isDate, isNil, isNumber, isString } from '@antv/util';\nimport { timeFormat, toTimeStamp } from '../util/time';\nimport Linear from './linear';\n\n/**\n * 时间度量\n * @class\n */\nclass Time extends Linear {\n  public readonly type: string = 'time';\n  public mask: string;\n\n  /**\n   * @override\n   */\n  public getText(value: string | number | Date, index?: number) {\n    const numberValue = this.translate(value);\n    const formatter = this.formatter;\n    return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);\n  }\n  /**\n   * @override\n   */\n  public scale(value): number {\n    let v = value;\n    if (isString(v) || isDate(v)) {\n      v = this.translate(v);\n    }\n    return super.scale(v);\n  }\n  /**\n   * 将时间转换成数字\n   * @override\n   */\n  public translate(v): number {\n    return toTimeStamp(v);\n  }\n  protected initCfg() {\n    this.tickMethod = 'time-pretty';\n    this.mask = 'YYYY-MM-DD';\n    this.tickCount = 7;\n    this.nice = false;\n  }\n\n  protected setDomain() {\n    const values = this.values;\n    // 是否设置了 min, max，而不是直接取 this.min, this.max\n    const minConfig = this.getConfig('min');\n    const maxConfig = this.getConfig('max');\n    // 如果设置了 min,max 则转换成时间戳\n    if (!isNil(minConfig) || !isNumber(minConfig)) {\n      this.min = this.translate(this.min);\n    }\n    if (!isNil(maxConfig) || !isNumber(maxConfig)) {\n      this.max = this.translate(this.max);\n    }\n    // 没有设置 min, max 时\n    if (values && values.length) {\n      // 重新计算最大最小值\n      const timeStamps = [];\n      let min = Infinity; // 最小值\n      let secondMin = min; // 次小值\n      let max = 0;\n      // 使用一个循环，计算min,max,secondMin\n      each(values, (v) => {\n        const timeStamp = toTimeStamp(v);\n        if (isNaN(timeStamp)) {\n          throw new TypeError(`Invalid Time: ${v} in time scale!`);\n        }\n        if (min > timeStamp) {\n          secondMin = min;\n          min = timeStamp;\n        } else if (secondMin > timeStamp) {\n          secondMin = timeStamp;\n        }\n        if (max < timeStamp) {\n          max = timeStamp;\n        }\n        timeStamps.push(timeStamp);\n      });\n      // 存在多个值时，设置最小间距\n      if (values.length > 1) {\n        this.minTickInterval = secondMin - min;\n      }\n      if (isNil(minConfig)) {\n        this.min = min;\n      }\n      if (isNil(maxConfig)) {\n        this.max = max;\n      }\n    }\n  }\n}\nexport default Time;\n","import { each, head, last } from '@antv/util';\nimport Continuous from './base';\n\n/**\n * 分段度量\n */\nclass Quantize extends Continuous {\n  public type = 'quantize';\n\n  public invert(value): number {\n    const ticks = this.ticks;\n    const length = ticks.length;\n    const percent = this.getInvertPercent(value);\n    const minIndex = Math.floor(percent * (length - 1));\n    // 最后一个\n    if (minIndex >= length - 1) {\n      return last(ticks);\n    }\n    // 超出左边界， 则取第一个\n    if (minIndex < 0) {\n      return head(ticks);\n    }\n    const minTick = ticks[minIndex];\n    const nextTick = ticks[minIndex + 1];\n    // 比当前值小的 tick 在度量上的占比\n    const minIndexPercent = minIndex / (length - 1);\n    const maxIndexPercent =  (minIndex + 1) / (length - 1);\n    return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);\n  }\n\n  protected initCfg() {\n    this.tickMethod = 'r-pretty';\n    this.tickCount = 5;\n    this.nice = true;\n  }\n\n  protected calculateTicks(): any[] {\n    const ticks = super.calculateTicks();\n    if (!this.nice) { // 如果 nice = false ,补充 min, max\n      if (last(ticks) !== this.max) {\n        ticks.push(this.max);\n      }\n      if (head(ticks) !== this.min) {\n        ticks.unshift(this.min);\n      }\n    }\n    return ticks;\n  }\n\n  // 计算当前值在刻度中的占比\n  protected getScalePercent(value) {\n    const ticks = this.ticks;\n    // 超出左边界\n    if (value < head(ticks)) {\n      return 0;\n    }\n    // 超出右边界\n    if (value > last(ticks)) {\n      return 1;\n    }\n    let minIndex = 0;\n    each(ticks, (tick, index) => {\n      if (value >= tick) {\n        minIndex = index;\n      } else {\n        return false;\n      }\n    });\n    return minIndex / (ticks.length - 1);\n  }\n}\n\nexport default Quantize;\n","import Quantize from './quantize';\n\nclass Quantile extends Quantize {\n  public type = 'quantile';\n  protected initCfg() {\n    this.tickMethod = 'quantile';\n    this.tickCount = 5;\n    this.nice = true;\n  }\n}\n\nexport default Quantile;\n","import Scale from './base';\nimport { ScaleConfig } from './types';\ntype ScaleConstructor<T extends Scale = Scale> = new (cfg: ScaleConfig) => T;\n\ninterface ScaleMap {\n  [key: string]: ScaleConstructor;\n}\n\nconst map: ScaleMap = {};\n\nfunction getClass(key: string): ScaleConstructor {\n  return map[key];\n}\n\nfunction registerClass(key: string, cls: ScaleConstructor) {\n  if (getClass(key)) {\n    throw new Error(`type '${key}' existed.`);\n  }\n  map[key] = cls;\n}\n\nexport { Scale, getClass as getScale, registerClass as registerScale };\n","import { has, isNumber } from '@antv/util';\nimport Base from '../base';\nimport { ScaleType } from '../types';\n\n/**\n * identity scale原则上是定义域和值域一致，scale/invert方法也是一致的\n * 参考R的实现：https://github.com/r-lib/scales/blob/master/R/pal-identity.r\n * 参考d3的实现（做了下转型）：https://github.com/d3/d3-scale/blob/master/src/identity.js\n */\nexport default class Identity extends Base {\n  public readonly type: ScaleType = 'identity';\n  public readonly isIdentity: boolean = true;\n\n  public calculateTicks() {\n    return this.values;\n  }\n\n  public scale(value: any): number {\n    // 如果传入的值不等于 identity 的值，则直接返回，用于一维图时的 dodge\n    if (this.values[0] !== value && isNumber(value)) {\n      return value;\n    }\n    return this.range[0];\n  }\n\n  public invert(value?: number): number {\n    const range = this.range;\n    if (value < range[0] || value > range[1]) {\n      return NaN;\n    }\n    return this.values[0];\n  }\n}\n","import { filter, isNil, isNumber, last } from '@antv/util';\nimport { ScaleConfig } from '../types';\n\n/**\n * 计算分类 ticks\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function calculateCatTicks(cfg: ScaleConfig): any[] {\n  const { values, tickInterval, tickCount, showLast } = cfg;\n\n  if (isNumber(tickInterval)) {\n    const ticks = filter(values, (__: any, i: number) => i % tickInterval === 0);\n    const lastValue = last(values);\n    if (showLast && last(ticks) !== lastValue) {\n      ticks.push(lastValue);\n    }\n    return ticks;\n  }\n\n  const len = values.length;\n  let { min, max } = cfg;\n  if (isNil(min)) {\n    min = 0;\n  }\n  if (isNil(max)) {\n    max = values.length - 1;\n  }\n\n  if (!isNumber(tickCount) || tickCount >= len) return values.slice(min, max + 1);\n  if (tickCount <= 0 || max <= 0) return [];\n\n  const interval = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));\n  const ticks = [];\n\n  let idx = min;\n  for (let i = 0; i < tickCount; i++) {\n    if (idx >= max) break;\n\n    idx = Math.min(min + i * interval, max);\n    if (i === tickCount - 1 && showLast) ticks.push(values[max]);\n    else ticks.push(values[idx]);\n  }\n  return ticks;\n}\n","import { ScaleConfig } from '../types';\n\nexport default function d3Linear(cfg: ScaleConfig): number[] {\n  const { min, max, nice, tickCount } = cfg;\n  const linear = new D3Linear();\n  linear.domain([min, max]);\n  if (nice) {\n    linear.nice(tickCount);\n  }\n  return linear.ticks(tickCount);\n}\n\nconst DEFAULT_COUNT = 5;\nconst e10 = Math.sqrt(50);\nconst e5 = Math.sqrt(10);\nconst e2 = Math.sqrt(2);\n\n// https://github.com/d3/d3-scale\nexport class D3Linear {\n  private _domain: number[] = [0, 1];\n\n  public domain(domain?: number[]): D3Linear | number[] {\n    if (domain) {\n      this._domain = Array.from(domain, Number);\n      return this;\n    }\n    return this._domain.slice();\n  }\n\n  public nice(count = DEFAULT_COUNT) {\n    const d = this._domain.slice();\n    let i0 = 0;\n    let i1 = this._domain.length - 1;\n    let start = this._domain[i0];\n    let stop = this._domain[i1];\n    let step;\n\n    if (stop < start) {\n      [start, stop] = [stop, start];\n      [i0, i1] = [i1, i0];\n    }\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      this.domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      this.domain(d);\n    }\n\n    return this;\n  }\n\n  public ticks(count = DEFAULT_COUNT): number[] {\n    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);\n  }\n}\n\nfunction d3ArrayTicks(start: number, stop: number, count: number): number[] {\n  let reverse;\n  let i = -1;\n  let n;\n  let ticks;\n  let step;\n\n  (stop = +stop), (start = +start), (count = +count);\n  if (start === stop && count > 0) {\n    return [start];\n  }\n  // tslint:disable-next-line\n  if ((reverse = stop < start)) {\n    (n = start), (start = stop), (stop = n);\n  }\n  // tslint:disable-next-line\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {\n    return [];\n  }\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array((n = Math.ceil(stop - start + 1)));\n    while (++i < n) {\n      ticks[i] = (start + i) * step;\n    }\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array((n = Math.ceil(start - stop + 1)));\n    while (++i < n) {\n      ticks[i] = (start - i) / step;\n    }\n  }\n\n  if (reverse) {\n    ticks.reverse();\n  }\n\n  return ticks;\n}\n\nfunction tickIncrement(start: number, stop: number, count: number): number {\n  const step = (stop - start) / Math.max(0, count);\n  const power = Math.floor(Math.log(step) / Math.LN10);\n  const error = step / Math.pow(10, power);\n\n  return power >= 0\n    ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n    : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n","\nimport { fixedBase } from '@antv/util';\n\nfunction snapMultiple(v, base, snapType) {\n  let div;\n  if (snapType === 'ceil') {\n    div = Math.ceil(v / base);\n  } else if (snapType === 'floor') {\n    div = Math.floor(v / base);\n  } else {\n    div = Math.round(v / base);\n  }\n  return div * base;\n}\n\nexport default function intervalTicks(min, max, interval) {\n  // 变成 interval 的倍数\n  let minTick = snapMultiple(min, interval, 'floor');\n  let maxTick = snapMultiple(max, interval, 'ceil');\n  // 统一小数位数\n  minTick = fixedBase(minTick, interval);\n  maxTick = fixedBase(maxTick, interval);\n  const ticks = [];\n  // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n  const availableInterval = Math.max((maxTick - minTick) / (2 ** 12 - 1), interval);\n  for (let i = minTick; i <= maxTick; i = i + availableInterval) {\n    const tickValue = fixedBase(i, availableInterval); // 防止浮点数加法出现问题\n    ticks.push(tickValue);\n  }\n  return {\n    min: minTick,\n    max: maxTick,\n    ticks\n  };\n}","import { isNil } from '@antv/util';\nimport { ScaleConfig } from '../types';\n\n/**\n * 按照给定的 minLimit/maxLimit/tickCount 均匀计算出刻度 ticks\n *\n * @param cfg Scale 配置项\n * @return ticks\n */\nexport default function strictLimit(cfg: ScaleConfig, defaultMin?: number, defaultMax?: number): number[] {\n  const { minLimit, maxLimit, min, max, tickCount = 5 } = cfg;\n  let tickMin = isNil(minLimit) ? (isNil(defaultMin) ? min : defaultMin) : minLimit;\n  let tickMax = isNil(maxLimit) ? (isNil(defaultMax) ? max : defaultMax) : maxLimit;\n\n  if (tickMin > tickMax) {\n    [tickMax, tickMin] = [tickMin, tickMax];\n  }\n\n  if (tickCount <= 2) {\n    return [tickMin, tickMax];\n  }\n\n  const step = (tickMax - tickMin) / (tickCount - 1);\n  const ticks: number[] = [];\n\n  for (let i = 0; i < tickCount; i++) {\n    ticks.push(tickMin + step * i);\n  }\n\n  return ticks;\n}\n","// 为了解决 js 运算的精度问题\nexport function prettyNumber(n: number) {\n  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));\n}\n","import { head, indexOf, size, last } from '@antv/util';\nimport { prettyNumber } from './pretty-number';\n\nexport const DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];\n\nexport const ALL_Q = [1, 5, 2, 2.5, 4, 3, 1.5, 7, 6, 8, 9];\n\nconst eps = Number.EPSILON * 100;\n\nfunction mod(n: number, m: number) {\n  return ((n % m) + m) % m;\n}\n\nfunction round(n: number) {\n  return Math.round(n * 1e12) / 1e12;\n}\n\nfunction simplicity(q: number, Q: number[], j: number, lmin: number, lmax: number, lstep: number) {\n  const n = size(Q);\n  const i = indexOf(Q, q);\n  let v = 0;\n  const m = mod(lmin, lstep);\n  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {\n    v = 1;\n  }\n  return 1 - i / (n - 1) - j + v;\n}\n\nfunction simplicityMax(q: number, Q: number[], j: number) {\n  const n = size(Q);\n  const i = indexOf(Q, q);\n  const v = 1;\n  return 1 - i / (n - 1) - j + v;\n}\n\nfunction density(k: number, m: number, dMin: number, dMax: number, lMin: number, lMax: number) {\n  const r = (k - 1) / (lMax - lMin);\n  const rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));\n  return 2 - Math.max(r / rt, rt / r);\n}\n\nfunction densityMax(k: number, m: number) {\n  if (k >= m) {\n    return 2 - (k - 1) / (m - 1);\n  }\n  return 1;\n}\n\nfunction coverage(dMin: number, dMax: number, lMin: number, lMax: number) {\n  const range = dMax - dMin;\n  return 1 - (0.5 * ((dMax - lMax) ** 2 + (dMin - lMin) ** 2)) / (0.1 * range) ** 2;\n}\n\nfunction coverageMax(dMin: number, dMax: number, span: number) {\n  const range = dMax - dMin;\n  if (span > range) {\n    const half = (span - range) / 2;\n    return 1 - half ** 2 / (0.1 * range) ** 2;\n  }\n  return 1;\n}\n\nfunction legibility() {\n  return 1;\n}\n\n/**\n * An Extension of Wilkinson's Algorithm for Position Tick Labels on Axes\n * https://www.yuque.com/preview/yuque/0/2019/pdf/185317/1546999150858-45c3b9c2-4e86-4223-bf1a-8a732e8195ed.pdf\n * @param dMin 最小值\n * @param dMax 最大值\n * @param m tick个数\n * @param onlyLoose 是否允许扩展min、max，不绝对强制，例如[3, 97]\n * @param Q nice numbers集合\n * @param w 四个优化组件的权重\n */\nexport default function extended(\n  dMin: number,\n  dMax: number,\n  n: number = 5,\n  onlyLoose: boolean = true,\n  Q: number[] = DEFAULT_Q,\n  w: [number, number, number, number] = [0.25, 0.2, 0.5, 0.05]\n): { min: number; max: number; ticks: number[] } {\n  // 处理小于 0 和小数的 tickCount\n  const m = n < 0 ? 0 : Math.round(n);\n\n  // nan 也会导致异常\n  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== 'number' || typeof dMax !== 'number' || !m) {\n    return {\n      min: 0,\n      max: 0,\n      ticks: [],\n    };\n  }\n\n  // js 极大值极小值问题，差值小于 1e-15 会导致计算出错\n  if (dMax - dMin < 1e-15 || m === 1) {\n    return {\n      min: dMin,\n      max: dMax,\n      ticks: [dMin],\n    };\n  }\n\n  // js 超大值问题\n  if (dMax - dMin > 1e148) {\n    const count = n || 5;\n    const step = (dMax - dMin) / count;\n    return {\n      min: dMin,\n      max: dMax,\n      ticks: Array(count).fill(null).map((_,idx) => {\n        return prettyNumber(dMin + step * idx);\n      }),\n    };\n  }\n\n  const best = {\n    score: -2,\n    lmin: 0,\n    lmax: 0,\n    lstep: 0,\n  };\n\n  let j = 1;\n  while (j < Infinity) {\n    for (let i = 0; i < Q.length; i += 1) {\n      const q = Q[i];\n      const sm = simplicityMax(q, Q, j);\n      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n        j = Infinity;\n        break;\n      }\n      let k = 2;\n      while (k < Infinity) {\n        const dm = densityMax(k, m);\n        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n          break;\n        }\n\n        const delta = (dMax - dMin) / (k + 1) / j / q;\n        let z = Math.ceil(Math.log10(delta));\n\n        while (z < Infinity) {\n          const step = j * q * 10 ** z;\n          const cm = coverageMax(dMin, dMax, step * (k - 1));\n\n          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n            break;\n          }\n\n          const minStart = Math.floor(dMax / step) * j - (k - 1) * j;\n          const maxStart = Math.ceil(dMin / step) * j;\n\n          if (minStart <= maxStart) {\n            const count = maxStart - minStart;\n            for (let i = 0; i <= count; i += 1) {\n              const start = minStart + i;\n              const lMin = start * (step / j);\n              const lMax = lMin + step * (k - 1);\n              const lStep = step;\n\n              const s = simplicity(q, Q, j, lMin, lMax, lStep);\n              const c = coverage(dMin, dMax, lMin, lMax);\n              const g = density(k, m, dMin, dMax, lMin, lMax);\n              const l = legibility();\n\n              const score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n              if (score > best.score && (!onlyLoose || (lMin <= dMin && lMax >= dMax))) {\n                best.lmin = lMin;\n                best.lmax = lMax;\n                best.lstep = lStep;\n                best.score = score;\n              }\n            }\n          }\n          z += 1;\n        }\n        k += 1;\n      }\n    }\n    j += 1;\n  }\n\n  // 处理精度问题，保证这三个数没有精度问题\n  const lmax = prettyNumber(best.lmax);\n  const lmin = prettyNumber(best.lmin);\n  const lstep = prettyNumber(best.lstep);\n\n  // 加 round 是为处理 extended(0.94, 1, 5)\n  // 保证生成的 tickCount 没有精度问题\n  const tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;\n  const ticks = new Array(tickCount);\n\n  // 少用乘法：防止出现 -1.2 + 1.2 * 3 = 2.3999999999999995 的情况\n  ticks[0] = prettyNumber(lmin);\n  for (let i = 1; i < tickCount; i++) {\n    ticks[i] = prettyNumber(ticks[i - 1] + lstep);\n  }\n\n  return {\n    min: Math.min(dMin, head(ticks)),\n    max: Math.max(dMax, last(ticks)),\n    ticks,\n  };\n}\n","import { prettyNumber } from './pretty-number';\n\nexport default function pretty(min: number, max: number, m: number = 5) {\n  if (min === max) {\n    return {\n      max,\n      min,\n      ticks: [min],\n    };\n  }\n\n  const n = m < 0 ? 0 : Math.round(m);\n  if (n === 0) return { max, min, ticks: [] };\n\n  /*\n    R pretty:\n    https://svn.r-project.org/R/trunk/src/appl/pretty.c\n    https://www.rdocumentation.org/packages/base/versions/3.5.2/topics/pretty\n    */\n  const h = 1.5; // high.u.bias\n  const h5 = 0.5 + 1.5 * h; // u5.bias\n  // 反正我也不会调参，跳过所有判断步骤\n  const d = max - min;\n  const c = d / n;\n  // 当d非常小的时候触发，但似乎没什么用\n  // const min_n = Math.floor(n / 3);\n  // const shrink_sml = Math.pow(2, 5);\n  // if (Math.log10(d) < -2) {\n  //   c = (_.max([ Math.abs(max), Math.abs(min) ]) * shrink_sml) / min_n;\n  // }\n\n  const base = Math.pow(10, Math.floor(Math.log10(c)));\n  let unit = base;\n  if (2 * base - c < h * (c - unit)) {\n    unit = 2 * base;\n    if (5 * base - c < h5 * (c - unit)) {\n      unit = 5 * base;\n      if (10 * base - c < h * (c - unit)) {\n        unit = 10 * base;\n      }\n    }\n  }\n  const nu = Math.ceil(max / unit);\n  const ns = Math.floor(min / unit);\n\n  const hi = Math.max(nu * unit, max);\n  const lo = Math.min(ns * unit, min);\n\n  const size = Math.floor((hi - lo) / unit) + 1;\n  const ticks = new Array(size);\n  for (let i = 0; i < size; i++) {\n    ticks[i] = prettyNumber(lo + i * unit);\n  }\n\n  return {\n    min: lo,\n    max: hi,\n    ticks,\n  };\n}\n","import { ScaleConfig } from '../types';\n/**\n * 计算几分位 https://github.com/simple-statistics/simple-statistics/blob/master/src/quantile_sorted.js\n * @param x  数组\n * @param p  百分比\n */\nfunction quantileSorted(x, p) {\n  const idx = x.length * p;\n  /*if (x.length === 0) { // 当前场景这些条件不可能命中\n    throw new Error('quantile requires at least one value.');\n  } else if (p < 0 || p > 1) {\n    throw new Error('quantiles must be between 0 and 1');\n  } else */\n  \n  if (p === 1) {\n    // If p is 1, directly return the last element\n    return x[x.length - 1];\n  } else if (p === 0) {\n    // If p is 0, directly return the first element\n    return x[0];\n  } else if (idx % 1 !== 0) {\n    // If p is not integer, return the next element in array\n    return x[Math.ceil(idx) - 1];\n  } else if (x.length % 2 === 0) {\n    // If the list has even-length, we'll take the average of this number\n    // and the next value, if there is one\n    return (x[idx - 1] + x[idx]) / 2;\n  } else {\n    // Finally, in the simple case of an integer value\n    // with an odd-length list, return the x value at the index.\n    return x[idx];\n  }\n}\n\nexport default function calculateTicks(cfg: ScaleConfig) {\n  const { tickCount, values } = cfg;\n  if (!values || !values.length) {\n    return [];\n  }\n  const sorted = values.slice().sort((a, b) => {\n    return a - b;\n  });\n  const ticks = [];\n  for (let i = 0; i < tickCount; i++) {\n    const p = i / (tickCount - 1);\n    ticks.push(quantileSorted(sorted, p));\n  }\n  return ticks;\n}\n","import { ScaleConfig } from '../types';\nimport { DAY, getTickInterval, HOUR, MINUTE, MONTH, SECOND, YEAR } from '../util/time';\n\nfunction getYear(date: number) {\n  return new Date(date).getFullYear();\n}\n\nfunction createYear(year: number) {\n  return new Date(year, 0, 1).getTime();\n}\n\nfunction getMonth(date: number) {\n  return new Date(date).getMonth();\n}\n\nfunction diffMonth(min: number, max: number) {\n  const minYear = getYear(min);\n  const maxYear = getYear(max);\n  const minMonth = getMonth(min);\n  const maxMonth = getMonth(max);\n  return (maxYear - minYear) * 12 + ((maxMonth - minMonth) % 12);\n}\n\nfunction creatMonth(year: number, month: number) {\n  return new Date(year, month, 1).getTime();\n}\n\nfunction diffDay(min: number, max: number) {\n  return Math.ceil((max - min) / DAY);\n}\n\nfunction diffHour(min: number, max: number) {\n  return Math.ceil((max - min) / HOUR);\n}\n\nfunction diffMinus(min: number, max: number) {\n  return Math.ceil((max - min) / (60 * 1000));\n}\n\n/**\n * 计算 time 的 ticks，对 month, year 进行 pretty 处理\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function timePretty(cfg: ScaleConfig): number[] {\n  const { min, max, minTickInterval, tickCount } = cfg;\n  let { tickInterval } = cfg;\n  const ticks: number[] = [];\n  // 指定 tickInterval 后 tickCount 不生效，需要重新计算\n  if (!tickInterval) {\n    tickInterval = (max - min) / tickCount;\n    // 如果设置了最小间距，则使用最小间距\n    if (minTickInterval && tickInterval < minTickInterval) {\n      tickInterval = minTickInterval;\n    }\n  }\n  tickInterval = Math.max(Math.floor((max - min) / (2 ** 12 - 1)), tickInterval);\n  const minYear = getYear(min);\n  // 如果间距大于 1 年，则将开始日期从整年开始\n  if (tickInterval > YEAR) {\n    const maxYear = getYear(max);\n    const yearInterval = Math.ceil(tickInterval / YEAR);\n    for (let i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {\n      ticks.push(createYear(i));\n    }\n  } else if (tickInterval > MONTH) {\n    // 大于月时\n    const monthInterval = Math.ceil(tickInterval / MONTH);\n    const mmMoth = getMonth(min);\n    const dMonths = diffMonth(min, max);\n    for (let i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {\n      ticks.push(creatMonth(minYear, i + mmMoth));\n    }\n  } else if (tickInterval > DAY) {\n    // 大于天\n    const date = new Date(min);\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const mday = date.getDate();\n    const day = Math.ceil(tickInterval / DAY);\n    const ddays = diffDay(min, max);\n    for (let i = 0; i < ddays + day; i = i + day) {\n      ticks.push(new Date(year, month, mday + i).getTime());\n    }\n  } else if (tickInterval > HOUR) {\n    // 大于小时\n    const date = new Date(min);\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const day = date.getDate();\n    const hour = date.getHours();\n    const hours = Math.ceil(tickInterval / HOUR);\n    const dHours = diffHour(min, max);\n    for (let i = 0; i <= dHours + hours; i = i + hours) {\n      ticks.push(new Date(year, month, day, hour + i).getTime());\n    }\n  } else if (tickInterval > MINUTE) {\n    // 大于分钟\n    const dMinus = diffMinus(min, max);\n    const minutes = Math.ceil(tickInterval / MINUTE);\n    for (let i = 0; i <= dMinus + minutes; i = i + minutes) {\n      ticks.push(min + i * MINUTE);\n    }\n  } else {\n    // 小于分钟\n    let interval = tickInterval;\n    if (interval < SECOND) {\n      interval = SECOND;\n    }\n    const minSecond = Math.floor(min / SECOND) * SECOND;\n    const dSeconds = Math.ceil((max - min) / SECOND);\n    const seconds = Math.ceil(interval / SECOND);\n    for (let i = 0; i < dSeconds + seconds; i = i + seconds) {\n      ticks.push(minSecond + i * SECOND);\n    }\n  }\n\n  // 最好是能从算法能解决这个问题，但是如果指定了 tickInterval，计算 ticks，也只能这么算，所以\n  // 打印警告提示\n  if (ticks.length >= 512) {\n    console.warn(`Notice: current ticks length(${ticks.length}) >= 512, may cause performance issues, even out of memory. Because of the configure \"tickInterval\"(in milliseconds, current is ${tickInterval}) is too small, increase the value to solve the problem!`);\n  }\n\n  return ticks;\n}\n","import cat from './cat';\nimport d3Linear from './d3-linear';\nimport linear from './linear';\nimport log from './log';\nimport pow from './pow';\nimport quantile from './quantile';\nimport rPretty from './r-prettry';\nimport { getTickMethod, registerTickMethod } from './register';\nimport time from './time';\nimport timeCat from './time-cat';\nimport timePretty from './time-pretty';\n\nregisterTickMethod('cat', cat);\nregisterTickMethod('time-cat', timeCat);\nregisterTickMethod('wilkinson-extended', linear);\nregisterTickMethod('r-pretty', rPretty);\nregisterTickMethod('time', time);\nregisterTickMethod('time-pretty', timePretty);\nregisterTickMethod('log', log);\nregisterTickMethod('pow', pow);\nregisterTickMethod('quantile', quantile);\nregisterTickMethod('d3-linear', d3Linear);\n\nexport { getTickMethod, registerTickMethod };\n","import { ScaleConfig } from '../types';\nimport catTicks from './cat';\n/**\n * 计算时间分类的 ticks, 保头，保尾\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function timeCat(cfg: ScaleConfig): any[] {\n  // 默认保留最后一条\n  const ticks = catTicks({ showLast: true, ...cfg });\n  return ticks;\n}\n","import { head, isNil, last } from '@antv/util';\nimport { ScaleConfig } from '../types';\nimport extended from '../util/extended';\nimport interval from '../util/interval';\nimport strictLimit from '../util/strict-limit';\n\n/**\n * 计算线性的 ticks，使用 wilkinson extended 方法\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function linear(cfg: ScaleConfig): number[] {\n  const { min, max, tickCount, nice, tickInterval, minLimit, maxLimit } = cfg;\n  const ticks = extended(min, max, tickCount, nice).ticks;\n\n  if (!isNil(minLimit) || !isNil(maxLimit)) {\n    return strictLimit(cfg, head(ticks), last(ticks));\n  }\n  if (tickInterval) {\n    return interval(min, max, tickInterval).ticks;\n  }\n  return ticks;\n}\n","import { head, isNil, last } from '@antv/util';\nimport { ScaleConfig } from '../types';\nimport interval from '../util/interval';\nimport pretty from '../util/pretty';\nimport strictLimit from '../util/strict-limit';\n\n/**\n * 计算线性的 ticks，使用 R's pretty 方法\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function linearPretty(cfg: ScaleConfig): number[] {\n  const { min, max, tickCount, tickInterval, minLimit, maxLimit } = cfg;\n  const ticks = pretty(min, max, tickCount).ticks;\n\n  if (!isNil(minLimit) || !isNil(maxLimit)) {\n    return strictLimit(cfg, head(ticks), last(ticks));\n  }\n  if (tickInterval) {\n    return interval(min, max, tickInterval).ticks;\n  }\n  return ticks;\n}\n","import { ScaleConfig } from '../types';\nimport { getTickInterval } from '../util/time';\n\nexport default function calculateTimeTicks(cfg: ScaleConfig): number[] {\n  const { min, max, minTickInterval } = cfg;\n  let tickInterval = cfg.tickInterval;\n  let tickCount = cfg.tickCount;\n  // 指定 tickInterval 后 tickCount 不生效，需要重新计算\n  if (tickInterval) {\n    tickCount = Math.ceil((max - min) / tickInterval);\n  } else {\n    tickInterval = getTickInterval(min, max, tickCount)[1];\n    const count = (max - min) / tickInterval;\n    const ratio = count / tickCount;\n    if (ratio > 1) {\n      tickInterval = tickInterval * Math.ceil(ratio);\n    }\n    // 如果设置了最小间距，则使用最小间距\n    if (minTickInterval && tickInterval < minTickInterval) {\n      tickInterval = minTickInterval;\n    }\n  }\n\n  tickInterval = Math.max(Math.floor((max - min) / (2 ** 12 - 1)), tickInterval);\n  const ticks = [];\n  for (let i = min; i < max + tickInterval; i += tickInterval) {\n    ticks.push(i);\n  }\n  return ticks;\n}\n","import { isEmpty } from '@antv/util';\nimport { ScaleConfig } from '../types';\nimport { getLogPositiveMin, log } from '../util/math';\n\n/**\n * 计算 log 的 ticks，考虑 min = 0 的场景\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function calculateLogTicks(cfg: ScaleConfig) {\n  const { base, tickCount, min, max, values } = cfg;\n  let minTick;\n  const maxTick = log(base, max);\n  if (min > 0) {\n    minTick = Math.floor(log(base, min));\n  } else {\n    const positiveMin = getLogPositiveMin(values, base, max);\n    minTick = Math.floor(log(base, positiveMin));\n  }\n  const count = maxTick - minTick;\n  const avg = Math.ceil(count / tickCount);\n  const ticks = [];\n  for (let i = minTick; i < maxTick + avg; i = i + avg) {\n    ticks.push(Math.pow(base, i));\n  }\n  if (min <= 0) {\n    // 最小值 <= 0 时显示 0\n    ticks.unshift(0);\n  }\n  return ticks;\n}\n","import { ScaleConfig } from '../types';\nimport { calBase } from '../util/math';\nimport pretty from '../util/pretty';\n/**\n * 计算 Pow 的 ticks\n * @param cfg 度量的配置项\n * @returns 计算后的 ticks\n */\nexport default function calculatePowTicks(cfg: ScaleConfig) {\n  const { exponent, tickCount } = cfg;\n  const max = Math.ceil(calBase(exponent, cfg.max));\n  const min = Math.floor(calBase(exponent, cfg.min));\n  const ticks = pretty(min, max, tickCount).ticks;\n  return ticks.map((tick) => {\n    const factor = tick >= 0 ? 1 : -1;\n    return Math.pow(tick, exponent) * factor;\n  });\n}\n","import { head, isNil, last } from '@antv/util';\nimport { ScaleConfig } from '../types';\nimport d3Linear from '../util/d3-linear';\nimport interval from '../util/interval';\nimport strictLimit from '../util/strict-limit';\n\nexport default function d3LinearTickMethod(cfg: ScaleConfig): number[] {\n  const { min, max, tickInterval, minLimit, maxLimit } = cfg;\n  const ticks = d3Linear(cfg);\n\n  if (!isNil(minLimit) || !isNil(maxLimit)) {\n    return strictLimit(cfg, head(ticks), last(ticks));\n  }\n  if (tickInterval) {\n    return interval(min, max, tickInterval).ticks;\n  }\n  return ticks;\n}\n","import Scale from './base';\nimport Category from './category/base';\nimport TimeCat from './category/time';\nimport Linear from './continuous/linear';\nimport Log from './continuous/log';\nimport Pow from './continuous/pow';\nimport Time from './continuous/time';\nimport Quantize from './continuous/quantize';\nimport Quantile from './continuous/quantile';\nimport { getScale, registerScale } from './factory';\nimport Identity from './identity/index';\nimport { getTickMethod, registerTickMethod } from './tick-method/index';\nimport { ScaleConfig, Tick } from './types';\n\nregisterScale('cat', Category);\nregisterScale('category', Category);\nregisterScale('identity', Identity);\nregisterScale('linear', Linear);\nregisterScale('log', Log);\nregisterScale('pow', Pow);\nregisterScale('time', Time);\nregisterScale('timeCat', TimeCat);\nregisterScale('quantize', Quantize);\nregisterScale('quantile', Quantile);\n\nexport {\n  Category,\n  Identity,\n  Linear,\n  Log,\n  Pow,\n  Time,\n  TimeCat,\n  Quantile,\n  Quantize,\n  Scale,\n  getScale,\n  registerScale,\n  ScaleConfig,\n  Tick,\n  getTickMethod,\n  registerTickMethod,\n};\n"],"names":["methodCache","registerTickMethod","key","method","cfg","type","isCategory","isLinear","isContinuous","isIdentity","values","range","ticks","this","__cfg__","initCfg","init","Scale","v","assign","constructor","map","tick","idx","isObject","text","_this","getText","tickValue","value","scale","formatter","res","isNil","isFunction","toString","setDomain","isEmpty","getConfig","calculateTicks","tickMethod","isString","Error","min","max","isNumber","NaN","percent","__extends","Category","translateIndexMap","Map","i","length","set","buildIndexMap","get","undefined","order","translate","calcPercent","calcValue","rangeMin","rangeMax","scaledValue","domainRange","Math","round","args","includes","_super","apply","__spreadArrays","size","Base","timeFormat","time","mask","fecha1","fecha","toTimeStamp","indexOf","Date","getTime","replace","isDate","SECOND","MINUTE","HOUR","DAY","MONTH","YEAR","intervals","getTickInterval","tickCount","getter","o","a","x","_lo","_hi","lo","hi","mid","interval","last","TimeCat","index","tickIndex","result","each","sort","v1","v2","call","Continuous","getScalePercent","firstTick","head","lastTick","minLimit","maxLimit","getRange","nice","filter","Linear","getInvertPercent","calBase","b","e","E","pow","log","getLogPositiveMin","base","positiveMin","Log","appendPercent","tmp","Pow","exponent","factor","Time","numberValue","minConfig","maxConfig","timeStamps_1","min_1","Infinity","secondMin_1","max_1","timeStamp","isNaN","TypeError","push","minTickInterval","Quantize","minIndex","floor","minTick","minIndexPercent","unshift","Quantile","getClass","registerClass","cls","Identity","calculateCatTicks","tickInterval","showLast","ticks_1","__","lastValue","len","slice","e10","sqrt","e5","e2","_domain","D3Linear","domain","Array","from","Number","count","step","d","i0","i1","start","stop","_a","_b","tickIncrement","ceil","reverse","n","isFinite","d3ArrayTicks","power","LN10","error","snapMultiple","snapType","intervalTicks","maxTick","fixedBase","availableInterval","strictLimit","defaultMin","defaultMax","tickMin","tickMax","prettyNumber","abs","parseFloat","toFixed","DEFAULT_Q","eps","EPSILON","simplicity","q","Q","j","lmin","lmax","lstep","m","mod","simplicityMax","density","k","dMin","dMax","lMin","lMax","r","rt","densityMax","coverage","coverageMax","span","half","extended","onlyLoose","w","step_1","fill","_","best","score","sm","dm","delta","z","log10","cm","minStart","maxStart","i_1","lStep","s","c","g","pretty","unit","nu","ns","quantileSorted","p","getYear","date","getFullYear","createYear","year","getMonth","creatMonth","month","cat","catTicks","ratio","minYear","maxYear","yearInterval","monthInterval","mmMoth","dMonths","minMonth","diffMonth","mday","getDate","day","ddays","diffDay","hour","getHours","hours","dHours","diffHour","dMinus","diffMinus","minutes","minSecond","dSeconds","seconds","console","warn","avg","sorted","linear","d3Linear","registerScale"],"sourceRoot":""}