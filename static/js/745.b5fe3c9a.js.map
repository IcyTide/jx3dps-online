{"version":3,"file":"static/js/745.b5fe3c9a.js","mappings":"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","sources":["../node_modules/@antv/dom-util/src/add-event-listener.ts","../node_modules/@antv/dom-util/src/create-dom.ts","../node_modules/@antv/dom-util/src/get-outer-height.ts","../node_modules/@antv/dom-util/src/get-height.ts","../node_modules/@antv/dom-util/src/get-outer-width.ts","../node_modules/@antv/dom-util/src/get-width.ts","../node_modules/@antv/dom-util/src/get-style.ts","../node_modules/@antv/dom-util/src/modify-css.ts","../node_modules/@antv/event-emitter/src/index.ts","../node_modules/@antv/g-base/src/abstract/base.ts","../node_modules/@antv/g-base/src/abstract/canvas.ts","../node_modules/@antv/g-base/src/abstract/container.ts","../node_modules/@antv/g-base/src/abstract/element.ts","../node_modules/@antv/g-base/src/abstract/group.ts","../node_modules/@antv/g-base/src/abstract/shape.ts"],"sourcesContent":["export default function addEventListener(target: HTMLElement, eventType: string, callback: any) {\n  if (target) {\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove() {\n          target.removeEventListener(eventType, callback, false);\n        },\n      };\n      // @ts-ignore\n    }  if (typeof target.attachEvent === 'function') {\n      // @ts-ignore\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove() {\n          // @ts-ignore\n          target.detachEvent('on' + eventType, callback);\n        },\n      };\n    }\n  }\n}\n","/**\n * 创建DOM 节点\n * @param  {String} str Dom 字符串\n * @return {HTMLElement}  DOM 节点\n */\n\nlet TABLE:HTMLTableElement;\nlet TABLE_TR:HTMLTableRowElement;\nlet FRAGMENT_REG:RegExp;\nlet CONTAINERS:{\n  '*': HTMLDivElement;\n  [key:string]: any;\n};\n\nfunction initConstants() {\n  TABLE = document.createElement('table');\n  TABLE_TR = document.createElement('tr');\n  FRAGMENT_REG = /^\\s*<(\\w+|!)[^>]*>/;\n  CONTAINERS = {\n    tr: document.createElement('tbody'),\n    tbody: TABLE,\n    thead: TABLE,\n    tfoot: TABLE,\n    td: TABLE_TR,\n    th: TABLE_TR,\n    '*': document.createElement('div'),\n  };\n}\n\nexport default function createDom(str:string): any {\n  if (!TABLE) {\n    initConstants();\n  }\n  let name = FRAGMENT_REG.test(str) && RegExp.$1;\n  if (!name || !(name in CONTAINERS)) {\n    name = '*';\n  }\n  const container = CONTAINERS[name];\n  str = typeof str === 'string' ? str.replace(/(^\\s*)|(\\s*$)/g, '') : str;\n  container.innerHTML = '' + str;\n  const dom = container.childNodes[0];\n  if (dom && container.contains(dom)) {\n    container.removeChild(dom);\n  }\n  return dom;\n}\n","\nimport getStyle from './get-style';\nimport getHeight from './get-height';\n\nexport default function getOuterHeight(el: HTMLElement, defaultValue?: any): number {\n  const height = getHeight(el, defaultValue);\n  const bTop = parseFloat(getStyle(el, 'borderTopWidth')) || 0;\n  const pTop = parseFloat(getStyle(el, 'paddingTop')) || 0;\n  const pBottom = parseFloat(getStyle(el, 'paddingBottom')) || 0;\n  const bBottom = parseFloat(getStyle(el, 'borderBottomWidth')) || 0;\n  const mTop = parseFloat(getStyle(el, 'marginTop')) || 0;\n  const mBottom = parseFloat(getStyle(el, 'marginBottom')) || 0;\n  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;\n}\n","import getStyle from './get-style';\n\nexport default function getHeight(el: HTMLElement, defaultValue?: any): number {\n  let height = getStyle(el, 'height', defaultValue);\n  if (height === 'auto') {\n    height = el.offsetHeight;\n  }\n  return parseFloat(height);\n}\n","\nimport getStyle from './get-style';\nimport getWidth from './get-width';\n\nexport default function getOuterWidth(el: HTMLElement, defaultValue?: any): number {\n  const width = getWidth(el, defaultValue);\n  const bLeft = parseFloat(getStyle(el, 'borderLeftWidth')) || 0;\n  const pLeft = parseFloat(getStyle(el, 'paddingLeft')) || 0;\n  const pRight = parseFloat(getStyle(el, 'paddingRight')) || 0;\n  const bRight = parseFloat(getStyle(el, 'borderRightWidth')) || 0;\n  const mRight = parseFloat(getStyle(el, 'marginRight')) || 0;\n  const mLeft = parseFloat(getStyle(el, 'marginLeft')) || 0;\n  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;\n}\n","import getStyle from './get-style';\n\nexport default function getHeight(el: HTMLElement, defaultValue?: any): number {\n  let width = getStyle(el, 'width', defaultValue);\n  if (width === 'auto') {\n    width = el.offsetWidth;\n  }\n  return parseFloat(width);\n}\n","/**\n * 获取样式\n * @param  {Object} dom DOM节点\n * @param  {String} name 样式名\n * @param  {Any} defaultValue 默认值\n * @return {String} 属性值\n */\nexport default function getStyle(dom: HTMLElement, name: string, defaultValue?: any) {\n  let v;\n  try {\n    v = window.getComputedStyle ?\n      window.getComputedStyle(dom, null)[name] :\n      dom.style[name]; // 一般不会走到这个逻辑，dom.style 获取的是标签 style 属性，也不准确\n  } catch (e) {\n    // do nothing\n  } finally {\n    v = v === undefined ? defaultValue : v;\n  }\n  return v;\n}\n","export default function modifyCSS(dom: HTMLElement, css: { [key:string]: any }): HTMLElement {\n  if (dom) {\n    for (const key in css) {\n      if (css.hasOwnProperty(key)) {\n        dom.style[key] = css[key];\n      }\n    }\n  }\n  return dom;\n}\n","interface EventType {\n  readonly callback: Function;\n  readonly once: boolean;\n}\n\ntype EventsType = Record<string, EventType[]>;\n\nconst WILDCARD = '*';\n\n/* event-emitter */\nexport default class EventEmitter {\n  private _events: EventsType = {};\n\n  /**\n   * 监听一个事件\n   * @param evt\n   * @param callback\n   * @param once\n   */\n  on(evt: string, callback: Function, once?: boolean) {\n    if (!this._events[evt]) {\n      this._events[evt] = [];\n    }\n    this._events[evt].push({\n      callback,\n      once: !!once,\n    });\n    return this;\n  }\n\n  /**\n   * 监听一个事件一次\n   * @param evt\n   * @param callback\n   */\n  once(evt: string, callback: Function) {\n    return this.on(evt, callback, true);\n  }\n\n  /**\n   * 触发一个事件\n   * @param evt\n   * @param args\n   */\n  emit(evt: string, ...args: any[]) {\n    const events = this._events[evt] || [];\n    const wildcardEvents = this._events[WILDCARD] || [];\n\n    // 实际的处理 emit 方法\n    const doEmit = (es: EventType[]) => {\n      let length = es.length;\n      for (let i = 0; i < length; i++) {\n        if (!es[i]) {\n          continue;\n        }\n        const { callback, once } = es[i];\n\n        if (once) {\n          es.splice(i, 1);\n\n          if (es.length === 0) {\n            delete this._events[evt];\n          }\n\n          length--;\n          i--;\n        }\n\n        callback.apply(this, args);\n      }\n    };\n\n    doEmit(events);\n    doEmit(wildcardEvents);\n  }\n\n  /**\n   * 取消监听一个事件，或者一个channel\n   * @param evt\n   * @param callback\n   */\n  off(evt?: string, callback?: Function) {\n    if (!evt) {\n      // evt 为空全部清除\n      this._events = {};\n    } else {\n      if (!callback) {\n        // evt 存在，callback 为空，清除事件所有方法\n        delete this._events[evt];\n      } else {\n        // evt 存在，callback 存在，清除匹配的\n        const events = this._events[evt] || [];\n\n        let length = events.length;\n        for (let i = 0; i < length; i++) {\n          if (events[i].callback === callback) {\n            events.splice(i, 1);\n            length--;\n            i--;\n          }\n        }\n\n        if (events.length === 0) {\n          delete this._events[evt];\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /* 当前所有的事件 */\n  getEvents() {\n    return this._events;\n  }\n}\n","import EE from '@antv/event-emitter';\nimport { IBase } from '../interfaces';\nimport { mix } from '../util/util';\nimport { LooseObject } from '../types';\nabstract class Base extends EE implements IBase {\n  /**\n   * 内部属性，用于 get,set，但是可以用于优化性能使用\n   * @type {object}\n   */\n  cfg: LooseObject;\n\n  /**\n   * 是否被销毁\n   * @type {boolean}\n   */\n  destroyed: boolean = false;\n\n  /**\n   * @protected\n   * 默认的配置项\n   * @returns {object} 默认的配置项\n   */\n  getDefaultCfg() {\n    return {};\n  }\n\n  constructor(cfg) {\n    super();\n    const defaultCfg = this.getDefaultCfg();\n    this.cfg = mix(defaultCfg, cfg);\n  }\n\n  // 实现接口的方法\n  get(name) {\n    return this.cfg[name];\n  }\n  // 实现接口的方法\n  set(name, value) {\n    this.cfg[name] = value;\n  }\n\n  // 实现接口的方法\n  destroy() {\n    this.cfg = {\n      destroyed: true,\n    };\n    this.off();\n    this.destroyed = true;\n  }\n}\n\nexport default Base;\n","import { detect } from 'detect-browser';\nimport Container from './container';\nimport { ICanvas } from '../interfaces';\nimport { CanvasCfg, Point, Renderer, Cursor } from '../types';\nimport { isBrowser, isNil, isString } from '../util/util';\nimport Timeline from '../animate/timeline';\nimport EventController from '../event/event-contoller';\n\nconst PX_SUFFIX = 'px';\n\nconst browser = detect();\nconst isFirefox = browser && browser.name === 'firefox';\n\nabstract class Canvas extends Container implements ICanvas {\n  constructor(cfg: CanvasCfg) {\n    super(cfg);\n    this.initContainer();\n    this.initDom();\n    this.initEvents();\n    this.initTimeline();\n  }\n\n  getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    // set default cursor style for canvas\n    cfg['cursor'] = 'default';\n    // CSS transform 目前尚未经过长时间验证，为了避免影响上层业务，默认关闭，上层按需开启\n    cfg['supportCSSTransform'] = false;\n    return cfg;\n  }\n\n  /**\n   * @protected\n   * 初始化容器\n   */\n  initContainer() {\n    let container = this.get('container');\n    if (isString(container)) {\n      container = document.getElementById(container);\n      this.set('container', container);\n    }\n  }\n\n  /**\n   * @protected\n   * 初始化 DOM\n   */\n  initDom() {\n    const el = this.createDom();\n    this.set('el', el);\n    // 附加到容器\n    const container = this.get('container');\n    container.appendChild(el);\n    // 设置初始宽度\n    this.setDOMSize(this.get('width'), this.get('height'));\n  }\n\n  /**\n   * 创建画布容器\n   * @return {HTMLElement} 画布容器\n   */\n  abstract createDom(): HTMLElement | SVGSVGElement;\n\n  /**\n   * @protected\n   * 初始化绑定的事件\n   */\n  initEvents() {\n    const eventController = new EventController({\n      canvas: this,\n    });\n    eventController.init();\n    this.set('eventController', eventController);\n  }\n\n  /**\n   * @protected\n   * 初始化时间轴\n   */\n  initTimeline() {\n    const timeline = new Timeline(this);\n    this.set('timeline', timeline);\n  }\n\n  /**\n   * @protected\n   * 修改画布对应的 DOM 的大小\n   * @param {number} width  宽度\n   * @param {number} height 高度\n   */\n  setDOMSize(width: number, height: number) {\n    const el = this.get('el');\n    if (isBrowser) {\n      el.style.width = width + PX_SUFFIX;\n      el.style.height = height + PX_SUFFIX;\n    }\n  }\n\n  // 实现接口\n  changeSize(width: number, height: number) {\n    this.setDOMSize(width, height);\n    this.set('width', width);\n    this.set('height', height);\n    this.onCanvasChange('changeSize');\n  }\n\n  /**\n   * 获取当前的渲染引擎\n   * @return {Renderer} 返回当前的渲染引擎\n   */\n  getRenderer(): Renderer {\n    return this.get('renderer');\n  }\n\n  /**\n   * 获取画布的 cursor 样式\n   * @return {Cursor}\n   */\n  getCursor(): Cursor {\n    return this.get('cursor');\n  }\n\n  /**\n   * 设置画布的 cursor 样式\n   * @param {Cursor} cursor  cursor 样式\n   */\n  setCursor(cursor: Cursor) {\n    this.set('cursor', cursor);\n    const el = this.get('el');\n    if (isBrowser && el) {\n      // 直接设置样式，不等待鼠标移动时再设置\n      el.style.cursor = cursor;\n    }\n  }\n\n  // 实现接口\n  getPointByEvent(ev: Event): Point {\n    const supportCSSTransform = this.get('supportCSSTransform');\n    if (supportCSSTransform) {\n      // For Firefox <= 38\n      if (isFirefox && !isNil((ev as any).layerX) && (ev as any).layerX !== (ev as MouseEvent).offsetX) {\n        return {\n          x: (ev as any).layerX,\n          y: (ev as any).layerY,\n        };\n      }\n      if (!isNil((ev as MouseEvent).offsetX)) {\n        // For IE6+, Firefox >= 39, Chrome, Safari, Opera\n        return {\n          x: (ev as MouseEvent).offsetX,\n          y: (ev as MouseEvent).offsetY,\n        };\n      }\n    }\n    // should calculate by self for other cases, like Safari in ios\n    // TODO: support CSS transform\n    const { x: clientX, y: clientY } = this.getClientByEvent(ev);\n    return this.getPointByClient(clientX, clientY);\n  }\n\n  // 获取 touch 事件的 clientX 和 clientY 需要单独处理\n  getClientByEvent(ev: Event) {\n    let clientInfo: MouseEvent | Touch = ev as MouseEvent;\n    if ((ev as TouchEvent).touches) {\n      if (ev.type === 'touchend') {\n        clientInfo = (ev as TouchEvent).changedTouches[0];\n      } else {\n        clientInfo = (ev as TouchEvent).touches[0];\n      }\n    }\n    return {\n      x: clientInfo.clientX,\n      y: clientInfo.clientY,\n    };\n  }\n\n  // 实现接口\n  getPointByClient(clientX: number, clientY: number): Point {\n    const el = this.get('el');\n    const bbox = el.getBoundingClientRect();\n    return {\n      x: clientX - bbox.left,\n      y: clientY - bbox.top,\n    };\n  }\n\n  // 实现接口\n  getClientByPoint(x: number, y: number): Point {\n    const el = this.get('el');\n    const bbox = el.getBoundingClientRect();\n    return {\n      x: x + bbox.left,\n      y: y + bbox.top,\n    };\n  }\n\n  // 实现接口\n  draw() {}\n\n  /**\n   * @protected\n   * 销毁 DOM 容器\n   */\n  removeDom() {\n    const el = this.get('el');\n    el.parentNode.removeChild(el);\n  }\n\n  /**\n   * @protected\n   * 清理所有的事件\n   */\n  clearEvents() {\n    const eventController = this.get('eventController');\n    eventController.destroy();\n  }\n\n  isCanvas() {\n    return true;\n  }\n\n  getParent() {\n    return null;\n  }\n\n  destroy() {\n    const timeline = this.get('timeline');\n    if (this.get('destroyed')) {\n      return;\n    }\n    this.clear();\n    // 同初始化时相反顺序调用\n    if (timeline) {\n      // 画布销毁时自动停止动画\n      timeline.stop();\n    }\n    this.clearEvents();\n    this.removeDom();\n    super.destroy();\n  }\n}\n\nexport default Canvas;\n","import { max, min } from '@antv/util';\nimport { IContainer, IShape, IGroup, IElement, ICanvas } from '../interfaces';\nimport { BBox, ElementFilterFn } from '../types';\nimport Timeline from '../animate/timeline';\nimport Element from './element';\nimport { isFunction, isObject, each, removeFromArray, upperFirst, isAllowCapture } from '../util/util';\n\nconst SHAPE_MAP = {};\nconst INDEX = '_INDEX';\n\n/**\n * 设置 canvas\n * @param {IElement} element 元素\n * @param {ICanvas}  canvas  画布\n */\nfunction setCanvas(element: IElement, canvas: ICanvas) {\n  element.set('canvas', canvas);\n  if (element.isGroup()) {\n    const children = element.get('children');\n    if (children.length) {\n      children.forEach((child) => {\n        setCanvas(child, canvas);\n      });\n    }\n  }\n}\n\n/**\n * 设置 timeline\n * @param {IElement} element  元素\n * @param {Timeline} timeline 时间轴\n */\nfunction setTimeline(element: IElement, timeline: Timeline) {\n  element.set('timeline', timeline);\n  if (element.isGroup()) {\n    const children = element.get('children');\n    if (children.length) {\n      children.forEach((child) => {\n        setTimeline(child, timeline);\n      });\n    }\n  }\n}\n\nfunction contains(container: IContainer, element: IElement): boolean {\n  const children = container.getChildren();\n  return children.indexOf(element) >= 0;\n}\n\nfunction removeChild(container: IContainer, element: IElement, destroy: boolean = true) {\n  // 不再调用 element.remove() 方法，会出现循环调用\n  if (destroy) {\n    element.destroy();\n  } else {\n    element.set('parent', null);\n    element.set('canvas', null);\n  }\n  removeFromArray(container.getChildren(), element);\n}\n\nfunction getComparer(compare: Function) {\n  return function (left, right) {\n    const result = compare(left, right);\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\n  };\n}\n\nabstract class Container extends Element implements IContainer {\n  isCanvas() {\n    return false;\n  }\n\n  // 根据子节点确定 BBox\n  getBBox(): BBox {\n    // 所有的值可能在画布的可视区外\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    const children = this.getChildren().filter(\n      (child) =>\n        child.get('visible') && (!child.isGroup() || (child.isGroup() && (child as IGroup).getChildren().length > 0))\n    );\n    if (children.length > 0) {\n      each(children, (child: IElement) => {\n        const { minX: childMinX, maxX: childMaxX, minY: childMinY, maxY: childMaxY } = child.getBBox();\n        if (childMinX < minX) {\n          minX = childMinX;\n        }\n        if (childMaxX > maxX) {\n          maxX = childMaxX;\n        }\n        if (childMinY < minY) {\n          minY = childMinY;\n        }\n        if (childMaxY > maxY) {\n          maxY = childMaxY;\n        }\n      });\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    const box = {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n    return box;\n  }\n\n  // 获取画布的包围盒\n  getCanvasBBox(): BBox {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    const children = this.getChildren().filter(\n      (child) =>\n        child.get('visible') && (!child.isGroup() || (child.isGroup() && (child as IGroup).getChildren().length > 0))\n    );\n    if (children.length > 0) {\n      each(children, (child: IElement) => {\n        const { minX: childMinX, maxX: childMaxX, minY: childMinY, maxY: childMaxY } = child.getCanvasBBox();\n        if (childMinX < minX) {\n          minX = childMinX;\n        }\n        if (childMaxX > maxX) {\n          maxX = childMaxX;\n        }\n        if (childMinY < minY) {\n          minY = childMinY;\n        }\n        if (childMaxY > maxY) {\n          maxY = childMaxY;\n        }\n      });\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    const box = {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n    return box;\n  }\n\n  getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    cfg['children'] = [];\n    return cfg;\n  }\n\n  onAttrChange(name, value, originValue) {\n    super.onAttrChange(name, value, originValue);\n    if (name === 'matrix') {\n      const totalMatrix = this.getTotalMatrix();\n      this._applyChildrenMarix(totalMatrix);\n    }\n  }\n\n  // 不但应用到自己身上还要应用于子元素\n  applyMatrix(matrix: number[]) {\n    const preTotalMatrix = this.getTotalMatrix();\n    super.applyMatrix(matrix);\n    const totalMatrix = this.getTotalMatrix();\n    // totalMatrix 没有发生变化时，这里仅考虑两者都为 null 时\n    // 不继续向下传递矩阵\n    if (totalMatrix === preTotalMatrix) {\n      return;\n    }\n    this._applyChildrenMarix(totalMatrix);\n  }\n\n  // 在子元素上设置矩阵\n  _applyChildrenMarix(totalMatrix) {\n    const children = this.getChildren();\n    each(children, (child) => {\n      child.applyMatrix(totalMatrix);\n    });\n  }\n\n  // 兼容老版本的接口\n  addShape(...args): IShape {\n    const type = args[0];\n    let cfg = args[1];\n    if (isObject(type)) {\n      cfg = type;\n    } else {\n      cfg['type'] = type;\n    }\n    let shapeType = SHAPE_MAP[cfg.type];\n    if (!shapeType) {\n      shapeType = upperFirst(cfg.type);\n      SHAPE_MAP[cfg.type] = shapeType;\n    }\n    const ShapeBase = this.getShapeBase();\n    const shape = new ShapeBase[shapeType](cfg);\n    this.add(shape);\n    return shape;\n  }\n\n  addGroup(...args): IGroup {\n    const [groupClass, cfg] = args;\n    let group;\n    if (isFunction(groupClass)) {\n      if (cfg) {\n        group = new groupClass(cfg);\n      } else {\n        group = new groupClass({\n          // canvas,\n          parent: this,\n        });\n      }\n    } else {\n      const tmpCfg = groupClass || {};\n      const TmpGroupClass = this.getGroupBase();\n      group = new TmpGroupClass(tmpCfg);\n    }\n    this.add(group);\n    return group;\n  }\n\n  getCanvas() {\n    let canvas;\n    if (this.isCanvas()) {\n      canvas = this;\n    } else {\n      canvas = this.get('canvas');\n    }\n    return canvas;\n  }\n\n  getShape(x: number, y: number, ev: Event): IShape {\n    // 如果不支持拾取，则直接返回\n    if (!isAllowCapture(this)) {\n      return null;\n    }\n    const children = this.getChildren();\n    let shape;\n    // 如果容器是 group\n    if (!this.isCanvas()) {\n      let v = [x, y, 1];\n      // 将 x, y 转换成对应于 group 的局部坐标\n      v = this.invertFromMatrix(v);\n      if (!this.isClipped(v[0], v[1])) {\n        shape = this._findShape(children, v[0], v[1], ev);\n      }\n    } else {\n      shape = this._findShape(children, x, y, ev);\n    }\n    return shape;\n  }\n\n  _findShape(children: IElement[], x: number, y: number, ev: Event) {\n    let shape = null;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (isAllowCapture(child)) {\n        if (child.isGroup()) {\n          shape = (child as IGroup).getShape(x, y, ev);\n        } else if ((child as IShape).isHit(x, y)) {\n          shape = child;\n        }\n      }\n      if (shape) {\n        break;\n      }\n    }\n    return shape;\n  }\n\n  add(element: IElement) {\n    const canvas = this.getCanvas();\n    const children = this.getChildren();\n    const timeline = this.get('timeline');\n    const preParent = element.getParent();\n    if (preParent) {\n      removeChild(preParent, element, false);\n    }\n    element.set('parent', this);\n    if (canvas) {\n      setCanvas(element, canvas);\n    }\n    if (timeline) {\n      setTimeline(element, timeline);\n    }\n    children.push(element);\n    element.onCanvasChange('add');\n    this._applyElementMatrix(element);\n  }\n\n  // 将当前容器的矩阵应用到子元素\n  _applyElementMatrix(element) {\n    const totalMatrix = this.getTotalMatrix();\n    // 添加图形或者分组时，需要把当前图元的矩阵设置进去\n    if (totalMatrix) {\n      element.applyMatrix(totalMatrix);\n    }\n  }\n\n  getChildren(): IElement[] {\n    return this.get('children') as IElement[];\n  }\n\n  sort() {\n    const children = this.getChildren();\n    // 稳定排序\n    each(children, (child, index) => {\n      child[INDEX] = index;\n      return child;\n    });\n    children.sort(\n      getComparer((obj1, obj2) => {\n        return obj1.get('zIndex') - obj2.get('zIndex');\n      })\n    );\n    this.onCanvasChange('sort');\n  }\n\n  clear() {\n    this.set('clearing', true);\n    if (this.destroyed) {\n      return;\n    }\n    const children = this.getChildren();\n    for (let i = children.length - 1; i >= 0; i--) {\n      children[i].destroy(); // 销毁子元素\n    }\n    this.set('children', []);\n    this.onCanvasChange('clear');\n    this.set('clearing', false);\n  }\n\n  destroy() {\n    if (this.get('destroyed')) {\n      return;\n    }\n    this.clear();\n    super.destroy();\n  }\n\n  /**\n   * 获取第一个子元素\n   * @return {IElement} 第一个元素\n   */\n  getFirst(): IElement {\n    return this.getChildByIndex(0);\n  }\n\n  /**\n   * 获取最后一个子元素\n   * @return {IElement} 元素\n   */\n  getLast(): IElement {\n    const children = this.getChildren();\n    return this.getChildByIndex(children.length - 1);\n  }\n\n  /**\n   * 根据索引获取子元素\n   * @return {IElement} 第一个元素\n   */\n  getChildByIndex(index: number): IElement {\n    const children = this.getChildren();\n    return children[index];\n  }\n\n  /**\n   * 子元素的数量\n   * @return {number} 子元素数量\n   */\n  getCount(): number {\n    const children = this.getChildren();\n    return children.length;\n  }\n\n  /**\n   * 是否包含对应元素\n   * @param {IElement} element 元素\n   * @return {boolean}\n   */\n  contain(element: IElement): boolean {\n    const children = this.getChildren();\n    return children.indexOf(element) > -1;\n  }\n\n  /**\n   * 移除对应子元素\n   * @param {IElement} element 子元素\n   * @param {boolean} destroy 是否销毁子元素，默认为 true\n   */\n  removeChild(element: IElement, destroy = true) {\n    if (this.contain(element)) {\n      element.remove(destroy);\n    }\n  }\n\n  /**\n   * 查找所有匹配的元素\n   * @param  {ElementFilterFn}   fn  匹配函数\n   * @return {IElement[]} 元素数组\n   */\n  findAll(fn: ElementFilterFn): IElement[] {\n    let rst: IElement[] = [];\n    const children = this.getChildren();\n    each(children, (element: IElement) => {\n      if (fn(element)) {\n        rst.push(element);\n      }\n      if (element.isGroup()) {\n        rst = rst.concat((element as IGroup).findAll(fn));\n      }\n    });\n    return rst;\n  }\n\n  /**\n   * 查找元素，找到第一个返回\n   * @param  {ElementFilterFn} fn    匹配函数\n   * @return {IElement|null} 元素，可以为空\n   */\n  find(fn: ElementFilterFn): IElement {\n    let rst: IElement = null;\n    const children = this.getChildren();\n    each(children, (element: IElement) => {\n      if (fn(element)) {\n        rst = element;\n      } else if (element.isGroup()) {\n        rst = (element as IGroup).find(fn);\n      }\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  }\n\n  /**\n   * 根据 ID 查找元素\n   * @param {string} id 元素 id\n   * @return {IElement|null} 元素\n   */\n  findById(id: string): IElement {\n    return this.find((element) => {\n      return element.get('id') === id;\n    });\n  }\n\n  /**\n   * 该方法即将废弃，不建议使用\n   * 根据 className 查找元素\n   * TODO: 该方式定义暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除\n   * @param {string} className 元素 className\n   * @return {IElement | null} 元素\n   */\n  findByClassName(className: string): IElement {\n    return this.find((element) => {\n      return element.get('className') === className;\n    });\n  }\n\n  /**\n   * 根据 name 查找元素列表\n   * @param {string}      name 元素名称\n   * @return {IElement[]} 元素\n   */\n  findAllByName(name: string): IElement[] {\n    return this.findAll((element) => {\n      return element.get('name') === name;\n    });\n  }\n}\n\nexport default Container;\n","import { each, isEqual, isFunction, isNumber, isObject, isArray, noop, mix, upperFirst, uniqueId } from '@antv/util';\nimport { ext } from '@antv/matrix-util';\nimport { IElement, IShape, IGroup, ICanvas, ICtor } from '../interfaces';\nimport { ClipCfg, ChangeType, OnFrame, ShapeAttrs, AnimateCfg, Animation, BBox, ShapeBase } from '../types';\nimport { removeFromArray, isParent } from '../util/util';\nimport { multiplyMatrix, multiplyVec2, invert } from '../util/matrix';\nimport Base from './base';\nimport GraphEvent from '../event/graph-event';\n\nconst { transform } = ext;\n\nconst MATRIX = 'matrix';\nconst CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type'];\n\n// 可以在 toAttrs 中设置，但不属于绘图属性的字段\nconst RESERVED_PORPS = ['repeat'];\n\nconst DELEGATION_SPLIT = ':';\nconst WILDCARD = '*';\n\n// 需要考虑数组嵌套数组的场景\n// 数组嵌套对象的场景不考虑\nfunction _cloneArrayAttr(arr) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (isArray(arr[i])) {\n      result.push([].concat(arr[i]));\n    } else {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\nfunction getFormatFromAttrs(toAttrs, shape) {\n  const fromAttrs = {};\n  const attrs = shape.attrs;\n  for (const k in toAttrs) {\n    fromAttrs[k] = attrs[k];\n  }\n  return fromAttrs;\n}\n\nfunction getFormatToAttrs(props, shape) {\n  const toAttrs = {};\n  const attrs = shape.attr();\n  each(props, (v, k) => {\n    if (RESERVED_PORPS.indexOf(k) === -1 && !isEqual(attrs[k], v)) {\n      toAttrs[k] = v;\n    }\n  });\n  return toAttrs;\n}\n\nfunction checkExistedAttrs(animations: Animation[], animation: Animation) {\n  if (animation.onFrame) {\n    return animations;\n  }\n  const { startTime, delay, duration } = animation;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  each(animations, (item) => {\n    // 后一个动画开始执行的时间 < 前一个动画的结束时间 && 后一个动画的执行时间 > 前一个动画的延迟\n    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {\n      each(animation.toAttrs, (v, k) => {\n        if (hasOwnProperty.call(item.toAttrs, k)) {\n          delete item.toAttrs[k];\n          delete item.fromAttrs[k];\n        }\n      });\n    }\n  });\n\n  return animations;\n}\n\nabstract class Element extends Base implements IElement {\n  /**\n   * @protected\n   * 图形属性\n   * @type {ShapeAttrs}\n   */\n  attrs: ShapeAttrs = {};\n\n  constructor(cfg) {\n    super(cfg);\n    const attrs = this.getDefaultAttrs();\n    mix(attrs, cfg.attrs);\n    this.attrs = attrs;\n    this.initAttrs(attrs);\n    this.initAnimate(); // 初始化动画\n  }\n\n  // override\n  getDefaultCfg() {\n    return {\n      visible: true,\n      capture: true,\n      zIndex: 0,\n    };\n  }\n\n  /**\n   * @protected\n   * 获取默认的属相\n   */\n  getDefaultAttrs() {\n    return {\n      matrix: this.getDefaultMatrix(),\n      opacity: 1,\n    };\n  }\n\n  abstract getShapeBase(): ShapeBase;\n  abstract getGroupBase(): ICtor<IGroup>;\n\n  /**\n   * @protected\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  onCanvasChange(changeType: ChangeType) {}\n\n  /**\n   * @protected\n   * 初始化属性，有些属性需要加工\n   * @param {object} attrs 属性值\n   */\n  initAttrs(attrs: ShapeAttrs) {}\n\n  /**\n   * @protected\n   * 初始化动画\n   */\n  initAnimate() {\n    this.set('animable', true);\n    this.set('animating', false);\n  }\n\n  isGroup() {\n    return false;\n  }\n\n  getParent(): IGroup {\n    return this.get('parent');\n  }\n\n  getCanvas(): ICanvas {\n    return this.get('canvas');\n  }\n\n  attr(...args) {\n    const [name, value] = args;\n    if (!name) return this.attrs;\n    if (isObject(name)) {\n      for (const k in name) {\n        this.setAttr(k, name[k]);\n      }\n      this.afterAttrsChange(name);\n      return this;\n    }\n    if (args.length === 2) {\n      this.setAttr(name, value);\n      this.afterAttrsChange({\n        [name]: value,\n      });\n      return this;\n    }\n    return this.attrs[name];\n  }\n\n  // 在子类上单独实现\n  abstract getBBox(): BBox;\n  // 子类上单独实现\n  abstract getCanvasBBox(): BBox;\n\n  // 是否被裁剪，被裁剪则不显示，不参与拾取\n  isClipped(refX, refY): boolean {\n    const clip = this.getClip();\n    return clip && !clip.isHit(refX, refY);\n  }\n\n  /**\n   * 内部设置属性值的接口\n   * @param {string} name 属性名\n   * @param {any} value 属性值\n   */\n  setAttr(name: string, value: any) {\n    const originValue = this.attrs[name];\n    if (originValue !== value) {\n      this.attrs[name] = value;\n      this.onAttrChange(name, value, originValue);\n    }\n  }\n\n  /**\n   * @protected\n   * 属性值发生改变\n   * @param {string} name 属性名\n   * @param {any} value 属性值\n   * @param {any} originValue 属性值\n   */\n  onAttrChange(name: string, value: any, originValue: any) {\n    if (name === 'matrix') {\n      this.set('totalMatrix', null);\n    }\n  }\n\n  /**\n   * 属性更改后需要做的事情\n   * @protected\n   */\n  afterAttrsChange(targetAttrs) {\n    if (this.cfg.isClipShape) {\n      const applyTo = this.cfg.applyTo;\n      if (applyTo) {\n        applyTo.onCanvasChange('clip');\n      }\n    } else {\n      this.onCanvasChange('attr');\n    }\n  }\n\n  show() {\n    // 不是高频操作直接使用 set\n    this.set('visible', true);\n    this.onCanvasChange('show');\n    return this;\n  }\n\n  hide() {\n    // 不是高频操作直接使用 set\n    this.set('visible', false);\n    this.onCanvasChange('hide');\n    return this;\n  }\n\n  setZIndex(zIndex: number) {\n    this.set('zIndex', zIndex);\n    const parent = this.getParent();\n    if (parent) {\n      // 改变 zIndex 不应该立即触发渲染 (调用 onCanvasChange('zIndex'))，需要经过 sort 再触发\n      parent.sort();\n    }\n    return this;\n  }\n\n  toFront() {\n    const parent = this.getParent();\n    if (!parent) {\n      return;\n    }\n    const children = parent.getChildren();\n    const el = this.get('el');\n    const index = children.indexOf(this);\n    children.splice(index, 1);\n    children.push(this);\n    this.onCanvasChange('zIndex');\n  }\n\n  toBack() {\n    const parent = this.getParent();\n    if (!parent) {\n      return;\n    }\n    const children = parent.getChildren();\n    const el = this.get('el');\n    const index = children.indexOf(this);\n    children.splice(index, 1);\n    children.unshift(this);\n    this.onCanvasChange('zIndex');\n  }\n\n  remove(destroy = true) {\n    const parent = this.getParent();\n    if (parent) {\n      removeFromArray(parent.getChildren(), this);\n      if (!parent.get('clearing')) {\n        // 如果父元素正在清理，当前元素不触发 remove\n        this.onCanvasChange('remove');\n      }\n    } else {\n      this.onCanvasChange('remove');\n    }\n    if (destroy) {\n      this.destroy();\n    }\n  }\n\n  resetMatrix() {\n    this.attr(MATRIX, this.getDefaultMatrix());\n    this.onCanvasChange('matrix');\n  }\n\n  getMatrix(): number[] {\n    return this.attr(MATRIX);\n  }\n\n  setMatrix(m: number[]) {\n    this.attr(MATRIX, m);\n    this.onCanvasChange('matrix');\n  }\n\n  // 获取总的 matrix\n  getTotalMatrix() {\n    let totalMatrix = this.cfg.totalMatrix;\n    if (!totalMatrix) {\n      const currentMatrix = this.attr('matrix');\n      const parentMatrix = this.cfg.parentMatrix;\n      if (parentMatrix && currentMatrix) {\n        totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);\n      } else {\n        totalMatrix = currentMatrix || parentMatrix;\n      }\n      this.set('totalMatrix', totalMatrix);\n    }\n    return totalMatrix;\n  }\n\n  // 上层分组设置 matrix\n  applyMatrix(matrix: number[]) {\n    const currentMatrix = this.attr('matrix');\n    let totalMatrix = null;\n    if (matrix && currentMatrix) {\n      totalMatrix = multiplyMatrix(matrix, currentMatrix);\n    } else {\n      totalMatrix = currentMatrix || matrix;\n    }\n    this.set('totalMatrix', totalMatrix);\n    this.set('parentMatrix', matrix);\n  }\n\n  /**\n   * @protected\n   * 获取默认的矩阵\n   * @returns {number[]|null} 默认的矩阵\n   */\n  getDefaultMatrix() {\n    return null;\n  }\n\n  // 将向量应用设置的矩阵\n  applyToMatrix(v: number[]): number[] {\n    const matrix = this.attr('matrix');\n    if (matrix) {\n      return multiplyVec2(matrix, v);\n    }\n    return v;\n  }\n\n  // 根据设置的矩阵，将向量转换相对于图形/分组的位置\n  invertFromMatrix(v: number[]): number[] {\n    const matrix = this.attr('matrix');\n    if (matrix) {\n      const invertMatrix = invert(matrix);\n      if (invertMatrix) {\n        return multiplyVec2(invertMatrix, v);\n      }\n    }\n    return v;\n  }\n\n  // 设置 clip\n  setClip(clipCfg: ClipCfg) {\n    const canvas = this.getCanvas();\n    // 应该只设置当前元素的 clip，不应该去修改 clip 本身，方便 clip 被复用\n    // TODO: setClip 的传参既 shape 配置，也支持 shape 对象\n    // const preShape = this.get('clipShape');\n    // if (preShape) {\n    //   // 将之前的 clipShape 销毁\n    //   preShape.destroy();\n    // }\n    let clipShape = null;\n    // 如果配置项为 null，则不移除 clipShape\n    if (clipCfg) {\n      const ShapeBase = this.getShapeBase();\n      const shapeType = upperFirst(clipCfg.type);\n      const Cons = ShapeBase[shapeType];\n      if (Cons) {\n        clipShape = new Cons({\n          type: clipCfg.type,\n          isClipShape: true, // 增加一个标记\n          applyTo: this,\n          attrs: clipCfg.attrs,\n          canvas, // 设置 canvas\n        });\n      }\n    }\n\n    this.set('clipShape', clipShape);\n    this.onCanvasChange('clip');\n    return clipShape;\n  }\n\n  getClip(): IShape {\n    // 高频率调用的地方直接使用 this.cfg.xxx\n    const clipShape = this.cfg.clipShape;\n    // 未设置时返回 Null，保证一致性\n    if (!clipShape) {\n      return null;\n    }\n    return clipShape;\n  }\n\n  clone() {\n    const originAttrs = this.attrs;\n    const attrs = {};\n    each(originAttrs, (i, k) => {\n      if (isArray(originAttrs[k])) {\n        attrs[k] = _cloneArrayAttr(originAttrs[k]);\n      } else {\n        attrs[k] = originAttrs[k];\n      }\n    });\n    const cons = this.constructor;\n    // @ts-ignore\n    const clone = new cons({ attrs });\n    each(CLONE_CFGS, (cfgName) => {\n      clone.set(cfgName, this.get(cfgName));\n    });\n    return clone;\n  }\n\n  destroy() {\n    const destroyed = this.destroyed;\n    if (destroyed) {\n      return;\n    }\n    this.attrs = {};\n    super.destroy();\n    // this.onCanvasChange('destroy');\n  }\n\n  /**\n   * 是否处于动画暂停状态\n   * @return {boolean} 是否处于动画暂停状态\n   */\n  isAnimatePaused() {\n    return this.get('_pause').isPaused;\n  }\n\n  /**\n   * 执行动画，支持多种函数签名\n   * 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)\n   * 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)\n   * 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)\n   * 4. animate(onFrame: OnFrame, cfg: AnimateCfg)\n   * 各个参数的含义为:\n   *   toAttrs  动画最终状态\n   *   onFrame  自定义帧动画函数\n   *   duration 动画执行时间\n   *   easing   动画缓动效果\n   *   callback 动画执行后的回调\n   *   delay    动画延迟时间\n   */\n  animate(...args) {\n    if (!this.get('timeline') && !this.get('canvas')) {\n      return;\n    }\n    this.set('animating', true);\n    let timeline = this.get('timeline');\n    if (!timeline) {\n      timeline = this.get('canvas').get('timeline');\n      this.set('timeline', timeline);\n    }\n    let animations = this.get('animations') || [];\n    // 初始化 tick\n    if (!timeline.timer) {\n      timeline.initTimer();\n    }\n    let [toAttrs, duration, easing = 'easeLinear', callback = noop, delay = 0] = args;\n    let onFrame: OnFrame;\n    let repeat: boolean;\n    let pauseCallback;\n    let resumeCallback;\n    let animateCfg: AnimateCfg;\n    // 第二个参数，既可以是动画最终状态 toAttrs，也可以是自定义帧动画函数 onFrame\n    if (isFunction(toAttrs)) {\n      onFrame = toAttrs as OnFrame;\n      toAttrs = {};\n    } else if (isObject(toAttrs) && (toAttrs as any).onFrame) {\n      // 兼容 3.0 中的写法，onFrame 和 repeat 可在 toAttrs 中设置\n      onFrame = (toAttrs as any).onFrame as OnFrame;\n      repeat = (toAttrs as any).repeat;\n    }\n    // 第二个参数，既可以是执行时间 duration，也可以是动画参数 animateCfg\n    if (isObject(duration)) {\n      animateCfg = duration as AnimateCfg;\n      duration = animateCfg.duration;\n      easing = animateCfg.easing || 'easeLinear';\n      delay = animateCfg.delay || 0;\n      // animateCfg 中的设置优先级更高\n      repeat = animateCfg.repeat || repeat || false;\n      callback = animateCfg.callback || noop;\n      pauseCallback = animateCfg.pauseCallback || noop;\n      resumeCallback = animateCfg.resumeCallback || noop;\n    } else {\n      // 第四个参数，既可以是回调函数 callback，也可以是延迟时间 delay\n      if (isNumber(callback)) {\n        delay = callback;\n        callback = null;\n      }\n      // 第三个参数，既可以是缓动参数 easing，也可以是回调函数 callback\n      if (isFunction(easing)) {\n        callback = easing;\n        easing = 'easeLinear';\n      } else {\n        easing = easing || 'easeLinear';\n      }\n    }\n    const formatToAttrs = getFormatToAttrs(toAttrs, this);\n    const animation: Animation = {\n      fromAttrs: getFormatFromAttrs(formatToAttrs, this),\n      toAttrs: formatToAttrs,\n      duration,\n      easing,\n      repeat,\n      callback,\n      pauseCallback,\n      resumeCallback,\n      delay,\n      startTime: timeline.getTime(),\n      id: uniqueId(),\n      onFrame,\n      pathFormatted: false,\n    };\n    // 如果动画元素队列中已经有这个图形了\n    if (animations.length > 0) {\n      // 先检查是否需要合并属性。若有相同的动画，将该属性从前一个动画中删除,直接用后一个动画中\n      animations = checkExistedAttrs(animations, animation);\n    } else {\n      // 否则将图形添加到动画元素队列\n      timeline.addAnimator(this);\n    }\n    animations.push(animation);\n    this.set('animations', animations);\n    this.set('_pause', { isPaused: false });\n  }\n\n  /**\n   * 停止动画\n   * @param {boolean} toEnd 是否到动画的最终状态\n   */\n  stopAnimate(toEnd = true) {\n    const animations = this.get('animations');\n    each(animations, (animation: Animation) => {\n      // 将动画执行到最后一帧\n      if (toEnd) {\n        if (animation.onFrame) {\n          this.attr(animation.onFrame(1));\n        } else {\n          this.attr(animation.toAttrs);\n        }\n      }\n      if (animation.callback) {\n        // 动画停止时的回调\n        animation.callback();\n      }\n    });\n    this.set('animating', false);\n    this.set('animations', []);\n  }\n\n  /**\n   * 暂停动画\n   */\n  pauseAnimate() {\n    const timeline = this.get('timeline');\n    const animations = this.get('animations');\n    const pauseTime = timeline.getTime();\n    each(animations, (animation: Animation) => {\n      animation._paused = true;\n      animation._pauseTime = pauseTime;\n      if (animation.pauseCallback) {\n        // 动画暂停时的回调\n        animation.pauseCallback();\n      }\n    });\n    // 记录下是在什么时候暂停的\n    this.set('_pause', {\n      isPaused: true,\n      pauseTime,\n    });\n    return this;\n  }\n\n  /**\n   * 恢复动画\n   */\n  resumeAnimate() {\n    const timeline = this.get('timeline');\n    const current = timeline.getTime();\n    const animations = this.get('animations');\n    const pauseTime = this.get('_pause').pauseTime;\n    // 之后更新属性需要计算动画已经执行的时长，如果暂停了，就把初始时间调后\n    each(animations, (animation: Animation) => {\n      animation.startTime = animation.startTime + (current - pauseTime);\n      animation._paused = false;\n      animation._pauseTime = null;\n      if (animation.resumeCallback) {\n        animation.resumeCallback();\n      }\n    });\n    this.set('_pause', {\n      isPaused: false,\n    });\n    this.set('animations', animations);\n    return this;\n  }\n\n  /**\n   * 触发委托事件\n   * @param  {string}     type 事件类型\n   * @param  {GraphEvent} eventObj 事件对象\n   */\n  emitDelegation(type: string, eventObj: GraphEvent) {\n    const paths = eventObj.propagationPath;\n    const events = this.getEvents();\n    let relativeShape;\n    if (type === 'mouseenter') {\n      relativeShape = eventObj.fromShape;\n    } else if (type === 'mouseleave') {\n      relativeShape = eventObj.toShape;\n    }\n    // 至少有一个对象，且第一个对象为 shape\n    for (let i = 0; i < paths.length; i++) {\n      const element = paths[i];\n      // 暂定跟 name 绑定\n      const name = element.get('name');\n      if (name) {\n        // 第一个 mouseenter 和 mouseleave 的停止即可，因为后面的都是前面的 Parent\n        if (\n          // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent\n          (element.isGroup() || (element.isCanvas && element.isCanvas())) &&\n          relativeShape &&\n          isParent(element, relativeShape)\n        ) {\n          break;\n        }\n        if (isArray(name)) {\n          each(name, (subName) => {\n            this.emitDelegateEvent(element, subName, eventObj);\n          });\n        } else {\n          this.emitDelegateEvent(element, name, eventObj);\n        }\n      }\n    }\n  }\n\n  private emitDelegateEvent(element, name: string, eventObj: GraphEvent) {\n    const events = this.getEvents();\n    // 事件委托的形式 name:type\n    const eventName = name + DELEGATION_SPLIT + eventObj.type;\n    if (events[eventName] || events[WILDCARD]) {\n      // 对于通配符 *，事件名称 = 委托事件名称\n      eventObj.name = eventName;\n      eventObj.currentTarget = element;\n      eventObj.delegateTarget = this;\n      // 将委托事件的监听对象 delegateObject 挂载到事件对象上\n      eventObj.delegateObject = element.get('delegateObject');\n      this.emit(eventName, eventObj);\n    }\n  }\n\n  /**\n   * 移动元素\n   * @param {number} translateX 水平移动距离\n   * @param {number} translateY 垂直移动距离\n   * @return {IElement} 元素\n   */\n  translate(translateX: number = 0, translateY: number = 0) {\n    const matrix = this.getMatrix();\n    const newMatrix = transform(matrix, [['t', translateX, translateY]]);\n    this.setMatrix(newMatrix);\n    return this;\n  }\n\n  /**\n   * 移动元素到目标位置\n   * @param {number} targetX 目标位置的水平坐标\n   * @param {number} targetX 目标位置的垂直坐标\n   * @return {IElement} 元素\n   */\n  move(targetX: number, targetY: number) {\n    const x = this.attr('x') || 0;\n    const y = this.attr('y') || 0;\n    this.translate(targetX - x, targetY - y);\n    return this;\n  }\n\n  /**\n   * 移动元素到目标位置，等价于 move 方法。由于 moveTo 的语义性更强，因此在文档中推荐使用 moveTo 方法\n   * @param {number} targetX 目标位置的 x 轴坐标\n   * @param {number} targetY 目标位置的 y 轴坐标\n   * @return {IElement} 元素\n   */\n  moveTo(targetX: number, targetY: number) {\n    return this.move(targetX, targetY);\n  }\n\n  /**\n   * 缩放元素\n   * @param {number} ratioX 水平缩放比例\n   * @param {number} ratioY 垂直缩放比例\n   * @return {IElement} 元素\n   */\n  scale(ratioX: number, ratioY?: number) {\n    const matrix = this.getMatrix();\n    const newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);\n    this.setMatrix(newMatrix);\n    return this;\n  }\n\n  /**\n   * 以画布左上角 (0, 0) 为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n  rotate(radian: number) {\n    const matrix = this.getMatrix();\n    const newMatrix = transform(matrix, [['r', radian]]);\n    this.setMatrix(newMatrix);\n    return this;\n  }\n\n  /**\n   * 以起始点为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n  rotateAtStart(rotate: number): IElement {\n    const { x, y } = this.attr();\n    const matrix = this.getMatrix();\n    const newMatrix = transform(matrix, [\n      ['t', -x, -y],\n      ['r', rotate],\n      ['t', x, y],\n    ]);\n    this.setMatrix(newMatrix);\n    return this;\n  }\n\n  /**\n   * 以任意点 (x, y) 为中心旋转元素\n   * @param {number} radian 旋转角度(弧度值)\n   * @return {IElement} 元素\n   */\n  rotateAtPoint(x: number, y: number, rotate: number): IElement {\n    const matrix = this.getMatrix();\n    const newMatrix = transform(matrix, [\n      ['t', -x, -y],\n      ['r', rotate],\n      ['t', x, y],\n    ]);\n    this.setMatrix(newMatrix);\n    return this;\n  }\n}\n\nexport default Element;\n","import { IGroup } from '../interfaces';\nimport Container from './container';\n\nabstract class AbstractGroup extends Container implements IGroup {\n  isGroup() {\n    return true;\n  }\n\n  isEntityGroup() {\n    return false;\n  }\n\n  clone() {\n    const clone = super.clone();\n    // 获取构造函数\n    const children = this.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      clone.add(child.clone());\n    }\n    return clone;\n  }\n}\n\nexport default AbstractGroup;\n","import { IShape } from '../interfaces';\nimport { ShapeCfg, ShapeAttrs, BBox } from '../types';\nimport Element from './element';\nimport { multiplyVec2 } from '../util/matrix';\nabstract class AbstractShape extends Element implements IShape {\n  constructor(cfg: ShapeCfg) {\n    super(cfg);\n  }\n\n  // 是否在包围盒内\n  _isInBBox(refX, refY): boolean {\n    const bbox = this.getBBox();\n    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;\n  }\n\n  /**\n   * 属性更改后需要做的事情\n   * @protected\n   * @param {ShapeAttrs} targetAttrs 渲染的图像属性\n   */\n  afterAttrsChange(targetAttrs: ShapeAttrs) {\n    super.afterAttrsChange(targetAttrs);\n    this.clearCacheBBox();\n  }\n  // 计算包围盒时，需要缓存，这是一个高频的操作\n  getBBox(): BBox {\n    let bbox = this.cfg.bbox;\n    if (!bbox) {\n      bbox = this.calculateBBox();\n      this.set('bbox', bbox);\n    }\n    return bbox;\n  }\n  // 计算相对于画布的包围盒\n  getCanvasBBox(): BBox {\n    let canvasBBox = this.cfg.canvasBBox;\n    if (!canvasBBox) {\n      canvasBBox = this.calculateCanvasBBox();\n      this.set('canvasBBox', canvasBBox);\n    }\n    return canvasBBox;\n  }\n\n  /**\n   * 计算包围盒的抽象方法\n   * @return {BBox} 包围盒\n   */\n  abstract calculateBBox(): BBox;\n\n  applyMatrix(matrix: number[]) {\n    super.applyMatrix(matrix);\n    // 清理掉缓存的包围盒\n    this.set('canvasBBox', null);\n  }\n\n  /**\n   * 计算相对于画布的包围盒，默认等同于 bbox\n   * @return {BBox} 包围盒\n   */\n  calculateCanvasBBox() {\n    const bbox = this.getBBox();\n    const totalMatrix = this.getTotalMatrix();\n    let { minX, minY, maxX, maxY } = bbox;\n    if (totalMatrix) {\n      const topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);\n      const topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);\n      const bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);\n      const bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);\n      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\n      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n      maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\n    }\n    const attrs = this.attrs;\n    // 如果存在 shadow 则计算 shadow\n    if (attrs.shadowColor) {\n      const { shadowBlur = 0, shadowOffsetX = 0, shadowOffsetY = 0 } = attrs;\n      const shadowLeft = minX - shadowBlur + shadowOffsetX;\n      const shadowRight = maxX + shadowBlur + shadowOffsetX;\n      const shadowTop = minY - shadowBlur + shadowOffsetY;\n      const shadowBottom = maxY + shadowBlur + shadowOffsetY;\n      minX = Math.min(minX, shadowLeft);\n      maxX = Math.max(maxX, shadowRight);\n      minY = Math.min(minY, shadowTop);\n      maxY = Math.max(maxY, shadowBottom);\n    }\n    return {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n\n  /**\n   * @protected\n   * 清理缓存的 bbox\n   */\n  clearCacheBBox() {\n    this.set('bbox', null);\n    this.set('canvasBBox', null);\n  }\n\n  // 实现接口\n  isClipShape() {\n    return this.get('isClipShape');\n  }\n\n  /**\n   * @protected\n   * 不同的图形自己实现是否在图形内部的逻辑，要判断边和填充区域\n   * @param  {number}  refX 相对于图形的坐标 x\n   * @param  {number}  refY 相对于图形的坐标 Y\n   * @return {boolean} 点是否在图形内部\n   */\n  isInShape(refX: number, refY: number): boolean {\n    return false;\n  }\n\n  /**\n   * 是否仅仅使用 BBox 检测就可以判定拾取到图形\n   * 默认是 false，但是有些图形例如 image、marker 等都可直接使用 BBox 的检测而不需要使用图形拾取\n   * @return {Boolean} 仅仅使用 BBox 进行拾取\n   */\n  isOnlyHitBox() {\n    return false;\n  }\n\n  // 不同的 Shape 各自实现\n  isHit(x: number, y: number): boolean {\n    const startArrowShape = this.get('startArrowShape');\n    const endArrowShape = this.get('endArrowShape');\n    let vec = [x, y, 1];\n    vec = this.invertFromMatrix(vec);\n    const [refX, refY] = vec;\n    const inBBox = this._isInBBox(refX, refY);\n    // 跳过图形的拾取，在某些图形中可以省略一倍的检测成本\n    if (this.isOnlyHitBox()) {\n      return inBBox;\n    }\n    // 被裁减掉的和不在包围盒内的不进行计算\n    if (inBBox && !this.isClipped(refX, refY)) {\n      // 对图形进行拾取判断\n      if (this.isInShape(refX, refY)) {\n        return true;\n      }\n      // 对起始箭头进行拾取判断\n      if (startArrowShape && startArrowShape.isHit(refX, refY)) {\n        return true;\n      }\n      // 对结束箭头进行拾取判断\n      if (endArrowShape && endArrowShape.isHit(refX, refY)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport default AbstractShape;\n"],"names":["addEventListener","target","eventType","callback","remove","removeEventListener","attachEvent","detachEvent","TABLE","TABLE_TR","FRAGMENT_REG","CONTAINERS","createDom","str","document","createElement","tr","tbody","thead","tfoot","td","th","name","test","RegExp","$1","container","replace","innerHTML","dom","childNodes","contains","removeChild","getOuterHeight","el","defaultValue","height","getStyle","offsetHeight","parseFloat","getHeight","bTop","pTop","pBottom","getOuterWidth","width","offsetWidth","getWidth","bLeft","pLeft","pRight","bRight","mRight","v","window","getComputedStyle","style","e","undefined","modifyCSS","css","key","hasOwnProperty","_events","EventEmitter","evt","once","this","push","on","args","events","wildcardEvents","doEmit","es","length","i","splice","_this","apply","length_1","cfg","_super","defaultCfg","getDefaultCfg","mix","__extends","Base","value","destroyed","off","EE","browser","detect","isFirefox","initContainer","initDom","initEvents","initTimeline","Canvas","call","get","isString","getElementById","set","appendChild","setDOMSize","eventController","EventController","canvas","init","timeline","Timeline","isBrowser","onCanvasChange","cursor","ev","isNil","layerX","offsetX","x","y","layerY","offsetY","getClientByEvent","clientX","clientY","getPointByClient","clientInfo","touches","type","changedTouches","bbox","getBoundingClientRect","left","top","parentNode","destroy","clear","stop","clearEvents","removeDom","Container","SHAPE_MAP","setCanvas","element","isGroup","children","forEach","child","setTimeline","minX","Infinity","maxX","minY","maxY","getChildren","filter","each","getBBox","childMinX","childMaxX","childMinY","childMaxY","getCanvasBBox","originValue","onAttrChange","totalMatrix","getTotalMatrix","_applyChildrenMarix","matrix","preTotalMatrix","applyMatrix","isObject","shapeType","upperFirst","ShapeBase","getShapeBase","shape","add","group","groupClass","isFunction","parent","tmpCfg","TmpGroupClass","getGroupBase","isCanvas","isAllowCapture","_findShape","invertFromMatrix","isClipped","getShape","isHit","getCanvas","preParent","getParent","removeFromArray","_applyElementMatrix","compare","index","sort","obj1","obj2","right","result","getChildByIndex","indexOf","contain","fn","rst","concat","findAll","find","id","className","Element","transform","ext","MATRIX","CLONE_CFGS","RESERVED_PORPS","getFormatFromAttrs","toAttrs","fromAttrs","attrs","k","getFormatToAttrs","props","attr","isEqual","checkExistedAttrs","animations","animation","onFrame","startTime","delay","duration","Object","prototype","item","getDefaultAttrs","initAttrs","initAnimate","visible","capture","zIndex","getDefaultMatrix","opacity","changeType","setAttr","afterAttrsChange","_a","refX","refY","clip","getClip","targetAttrs","isClipShape","applyTo","unshift","m","currentMatrix","parentMatrix","multiplyMatrix","multiplyVec2","invertMatrix","invert","clipCfg","clipShape","Cons","originAttrs","isArray","arr","_cloneArrayAttr","clone","cons","constructor","cfgName","isPaused","timer","initTimer","repeat","pauseCallback","resumeCallback","animateCfg","easing","_b","noop","_c","isNumber","formatToAttrs","getTime","uniqueId","pathFormatted","addAnimator","toEnd","pauseTime","_paused","_pauseTime","current","eventObj","relativeShape","paths","propagationPath","getEvents","fromShape","toShape","name_1","isParent","subName","emitDelegateEvent","this_1","eventName","currentTarget","delegateTarget","delegateObject","emit","translateX","translateY","getMatrix","newMatrix","setMatrix","targetX","targetY","translate","move","ratioX","ratioY","radian","rotate","AbstractGroup","AbstractShape","clearCacheBBox","calculateBBox","canvasBBox","calculateCanvasBBox","topLeft","topRight","bottomLeft","bottomRight","Math","min","max","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","shadowLeft","shadowRight","shadowTop","shadowBottom","startArrowShape","endArrowShape","vec","inBBox","_isInBBox","isOnlyHitBox","isInShape"],"sourceRoot":""}