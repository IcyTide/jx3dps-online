{"version":3,"file":"static/js/5736.64e9f349.js","mappings":"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","sources":["../node_modules/@antv/g-canvas/src/canvas.ts","../node_modules/@antv/g-canvas/src/group.ts","../node_modules/@antv/g-canvas/src/index.ts","../node_modules/@antv/g-canvas/src/shape/base.ts","../node_modules/@antv/g-canvas/src/shape/circle.ts","../node_modules/@antv/g-canvas/src/shape/ellipse.ts","../node_modules/@antv/g-canvas/src/shape/image.ts","../node_modules/@antv/g-canvas/src/shape/line.ts","../node_modules/@antv/g-canvas/src/shape/marker.ts","../node_modules/@antv/g-canvas/src/shape/path.ts","../node_modules/@antv/g-canvas/src/shape/polygon.ts","../node_modules/@antv/g-canvas/src/shape/polyline.ts","../node_modules/@antv/g-canvas/src/shape/rect.ts","../node_modules/@antv/g-canvas/src/shape/text.ts"],"sourcesContent":["import { AbstractCanvas } from '@antv/g-base';\nimport { ChangeType } from '@antv/g-base';\nimport { IElement } from './interfaces';\nimport { getShape } from './util/hit';\nimport * as Shape from './shape';\nimport Group from './group';\nimport { each, getPixelRatio, requestAnimationFrame, clearAnimationFrame } from './util/util';\nimport { applyAttrsToContext, drawChildren, getMergedRegion, mergeView, checkRefresh, clearChanged } from './util/draw';\n\nclass Canvas extends AbstractCanvas {\n  getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    // 设置渲染引擎为 canvas，只读属性\n    cfg['renderer'] = 'canvas';\n    // 是否自动绘制，不需要用户调用 draw 方法\n    cfg['autoDraw'] = true;\n    // 是否允许局部刷新图表\n    cfg['localRefresh'] = true;\n    cfg['refreshElements'] = [];\n    // 是否在视图内自动裁剪\n    cfg['clipView'] = true;\n    // 是否使用快速拾取的方案，默认为 false，上层可以打开\n    cfg['quickHit'] = false;\n    return cfg;\n  }\n\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  onCanvasChange(changeType: ChangeType) {\n    /**\n     * 触发画布更新的三种 changeType\n     * 1. attr: 修改画布的绘图属性\n     * 2. sort: 画布排序，图形的层次会发生变化\n     * 3. changeSize: 改变画布大小\n     */\n    if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {\n      this.set('refreshElements', [this]);\n      this.draw();\n    }\n  }\n\n  getShapeBase() {\n    return Shape;\n  }\n\n  getGroupBase() {\n    return Group;\n  }\n  /**\n   * 获取屏幕像素比\n   */\n  getPixelRatio() {\n    const pixelRatio = this.get('pixelRatio') || getPixelRatio();\n    // 不足 1 的取 1，超出 1 的取整\n    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;\n  }\n\n  getViewRange() {\n    return {\n      minX: 0,\n      minY: 0,\n      maxX: this.cfg.width,\n      maxY: this.cfg.height,\n    };\n  }\n\n  // 复写基类的方法生成标签\n  createDom(): HTMLElement {\n    const element = document.createElement('canvas');\n    const context = element.getContext('2d');\n    // 缓存 context 对象\n    this.set('context', context);\n    return element;\n  }\n  setDOMSize(width: number, height: number) {\n    super.setDOMSize(width, height);\n    const context = this.get('context');\n    const el = this.get('el');\n    const pixelRatio = this.getPixelRatio();\n    el.width = pixelRatio * width;\n    el.height = pixelRatio * height;\n    // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\n    if (pixelRatio > 1) {\n      context.scale(pixelRatio, pixelRatio);\n    }\n  }\n  // 复写基类方法\n  clear() {\n    super.clear();\n    this._clearFrame(); // 需要清理掉延迟绘制的帧\n    const context = this.get('context');\n    const element = this.get('el');\n    context.clearRect(0, 0, element.width, element.height);\n  }\n\n  getShape(x: number, y: number) {\n    let shape;\n    if (this.get('quickHit')) {\n      shape = getShape(this, x, y);\n    } else {\n      shape = super.getShape(x, y, null);\n    }\n    return shape;\n  }\n  // 对绘制区域边缘取整，避免浮点数问题\n  _getRefreshRegion() {\n    const elements = this.get('refreshElements');\n    const viewRegion = this.getViewRange();\n    let region;\n    // 如果是当前画布整体发生了变化，则直接重绘整个画布\n    if (elements.length && elements[0] === this) {\n      region = viewRegion;\n    } else {\n      region = getMergedRegion(elements);\n      if (region) {\n        region.minX = Math.floor(region.minX);\n        region.minY = Math.floor(region.minY);\n        region.maxX = Math.ceil(region.maxX);\n        region.maxY = Math.ceil(region.maxY);\n        region.maxY += 1; // 在很多环境下字体的高低会不一致，附加一像素，避免残影\n        const clipView = this.get('clipView');\n        // 自动裁剪不在 view 内的区域\n        if (clipView) {\n          region = mergeView(region, viewRegion);\n        }\n      }\n    }\n    return region;\n  }\n\n  /**\n   * 刷新图形元素，这里仅仅是放入队列，下次绘制时进行绘制\n   * @param {IElement} element 图形元素\n   */\n  refreshElement(element: IElement) {\n    const refreshElements = this.get('refreshElements');\n    refreshElements.push(element);\n    // if (this.get('autoDraw')) {\n    //   this._startDraw();\n    // }\n  }\n  // 清理还在进行的绘制\n  _clearFrame() {\n    const drawFrame = this.get('drawFrame');\n    if (drawFrame) {\n      // 如果全部渲染时，存在局部渲染，则抛弃掉局部渲染\n      clearAnimationFrame(drawFrame);\n      this.set('drawFrame', null);\n      this.set('refreshElements', []);\n    }\n  }\n\n  // 手工调用绘制接口\n  draw() {\n    const drawFrame = this.get('drawFrame');\n    if (this.get('autoDraw') && drawFrame) {\n      return;\n    }\n    this._startDraw();\n  }\n  // 绘制所有图形\n  _drawAll() {\n    const context = this.get('context');\n    const element = this.get('el');\n    const children = this.getChildren() as IElement[];\n    context.clearRect(0, 0, element.width, element.height);\n    applyAttrsToContext(context, this);\n    drawChildren(context, children);\n    // 对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也会记录更新的元素队列，因此全局渲染完后也需要置空\n    this.set('refreshElements', []);\n  }\n  // 绘制局部\n  _drawRegion() {\n    const context = this.get('context');\n    const refreshElements = this.get('refreshElements');\n    const children = this.getChildren() as IElement[];\n    const region = this._getRefreshRegion();\n    // 需要注意可能没有 region 的场景\n    // 一般发生在设置了 localRefresh ,在没有图形发生变化的情况下，用户调用了 draw\n    if (region) {\n      // 清理指定区域\n      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n      // 保存上下文，设置 clip\n      context.save();\n      context.beginPath();\n      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\n      context.clip();\n      applyAttrsToContext(context, this);\n      // 确认更新的元素，这个优化可以提升 10 倍左右的性能，10W 个带有 group 的节点，局部渲染会从 90ms 下降到 5-6 ms\n      checkRefresh(this, children, region);\n      // 绘制子元素\n      drawChildren(context, children, region);\n      context.restore();\n    } else if (refreshElements.length) {\n      // 防止发生改变的 elements 没有 region 的场景，这会发生在多个情况下\n      // 1. 空的 group\n      // 2. 所有 elements 没有在绘图区域\n      // 3. group 下面的 elements 隐藏掉\n      // 如果不进行清理 hasChanged 的状态会不正确\n      clearChanged(refreshElements);\n    }\n    each(refreshElements, (element) => {\n      if (element.get('hasChanged')) {\n        // 在视窗外的 Group 元素会加入到更新队列里，但实际却没有执行 draw() 逻辑，也就没有清除 hasChanged 标记\n        // 即已经重绘完、但 hasChanged 标记没有清除的元素，需要统一清除掉。主要是 Group 存在问题，具体原因待排查\n        element.set('hasChanged', false);\n      }\n    });\n    this.set('refreshElements', []);\n  }\n\n  // 触发绘制\n  _startDraw() {\n    let drawFrame = this.get('drawFrame');\n    if (!drawFrame) {\n      drawFrame = requestAnimationFrame(() => {\n        if (this.get('localRefresh')) {\n          this._drawRegion();\n        } else {\n          this._drawAll();\n        }\n        this.set('drawFrame', null);\n      });\n      this.set('drawFrame', drawFrame);\n    }\n  }\n\n  skipDraw() {}\n\n  removeDom() {\n    const el = this.get('el');\n    // 需要清理 canvas 画布内容，否则ios下 创建的canvas垃圾未回收，导致Total canvas memory use exceeds问题\n    // 相关问题列表\n    // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n    // https://github.com/openlayers/openlayers/issues/9291\n    el.width = 0;\n    el.height = 0;\n    el.parentNode.removeChild(el);\n  }\n}\n\nexport default Canvas;\n","import { AbstractGroup } from '@antv/g-base';\nimport { ChangeType } from '@antv/g-base';\nimport { IElement } from './interfaces';\nimport { Region } from './types';\nimport ShapeBase from './shape/base';\nimport * as Shape from './shape';\nimport { applyAttrsToContext, drawChildren, refreshElement } from './util/draw';\nimport { each, max, min } from '@antv/util';\nimport { intersectRect } from './util/util';\n\nclass Group extends AbstractGroup {\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  onCanvasChange(changeType: ChangeType) {\n    refreshElement(this, changeType);\n  }\n\n  getShapeBase() {\n    return Shape;\n  }\n\n  getGroupBase() {\n    return Group;\n  }\n\n  // 同 shape 中的方法重复了\n  _applyClip(context, clip: ShapeBase) {\n    if (clip) {\n      context.save();\n      // 将 clip 的属性挂载到 context 上\n      applyAttrsToContext(context, clip);\n      // 绘制 clip 路径\n      clip.createPath(context);\n      context.restore();\n      // 裁剪\n      context.clip();\n      clip._afterDraw();\n    }\n  }\n\n  // 这个方法以前直接使用的 getCanvasBBox，由于 group 上没有缓存，所以每次重新计算，导致性能开销比较大\n  // 大概能够节省全局渲染 15-20% 的性能，如果不在这里加缓存优化后 10W 个节点无法达到 5-6 ms，大概能够 30-40ms\n  private cacheCanvasBBox() {\n    const children = this.cfg.children;\n    const xArr = [];\n    const yArr = [];\n    each(children, (child) => {\n      const bbox = child.cfg.cacheCanvasBBox;\n      // isInview 的判定是一旦图形或者分组渲染就要计算是否在视图内，\n      // 这个判定 10W 个图形下差不多能够节省 5-6 ms 的开销\n      if (bbox && child.cfg.isInView) {\n        xArr.push(bbox.minX, bbox.maxX);\n        yArr.push(bbox.minY, bbox.maxY);\n      }\n    });\n    let bbox = null;\n    if (xArr.length) {\n      const minX = min(xArr);\n      const maxX = max(xArr);\n      const minY = min(yArr);\n      const maxY = max(yArr);\n      bbox = {\n        minX,\n        minY,\n        x: minX,\n        y: minY,\n        maxX,\n        maxY,\n        width: maxX - minX,\n        height: maxY - minY,\n      };\n      const canvas = this.cfg.canvas;\n      if (canvas) {\n        const viewRange = canvas.getViewRange();\n        // 如果这个地方判定 isInView == false 设置 bbox 为 false 的话，拾取的性能会更高\n        // 但是目前 10W 图形的拾取在 2-5ms 内，这个优化意义不大，可以后期观察再看\n        this.set('isInView', intersectRect(bbox, viewRange));\n      }\n    } else {\n      this.set('isInView', false);\n    }\n\n    this.set('cacheCanvasBBox', bbox);\n  }\n\n  draw(context: CanvasRenderingContext2D, region?: Region) {\n    const children = this.cfg.children as IElement[];\n    const allowDraw = region ? this.cfg.refresh : true; // 局部刷新需要判定\n    // 这个地方需要判定，在 G6 的场景每个 group 都有 transform 的场景下性能会开销非常大\n    // 通过 refresh 的判定，可以不刷新没有发生过变化的分组，不在视窗内的分组等等\n    // 如果想进一步提升局部渲染性能，可以进一步优化 refresh 的判定，依然有潜力\n    if (children.length && allowDraw) {\n      context.save();\n      // group 上的矩阵和属性也会应用到上下文上\n      // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n      applyAttrsToContext(context, this);\n      this._applyClip(context, this.getClip() as ShapeBase);\n      drawChildren(context, children, region);\n      context.restore();\n      this.cacheCanvasBBox();\n    }\n    // 这里的成本比较大，如果不绘制则不再\n    // this.set('cacheCanvasBBox', this.getCanvasBBox());\n    this.cfg.refresh = null;\n    // 绘制后，消除更新标记\n    this.set('hasChanged', false);\n  }\n  // 绘制时被跳过，一般发生在分组隐藏时\n  skipDraw() {\n    this.set('cacheCanvasBBox', null);\n    this.set('hasChanged', false);\n  }\n}\n\nexport default Group;\n","import * as Shape from './shape';\nexport * from '@antv/g-base';\nexport { IElement } from './interfaces';\nexport { Region } from './types';\nexport { default as Canvas } from './canvas';\nexport { default as Group } from './group';\nexport { Shape };\nexport { default as getArcParams } from './util/arc-params';\n\nexport const version = '0.5.12';\n","import { AbstractShape } from '@antv/g-base';\nimport { ChangeType, BBox } from '@antv/g-base';\nimport { isNil, intersectRect } from '../util/util';\nimport { applyAttrsToContext, refreshElement } from '../util/draw';\nimport { getBBoxMethod } from '@antv/g-base';\nimport { Region } from '../types';\nimport * as Shape from './index';\nimport Group from '../group';\n\nclass ShapeBase extends AbstractShape {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    // 设置默认值\n    return {\n      ...attrs,\n      lineWidth: 1,\n      lineAppendWidth: 0,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    };\n  }\n\n  getShapeBase() {\n    return Shape;\n  }\n\n  getGroupBase() {\n    return Group;\n  }\n\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  onCanvasChange(changeType: ChangeType) {\n    refreshElement(this, changeType);\n  }\n\n  calculateBBox(): BBox {\n    const type = this.get('type');\n    const lineWidth = this.getHitLineWidth();\n    // const attrs = this.attr();\n    const bboxMethod = getBBoxMethod(type);\n    const box = bboxMethod(this);\n    const halfLineWidth = lineWidth / 2;\n    const minX = box.x - halfLineWidth;\n    const minY = box.y - halfLineWidth;\n    const maxX = box.x + box.width + halfLineWidth;\n    const maxY = box.y + box.height + halfLineWidth;\n    return {\n      x: minX,\n      minX,\n      y: minY,\n      minY,\n      width: box.width + lineWidth,\n      height: box.height + lineWidth,\n      maxX,\n      maxY,\n    };\n  }\n\n  isFill() {\n    return !!this.attrs['fill'] || this.isClipShape();\n  }\n\n  isStroke() {\n    return !!this.attrs['stroke'];\n  }\n\n  // 同 shape 中的方法重复了\n  _applyClip(context, clip: ShapeBase) {\n    if (clip) {\n      context.save();\n      // 将 clip 的属性挂载到 context 上\n      applyAttrsToContext(context, clip);\n      // 绘制 clip 路径\n      clip.createPath(context);\n      context.restore();\n      // 裁剪\n      context.clip();\n      clip._afterDraw();\n    }\n  }\n\n  // 绘制图形时需要考虑 region 限制\n  draw(context: CanvasRenderingContext2D, region?: Region) {\n    const clip = this.cfg.clipShape;\n    // 如果指定了 region，同时不允许刷新时，直接返回\n    if (region) {\n      if (this.cfg.refresh === false) {\n        // this._afterDraw();\n        this.set('hasChanged', false);\n        return;\n      }\n      // 是否相交需要考虑 clip 的包围盒\n      const bbox = this.getCanvasBBox();\n      if (!intersectRect(region, bbox)) {\n        // 图形的包围盒与重绘区域不相交时，也需要清除标记\n        this.set('hasChanged', false);\n        // 存在多种情形需要更新 cacheCanvasBBox 和 isInview 的判定\n        // 1. 之前图形在视窗内，但是现在不再视窗内\n        // 2. 如果当前的图形以及父元素都没有发生过变化，refresh = false 不会走到这里，所以这里的图形都是父元素发生变化，但是没有在视图内的元素\n        if (this.cfg.isInView) {\n          this._afterDraw();\n        }\n        return;\n      }\n    }\n    context.save();\n    // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n    applyAttrsToContext(context, this);\n    this._applyClip(context, clip as ShapeBase);\n    this.drawPath(context);\n    context.restore();\n    this._afterDraw();\n  }\n\n  private getCanvasViewBox() {\n    const canvas = this.cfg.canvas;\n    if (canvas) {\n      // @ts-ignore\n      return canvas.getViewRange();\n    }\n    return null;\n  }\n\n  cacheCanvasBBox() {\n    const canvasBBox = this.getCanvasViewBox();\n    // 绘制的时候缓存包围盒\n    if (canvasBBox) {\n      const bbox = this.getCanvasBBox();\n      const isInView = intersectRect(bbox, canvasBBox);\n      this.set('isInView', isInView);\n      // 不再视窗内 cacheCanvasBBox 设置成 null，会提升局部渲染的性能，\n      // 因为在局部渲染影响的包围盒计算时不考虑这个图形的包围盒\n      // 父元素 cacheCanvasBBox 计算的时候也不计算\n      if (isInView) {\n        this.set('cacheCanvasBBox', bbox);\n      } else {\n        this.set('cacheCanvasBBox', null);\n      }\n    }\n  }\n\n  _afterDraw() {\n    this.cacheCanvasBBox();\n    // 绘制后消除标记\n    this.set('hasChanged', false);\n    this.set('refresh', null);\n  }\n\n  skipDraw() {\n    this.set('cacheCanvasBBox', null);\n    this.set('isInView', null);\n    this.set('hasChanged', false);\n  }\n\n  /**\n   * 绘制图形的路径\n   * @param {CanvasRenderingContext2D} context 上下文\n   */\n  drawPath(context: CanvasRenderingContext2D) {\n    this.createPath(context);\n    this.strokeAndFill(context);\n    this.afterDrawPath(context);\n  }\n\n  /**\n   * @protected\n   * 填充图形\n   * @param {CanvasRenderingContext2D} context context 上下文\n   */\n  fill(context: CanvasRenderingContext2D) {\n    context.fill();\n  }\n\n  /**\n   * @protected\n   * 绘制图形边框\n   * @param {CanvasRenderingContext2D} context context 上下文\n   */\n  stroke(context: CanvasRenderingContext2D) {\n    context.stroke();\n  }\n\n  // 绘制或者填充\n  strokeAndFill(context) {\n    const { lineWidth, opacity, strokeOpacity, fillOpacity } = this.attrs;\n\n    if (this.isFill()) {\n      if (!isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        this.fill(context);\n        context.globalAlpha = opacity;\n      } else {\n        this.fill(context);\n      }\n    }\n\n    if (this.isStroke()) {\n      if (lineWidth > 0) {\n        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = strokeOpacity;\n        }\n        this.stroke(context);\n      }\n    }\n    this.afterDrawPath(context);\n  }\n\n  /**\n   * @protected\n   * 绘制图形的路径\n   * @param {CanvasRenderingContext2D} context 上下文\n   */\n  createPath(context: CanvasRenderingContext2D) {}\n\n  /**\n   * 绘制完成 path 后的操作\n   * @param {CanvasRenderingContext2D} context 上下文\n   */\n  afterDrawPath(context: CanvasRenderingContext2D) {}\n\n  isInShape(refX: number, refY: number): boolean {\n    // return HitUtil.isHitShape(this, refX, refY);\n    const isStroke = this.isStroke();\n    const isFill = this.isFill();\n    const lineWidth = this.getHitLineWidth();\n    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\n  }\n\n  // 之所以不拆成 isInStroke 和 isInPath 在于两者存在一些共同的计算\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    return false;\n  }\n\n  /**\n   * 获取线拾取的宽度\n   * @returns {number} 线的拾取宽度\n   */\n  getHitLineWidth() {\n    if (!this.isStroke()) {\n      return 0;\n    }\n    const attrs = this.attrs;\n    return attrs['lineWidth'] + attrs['lineAppendWidth'];\n  }\n}\n\nexport default ShapeBase;\n","/**\n * @fileoverview 圆\n * @author dxq613@gmail.com\n */\n\nimport ShapeBase from './base';\nimport { distance } from '../util/util';\n\nclass Circle extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      x: 0,\n      y: 0,\n      r: 0,\n    };\n  }\n\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    const attrs = this.attr();\n    const cx = attrs.x;\n    const cy = attrs.y;\n    const r = attrs.r;\n    const halfLineWidth = lineWidth / 2;\n    const absDistance = distance(cx, cy, x, y);\n    // 直接用距离，如果同时存在边和填充时，可以减少两次计算\n    if (isFill && isStroke) {\n      return absDistance <= r + halfLineWidth;\n    }\n    if (isFill) {\n      return absDistance <= r;\n    }\n    if (isStroke) {\n      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n    }\n    return false;\n  }\n\n  createPath(context) {\n    const attrs = this.attr();\n    const cx = attrs.x;\n    const cy = attrs.y;\n    const r = attrs.r;\n    context.beginPath();\n    context.arc(cx, cy, r, 0, Math.PI * 2, false);\n    context.closePath();\n  }\n}\n\nexport default Circle;\n","/**\n * @fileoverview 椭圆\n * @author dxq613@gmail.com\n */\n\nimport ShapeBase from './base';\n\n// 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n  return squareX / (rx * rx) + squareY / (ry * ry);\n}\n\nclass Ellipse extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      x: 0,\n      y: 0,\n      rx: 0,\n      ry: 0,\n    };\n  }\n\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    const attrs = this.attr();\n    const halfLineWith = lineWidth / 2;\n    const cx = attrs.x;\n    const cy = attrs.y;\n    const { rx, ry } = attrs;\n    const squareX = (x - cx) * (x - cx);\n    const squareY = (y - cy) * (y - cy);\n    // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n    if (isFill && isStroke) {\n      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n    }\n    if (isFill) {\n      return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n    }\n    if (isStroke) {\n      return (\n        ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 &&\n        ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1\n      );\n    }\n    return false;\n  }\n\n  createPath(context) {\n    const attrs = this.attr();\n    const cx = attrs.x;\n    const cy = attrs.y;\n    const rx = attrs.rx;\n    const ry = attrs.ry;\n    context.beginPath();\n    // 兼容逻辑\n    if (context.ellipse) {\n      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\n    } else {\n      // 如果不支持，则使用圆来绘制，进行变形\n      const r = rx > ry ? rx : ry;\n      const scaleX = rx > ry ? 1 : rx / ry;\n      const scaleY = rx > ry ? ry / rx : 1;\n      context.save();\n      context.translate(cx, cy);\n      context.scale(scaleX, scaleY);\n      context.arc(0, 0, r, 0, Math.PI * 2);\n      context.restore();\n      context.closePath();\n    }\n  }\n}\n\nexport default Ellipse;\n","/**\n * @fileoverview 图片\n * @author dxq613@gmail.com\n */\n\nimport ShapeBase from './base';\nimport { isString, isNil } from '../util/util';\nfunction isCanvas(dom) {\n  return dom instanceof HTMLElement && isString(dom.nodeName) && dom.nodeName.toUpperCase() === 'CANVAS';\n}\n\nclass ImageShape extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    };\n  }\n\n  initAttrs(attrs) {\n    this._setImage(attrs.img);\n  }\n\n  // image 不计算 stroke\n  isStroke() {\n    return false;\n  }\n\n  // 仅仅使用包围盒检测来进行拾取\n  // 所以不需要复写 isInStrokeOrPath 的方法\n  isOnlyHitBox() {\n    return true;\n  }\n\n  _afterLoading() {\n    if (this.get('toDraw') === true) {\n      const canvas = this.get('canvas');\n      if (canvas) {\n        // 这段应该改成局部渲染\n        canvas.draw();\n      } else {\n        // 这种方式如果发生遮挡会出现问题\n        this.createPath(this.get('context'));\n      }\n    }\n  }\n\n  _setImage(img) {\n    const attrs = this.attrs;\n    if (isString(img)) {\n      const image = new Image();\n      image.onload = () => {\n        // 图片未加载完，则已经被销毁\n        if (this.destroyed) {\n          return false;\n        }\n        // 缓存原始地址，可以做对比，防止重复加载图片\n        // 如果考虑到在加载过程中可能替换 img 属性，则情况更加复杂\n        // this.set('imgSrc', img);\n        // 这里会循环调用 _setImage 方法，但不会再走这个分支\n        this.attr('img', image);\n        this.set('loading', false);\n        this._afterLoading();\n        const callback = this.get('callback');\n        if (callback) {\n          callback.call(this);\n        }\n      };\n      // 设置跨域\n      image.crossOrigin = 'Anonymous';\n\n      image.src = img;\n      // loading 过程中不绘制\n      this.set('loading', true);\n    } else if (img instanceof Image) {\n      // 如果是一个 image 对象，则设置宽高\n      if (!attrs.width) {\n        attrs.width = img.width;\n      }\n      if (!attrs.height) {\n        attrs.height = img.height;\n      }\n    } else if (isCanvas(img)) {\n      // 如果设置了 canvas 对象\n      if (!attrs.width) {\n        attrs.width = Number(img.getAttribute('width'));\n      }\n\n      if (!attrs.height) {\n        attrs.height, Number(img.getAttribute('height'));\n      }\n    }\n  }\n\n  onAttrChange(name: string, value: any, originValue: any) {\n    super.onAttrChange(name, value, originValue);\n    // 如果加载的已经是当前图片，则不再处理\n    if (name === 'img') {\n      // 可以加缓冲，&& this.get('imgSrc') !== value\n      this._setImage(value);\n    }\n  }\n\n  createPath(context: CanvasRenderingContext2D) {\n    // 正在加载则不绘制\n    if (this.get('loading')) {\n      this.set('toDraw', true); // 加载完成后绘制\n      this.set('context', context);\n      return;\n    }\n    const attrs = this.attr();\n    const { x, y, width, height, sx, sy, swidth, sheight } = attrs;\n\n    const img = attrs.img;\n    if (img instanceof Image || isCanvas(img)) {\n      if (!isNil(sx) && !isNil(sy) && !isNil(swidth) && !isNil(sheight)) {\n        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);\n      } else {\n        context.drawImage(img, x, y, width, height);\n      }\n    }\n  }\n}\n\nexport default ImageShape;\n","/**\n * @fileoverview 线\n * @author dxq613@gmail.com\n */\nimport { Line as LineUtil } from '@antv/g-math';\nimport ShapeBase from './base';\nimport inLine from '../util/in-stroke/line';\nimport * as ArrowUtil from '../util/arrow';\n\nclass Line extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      startArrow: false,\n      endArrow: false,\n    };\n  }\n\n  initAttrs(attrs) {\n    this.setArrow();\n  }\n\n  // 更新属性时，检测是否更改了箭头\n  onAttrChange(name: string, value: any, originValue: any) {\n    super.onAttrChange(name, value, originValue);\n    // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n    this.setArrow();\n  }\n\n  setArrow() {\n    const attrs = this.attr();\n    const { x1, y1, x2, y2, startArrow, endArrow } = attrs;\n    if (startArrow) {\n      ArrowUtil.addStartArrow(this, attrs, x2, y2, x1, y1);\n    }\n    if (endArrow) {\n      ArrowUtil.addEndArrow(this, attrs, x1, y1, x2, y2);\n    }\n  }\n\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    if (!isStroke || !lineWidth) {\n      return false;\n    }\n    const { x1, y1, x2, y2 } = this.attr();\n    return inLine(x1, y1, x2, y2, lineWidth, x, y);\n  }\n\n  createPath(context) {\n    const attrs = this.attr();\n    const { x1, y1, x2, y2, startArrow, endArrow } = attrs;\n    let startArrowDistance = {\n      dx: 0,\n      dy: 0,\n    };\n    let endArrowDistance = {\n      dx: 0,\n      dy: 0,\n    };\n\n    if (startArrow && startArrow.d) {\n      startArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);\n    }\n    if (endArrow && endArrow.d) {\n      endArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);\n    }\n\n    context.beginPath();\n    // 如果自定义箭头，线条相应缩进\n    context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);\n    context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);\n  }\n\n  afterDrawPath(context) {\n    const startArrowShape = this.get('startArrowShape');\n    const endArrowShape = this.get('endArrowShape');\n    if (startArrowShape) {\n      startArrowShape.draw(context);\n    }\n    if (endArrowShape) {\n      endArrowShape.draw(context);\n    }\n  }\n\n  /**\n   * Get length of line\n   * @return {number} length\n   */\n  getTotalLength() {\n    const { x1, y1, x2, y2 } = this.attr();\n    return LineUtil.length(x1, y1, x2, y2);\n  }\n\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n  getPoint(ratio: number) {\n    const { x1, y1, x2, y2 } = this.attr();\n    return LineUtil.pointAt(x1, y1, x2, y2, ratio);\n  }\n}\n\nexport default Line;\n","/**\n * @fileoverview Marker\n * @author dxq613@gmail.com\n */\n\nimport { isNil } from '@antv/util';\nimport { path2Absolute } from '@antv/path-util';\nimport ShapeBase from './base';\nimport { isFunction } from '../util/util';\nimport { drawPath } from '../util/draw';\n\nconst Symbols = {\n  // 圆\n  circle(x, y, r) {\n    return [\n      ['M', x - r, y],\n      ['A', r, r, 0, 1, 0, x + r, y],\n      ['A', r, r, 0, 1, 0, x - r, y],\n    ];\n  },\n  // 正方形\n  square(x, y, r) {\n    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];\n  },\n  // 菱形\n  diamond(x, y, r) {\n    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];\n  },\n  // 三角形\n  triangle(x, y, r) {\n    const diffY = r * Math.sin((1 / 3) * Math.PI);\n    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['Z']];\n  },\n  // 倒三角形\n  'triangle-down'(x, y, r) {\n    const diffY = r * Math.sin((1 / 3) * Math.PI);\n    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];\n  },\n};\n\nclass Marker extends ShapeBase {\n  initAttrs(attrs) {\n    this._resetParamsCache();\n  }\n\n  // 重置绘制 path 存储的缓存\n  _resetParamsCache() {\n    // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n    // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n    this.set('paramsCache', {}); // 清理缓存\n  }\n\n  // 更新属性时，检测是否更改了 path\n  onAttrChange(name: string, value: any, originValue: any) {\n    super.onAttrChange(name, value, originValue);\n    if (['symbol', 'x', 'y', 'r', 'radius'].indexOf(name) !== -1) {\n      // path 相关属性更改时，清理缓存\n      this._resetParamsCache();\n    }\n  }\n\n  // 仅仅使用包围盒检测来进行拾取\n  // 所以不需要复写 isInStrokeOrPath 的方法\n  isOnlyHitBox() {\n    return true;\n  }\n\n  _getR(attrs) {\n    // 兼容 r 和 radius 两种写法，推荐使用 r\n    return isNil(attrs.r) ? attrs.radius : attrs.r;\n  }\n\n  _getPath() {\n    const attrs = this.attr();\n    const { x, y } = attrs;\n    const symbol = attrs.symbol || 'circle';\n    const r = this._getR(attrs);\n    let method;\n    let path;\n    if (isFunction(symbol)) {\n      method = symbol;\n      path = method(x, y, r);\n      // 将 path 转成绝对路径\n      path = path2Absolute(path);\n    } else {\n      // 内置 symbol 的 path 都是绝对路径，直接绘制即可，不需要对 path 进行特殊处理\n      method = Marker.Symbols[symbol];\n\n      if (!method) {\n        console.warn(`${symbol} marker is not supported.`);\n        return null;\n      }\n\n      path = method(x, y, r);\n    }\n\n    return path;\n  }\n\n  createPath(context) {\n    const path = this._getPath();\n    const paramsCache = this.get('paramsCache');\n    drawPath(this, context, { path }, paramsCache);\n  }\n\n  static Symbols = Symbols;\n}\n\nexport default Marker;\n","/**\n * @fileoverview path\n * @author dxq613@gmail.com\n */\nimport { Point } from '@antv/g-base';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport { path2Absolute, path2Segments } from '@antv/path-util';\nimport { drawPath } from '../util/draw';\nimport isPointInPath from '../util/in-path/point-in-path';\nimport isInPolygon from '../util/in-path/polygon';\nimport PathUtil from '../util/path';\nimport * as ArrowUtil from '../util/arrow';\n\n// 是否在多个多边形内部\nfunction isInPolygons(polygons, x, y) {\n  let isHit = false;\n  for (let i = 0; i < polygons.length; i++) {\n    const points = polygons[i];\n    isHit = isInPolygon(points, x, y);\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\n\nclass Path extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      startArrow: false,\n      endArrow: false,\n    };\n  }\n\n  initAttrs(attrs) {\n    this._setPathArr(attrs.path);\n    this.setArrow();\n  }\n\n  // 更新属性时，检测是否更改了 path\n  onAttrChange(name: string, value: any, originValue: any) {\n    super.onAttrChange(name, value, originValue);\n    if (name === 'path') {\n      this._setPathArr(value);\n    }\n    // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n    this.setArrow();\n  }\n\n  // 将 path 转换成绝对路径\n  _setPathArr(path) {\n    // 转换 path 的格式\n    this.attrs.path = path2Absolute(path);\n    const hasArc = PathUtil.hasArc(path);\n    // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n    // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n    this.set('hasArc', hasArc);\n    this.set('paramsCache', {}); // 清理缓存\n    this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n    this.set('curve', null);\n    this.set('tCache', null);\n    this.set('totalLength', null);\n  }\n\n  getSegments() {\n    let segments = this.get('segements');\n    if (!segments) {\n      segments = path2Segments(this.attr('path'));\n      this.set('segments', segments);\n    }\n    return segments;\n  }\n\n  setArrow() {\n    const attrs = this.attr();\n    const { startArrow, endArrow } = attrs;\n\n    if (startArrow) {\n      const tangent = this.getStartTangent();\n      ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n    if (endArrow) {\n      const tangent = this.getEndTangent();\n      ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n  }\n\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    const segments = this.getSegments();\n    const hasArc = this.get('hasArc');\n    let isHit = false;\n    if (isStroke) {\n      const length = this.getTotalLength();\n      isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length);\n    }\n    if (!isHit && isFill) {\n      if (hasArc) {\n        // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n        isHit = isPointInPath(this, x, y);\n      } else {\n        const path = this.attr('path');\n        const extractResutl = PathUtil.extractPolygons(path);\n        // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n      }\n    }\n    return isHit;\n  }\n\n  createPath(context) {\n    const attrs = this.attr();\n    const paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n    drawPath(this, context, attrs, paramsCache);\n  }\n\n  afterDrawPath(context: CanvasRenderingContext2D) {\n    const startArrowShape = this.get('startArrowShape');\n    const endArrowShape = this.get('endArrowShape');\n    if (startArrowShape) {\n      startArrowShape.draw(context);\n    }\n    if (endArrowShape) {\n      endArrowShape.draw(context);\n    }\n  }\n\n  /**\n   * Get total length of path\n   * @return {number} length\n   */\n  getTotalLength() {\n    const totalLength = this.get('totalLength');\n    if (!isNil(totalLength)) {\n      return totalLength;\n    }\n    this._calculateCurve();\n    this._setTcache();\n    return this.get('totalLength');\n  }\n\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n  getPoint(ratio: number): Point {\n    let tCache = this.get('tCache');\n    if (!tCache) {\n      this._calculateCurve();\n      this._setTcache();\n      tCache = this.get('tCache');\n    }\n\n    let subt;\n    let index;\n\n    const curve = this.get('curve');\n    if (!tCache || tCache.length === 0) {\n      if (curve) {\n        return {\n          x: curve[0][1],\n          y: curve[0][2],\n        };\n      }\n      return null;\n    }\n    each(tCache, (v, i) => {\n      if (ratio >= v[0] && ratio <= v[1]) {\n        subt = (ratio - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n\n    const seg = curve[index];\n    if (isNil(seg) || isNil(index)) {\n      return null;\n    }\n    const l = seg.length;\n    const nextSeg = curve[index + 1];\n    return CubicUtil.pointAt(\n      seg[l - 2],\n      seg[l - 1],\n      nextSeg[1],\n      nextSeg[2],\n      nextSeg[3],\n      nextSeg[4],\n      nextSeg[5],\n      nextSeg[6],\n      subt\n    );\n  }\n\n  _calculateCurve() {\n    const { path } = this.attr();\n    this.set('curve', PathUtil.pathToCurve(path));\n  }\n\n  _setTcache() {\n    let totalLength = 0;\n    let tempLength = 0;\n    // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n    const tCache = [];\n    let segmentT;\n    let segmentL;\n    let segmentN;\n    let l;\n    const curve = this.get('curve');\n\n    if (!curve) {\n      return;\n    }\n\n    each(curve, (segment, i) => {\n      segmentN = curve[i + 1];\n      l = segment.length;\n      if (segmentN) {\n        totalLength +=\n          CubicUtil.length(\n            segment[l - 2],\n            segment[l - 1],\n            segmentN[1],\n            segmentN[2],\n            segmentN[3],\n            segmentN[4],\n            segmentN[5],\n            segmentN[6]\n          ) || 0;\n      }\n    });\n    this.set('totalLength', totalLength);\n\n    if (totalLength === 0) {\n      this.set('tCache', []);\n      return;\n    }\n\n    each(curve, (segment, i) => {\n      segmentN = curve[i + 1];\n      l = segment.length;\n      if (segmentN) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = CubicUtil.length(\n          segment[l - 2],\n          segment[l - 1],\n          segmentN[1],\n          segmentN[2],\n          segmentN[3],\n          segmentN[4],\n          segmentN[5],\n          segmentN[6]\n        );\n        // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n        tempLength += segmentL || 0;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.set('tCache', tCache);\n  }\n\n  /**\n   * Get start tangent vector\n   * @return {Array}\n   */\n  getStartTangent(): number[][] {\n    const segments = this.getSegments();\n    let result;\n    if (segments.length > 1) {\n      const startPoint = segments[0].currentPoint;\n      const endPoint = segments[1].currentPoint;\n      const tangent = segments[1].startTangent;\n      result = [];\n      if (tangent) {\n        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      } else {\n        result.push([endPoint[0], endPoint[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get end tangent vector\n   * @return {Array}\n   */\n  getEndTangent(): number[][] {\n    const segments = this.getSegments();\n    const length = segments.length;\n    let result;\n    if (length > 1) {\n      const startPoint = segments[length - 2].currentPoint;\n      const endPoint = segments[length - 1].currentPoint;\n      const tangent = segments[length - 1].endTangent;\n      result = [];\n      if (tangent) {\n        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      } else {\n        result.push([startPoint[0], startPoint[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      }\n    }\n    return result;\n  }\n}\n\nexport default Path;\n","/**\n * @fileoverview 多边形\n * @author dxq613@gmail.com\n */\n\nimport ShapeBase from './base';\nimport inPolyline from '../util/in-stroke/polyline';\nimport isInPolygon from '../util/in-path/polygon';\n\nclass Polygon extends ShapeBase {\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    const { points } = this.attr();\n    let isHit = false;\n    if (isStroke) {\n      isHit = inPolyline(points, lineWidth, x, y, true);\n    }\n    if (!isHit && isFill) {\n      isHit = isInPolygon(points, x, y); // isPointInPath(shape, x, y);\n    }\n    return isHit;\n  }\n\n  createPath(context) {\n    const attrs = this.attr();\n    const points = attrs.points;\n    if (points.length < 2) {\n      return;\n    }\n    context.beginPath();\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      if (i === 0) {\n        context.moveTo(point[0], point[1]);\n      } else {\n        context.lineTo(point[0], point[1]);\n      }\n    }\n    context.closePath();\n  }\n}\n\nexport default Polygon;\n","/**\n * @fileoverview 多边形\n * @author dxq613@gmail.com\n */\nimport { Point } from '@antv/g-base';\nimport { Line as LineUtil } from '@antv/g-math';\nimport { Polyline as PolylineUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport inPolyline from '../util/in-stroke/polyline';\nimport * as ArrowUtil from '../util/arrow';\n\nclass PolyLine extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      startArrow: false,\n      endArrow: false,\n    };\n  }\n\n  initAttrs(attrs) {\n    this.setArrow();\n  }\n\n  // 更新属性时，检测是否更改了 points\n  onAttrChange(name: string, value: any, originValue: any) {\n    super.onAttrChange(name, value, originValue);\n    this.setArrow();\n    if (['points'].indexOf(name) !== -1) {\n      this._resetCache();\n    }\n  }\n\n  _resetCache() {\n    this.set('totalLength', null);\n    this.set('tCache', null);\n  }\n\n  setArrow() {\n    const attrs = this.attr();\n    const { points, startArrow, endArrow } = this.attrs;\n    const length = points.length;\n    const x1 = points[0][0];\n    const y1 = points[0][1];\n    const x2 = points[length - 1][0];\n    const y2 = points[length - 1][1];\n\n    if (startArrow) {\n      ArrowUtil.addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);\n    }\n    if (endArrow) {\n      ArrowUtil.addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);\n    }\n  }\n\n  // 不允许 fill\n  isFill() {\n    return false;\n  }\n\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    // 没有设置 stroke 不能被拾取, 没有线宽不能被拾取\n    if (!isStroke || !lineWidth) {\n      return false;\n    }\n    const { points } = this.attr();\n    return inPolyline(points, lineWidth, x, y, false);\n  }\n\n  // 始终填充\n  isStroke() {\n    return true;\n  }\n\n  createPath(context) {\n    const { points, startArrow, endArrow } = this.attr();\n    const length = points.length;\n    if (points.length < 2) {\n      return;\n    }\n    let x1 = points[0][0];\n    let y1 = points[0][1];\n    let x2 = points[length - 1][0];\n    let y2 = points[length - 1][1];\n    // 如果定义了箭头，并且是自定义箭头，线条相应缩进\n    if (startArrow && startArrow.d) {\n      const distance = ArrowUtil.getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);\n      x1 += distance.dx;\n      y1 += distance.dy;\n    }\n    if (endArrow && endArrow.d) {\n      const distance = ArrowUtil.getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);\n      x2 -= distance.dx;\n      y2 -= distance.dy;\n    }\n\n    context.beginPath();\n    context.moveTo(x1, y1);\n    for (let i = 0; i < length - 1; i++) {\n      const point = points[i];\n      context.lineTo(point[0], point[1]);\n    }\n    context.lineTo(x2, y2);\n  }\n\n  afterDrawPath(context: CanvasRenderingContext2D) {\n    const startArrowShape = this.get('startArrowShape');\n    const endArrowShape = this.get('endArrowShape');\n    if (startArrowShape) {\n      startArrowShape.draw(context);\n    }\n    if (endArrowShape) {\n      endArrowShape.draw(context);\n    }\n  }\n\n  /**\n   * Get length of polyline\n   * @return {number} length\n   */\n  getTotalLength() {\n    const { points } = this.attr();\n    // get totalLength from cache\n    const totalLength = this.get('totalLength');\n    if (!isNil(totalLength)) {\n      return totalLength;\n    }\n    this.set('totalLength', PolylineUtil.length(points));\n    return this.get('totalLength');\n  }\n\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n  getPoint(ratio: number): Point {\n    const { points } = this.attr();\n    // get tCache from cache\n    let tCache = this.get('tCache');\n    if (!tCache) {\n      this._setTcache();\n      tCache = this.get('tCache');\n    }\n\n    let subt;\n    let index;\n    each(tCache, (v, i) => {\n      if (ratio >= v[0] && ratio <= v[1]) {\n        subt = (ratio - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    return LineUtil.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);\n  }\n\n  _setTcache() {\n    const { points } = this.attr();\n    if (!points || points.length === 0) {\n      return;\n    }\n\n    const totalLength = this.getTotalLength();\n    if (totalLength <= 0) {\n      return;\n    }\n\n    let tempLength = 0;\n    const tCache = [];\n    let segmentT;\n    let segmentL;\n\n    each(points, (p, i) => {\n      if (points[i + 1]) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = LineUtil.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);\n        tempLength += segmentL;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.set('tCache', tCache);\n  }\n\n  /**\n   * Get start tangent vector\n   * @return {Array}\n   */\n  getStartTangent(): number[][] {\n    const { points } = this.attr();\n    const result = [];\n    result.push([points[1][0], points[1][1]]);\n    result.push([points[0][0], points[0][1]]);\n    return result;\n  }\n\n  /**\n   * Get end tangent vector\n   * @return {Array}\n   */\n  getEndTangent(): number[][] {\n    const { points } = this.attr();\n    const l = points.length - 1;\n    const result = [];\n    result.push([points[l - 1][0], points[l - 1][1]]);\n    result.push([points[l][0], points[l][1]]);\n    return result;\n  }\n}\n\nexport default PolyLine;\n","/**\n * @fileoverview 矩形\n * @author dxq613@gmail.com\n */\n\nimport ShapeBase from './base';\nimport { parseRadius } from '../util/parse';\nimport { inBox } from '../util/util';\nimport inRect from '../util/in-stroke/rect';\nimport inRectWithRadius from '../util/in-stroke/rect-radius';\nimport isPointInPath from '../util/in-path/point-in-path';\n\nclass Rect extends ShapeBase {\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      radius: 0,\n    };\n  }\n\n  isInStrokeOrPath(x, y, isStroke, isFill, lineWidth) {\n    const attrs = this.attr();\n    const minX = attrs.x;\n    const minY = attrs.y;\n    const width = attrs.width;\n    const height = attrs.height;\n    const radius = attrs.radius;\n    // 无圆角时的策略\n    if (!radius) {\n      const halfWidth = lineWidth / 2;\n      // 同时填充和带有边框\n      if (isFill && isStroke) {\n        return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);\n      }\n      // 仅填充\n      if (isFill) {\n        return inBox(minX, minY, width, height, x, y);\n      }\n      if (isStroke) {\n        return inRect(minX, minY, width, height, lineWidth, x, y);\n      }\n    } else {\n      let isHit = false;\n      if (isStroke) {\n        isHit = inRectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);\n      }\n      // 仅填充时带有圆角的矩形直接通过图形拾取\n      // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n      if (!isHit && isFill) {\n        isHit = isPointInPath(this, x, y);\n      }\n      return isHit;\n    }\n  }\n\n  createPath(context) {\n    const attrs = this.attr();\n    const x = attrs.x;\n    const y = attrs.y;\n    const width = attrs.width;\n    const height = attrs.height;\n    const radius = attrs.radius;\n\n    context.beginPath();\n    if (radius === 0) {\n      // 改成原生的rect方法\n      context.rect(x, y, width, height);\n    } else {\n      const [r1, r2, r3, r4] = parseRadius(radius);\n      context.moveTo(x + r1, y);\n      context.lineTo(x + width - r2, y);\n      r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n      context.lineTo(x + width, y + height - r3);\n      r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n      context.lineTo(x + r4, y + height);\n      r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n      context.lineTo(x, y + r1);\n      r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n      context.closePath();\n    }\n  }\n}\n\nexport default Rect;\n","/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\n\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\nclass Text extends ShapeBase {\n  // 默认文本属性\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    return {\n      ...attrs,\n      x: 0,\n      y: 0,\n      text: null,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom',\n    };\n  }\n\n  // 仅仅使用包围盒检测来进行拾取\n  isOnlyHitBox() {\n    return true;\n  }\n\n  // 初始化时组合 font，同时判断 text 是否换行\n  initAttrs(attrs) {\n    this._assembleFont();\n    if (attrs.text) {\n      this._setText(attrs.text);\n    }\n  }\n  // 组装字体\n  _assembleFont() {\n    const attrs = this.attrs;\n    attrs.font = assembleFont(attrs);\n  }\n\n  // 如果文本换行，则缓存数组\n  _setText(text) {\n    let textArr = null;\n    if (isString(text) && text.indexOf('\\n') !== -1) {\n      textArr = text.split('\\n');\n    }\n    this.set('textArr', textArr);\n  }\n\n  // 更新属性时，检测是否更改了 font、text\n  onAttrChange(name: string, value: any, originValue: any) {\n    super.onAttrChange(name, value, originValue);\n    if (name.startsWith('font')) {\n      this._assembleFont();\n    }\n    if (name === 'text') {\n      this._setText(value);\n    }\n  }\n\n  // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n  // createPath(context) {\n\n  // }\n\n  // 如果文本多行，需要获取文本间距\n  _getSpaceingY() {\n    const attrs = this.attrs;\n    const lineHeight = attrs.lineHeight;\n    const fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  }\n\n  // 绘制文本，考虑多行的场景\n  _drawTextArr(context, textArr, isFill) {\n    const attrs = this.attrs;\n    const textBaseline = attrs.textBaseline;\n    const x = attrs.x;\n    const y = attrs.y;\n    const fontSize = attrs.fontSize * 1;\n    const spaceingY = this._getSpaceingY();\n    const height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n    let subY;\n    each(textArr, (subText, index: number) => {\n      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;\n      if (textBaseline === 'top') subY += height - fontSize;\n      if (!isNil(subText)) {\n        if (isFill) {\n          context.fillText(subText, x, subY);\n        } else {\n          context.strokeText(subText, x, subY);\n        }\n      }\n    });\n  }\n\n  // 绘制文本，同时考虑填充和绘制边框\n  _drawText(context, isFill) {\n    const attrs = this.attr();\n    const x = attrs.x;\n    const y = attrs.y;\n    const textArr = this.get('textArr');\n    if (textArr) {\n      this._drawTextArr(context, textArr, isFill);\n    } else {\n      const text = attrs.text;\n      if (!isNil(text)) {\n        if (isFill) {\n          context.fillText(text, x, y);\n        } else {\n          context.strokeText(text, x, y);\n        }\n      }\n    }\n  }\n\n  // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n  strokeAndFill(context) {\n    const { lineWidth, opacity, strokeOpacity, fillOpacity } = this.attrs;\n\n    if (this.isStroke()) {\n      if (lineWidth > 0) {\n        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = opacity;\n        }\n        this.stroke(context);\n      }\n    }\n\n    if (this.isFill()) {\n      if (!isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        this.fill(context);\n        context.globalAlpha = opacity;\n      } else {\n        this.fill(context);\n      }\n    }\n\n    this.afterDrawPath(context);\n  }\n\n  // 复写填充逻辑\n  fill(context) {\n    this._drawText(context, true);\n  }\n\n  // 复写绘制边框的逻辑\n  stroke(context) {\n    this._drawText(context, false);\n  }\n}\n\nexport default Text;\n"],"names":["__extends","Canvas","cfg","_super","getDefaultCfg","call","changeType","this","set","draw","Shape","Group","pixelRatio","get","getPixelRatio","Math","ceil","minX","minY","maxX","width","maxY","height","element","document","createElement","context","getContext","setDOMSize","el","scale","clear","_clearFrame","clearRect","x","y","getShape","region","elements","viewRegion","getViewRange","length","getMergedRegion","floor","mergeView","push","drawFrame","clearAnimationFrame","_startDraw","children","getChildren","applyAttrsToContext","drawChildren","refreshElements","_getRefreshRegion","save","beginPath","rect","clip","checkRefresh","restore","clearChanged","each","requestAnimationFrame","_this","_drawRegion","_drawAll","parentNode","removeChild","AbstractCanvas","refreshElement","createPath","_afterDraw","xArr","yArr","child","bbox","cacheCanvasBBox","isInView","min","max","canvas","viewRange","intersectRect","allowDraw","refresh","_applyClip","getClip","AbstractGroup","version","ShapeBase","attrs","getDefaultAttrs","lineWidth","lineAppendWidth","strokeOpacity","fillOpacity","type","getHitLineWidth","box","getBBoxMethod","bboxMethod","halfLineWidth","isClipShape","clipShape","getCanvasBBox","drawPath","canvasBBox","getCanvasViewBox","strokeAndFill","afterDrawPath","fill","stroke","opacity","isFill","isNil","globalAlpha","isStroke","refX","refY","isInStrokeOrPath","AbstractShape","Circle","r","attr","cx","cy","absDistance","distance","arc","PI","closePath","ellipseDistance","squareX","squareY","rx","ry","Ellipse","halfLineWith","ellipse","scaleX","scaleY","translate","isCanvas","dom","HTMLElement","isString","nodeName","toUpperCase","ImageShape","_setImage","img","image_1","Image","onload","destroyed","_afterLoading","callback","crossOrigin","src","Number","getAttribute","name","value","originValue","onAttrChange","sx","sy","swidth","sheight","drawImage","Line","x1","y1","x2","y2","startArrow","endArrow","setArrow","ArrowUtil","inLine","startArrowDistance","dx","dy","endArrowDistance","d","moveTo","lineTo","startArrowShape","endArrowShape","LineUtil","ratio","Symbols","circle","square","diamond","triangle","diffY","sin","Marker","_resetParamsCache","indexOf","radius","method","path","symbol","_getR","isFunction","path2Absolute","console","warn","_getPath","paramsCache","isInPolygons","polygons","isHit","i","points","isInPolygon","Path","_setPathArr","hasArc","PathUtil","segments","path2Segments","tangent","getStartTangent","getEndTangent","getSegments","length_1","getTotalLength","isPointInPath","extractResutl","polylines","totalLength","_calculateCurve","_setTcache","subt","index","tCache","curve","v","seg","l","nextSeg","CubicUtil","segmentT","segmentL","segmentN","tempLength","segment","result","startPoint","currentPoint","endPoint","startTangent","endTangent","Polygon","inPolyline","point","PolyLine","_resetCache","PolylineUtil","p","Rect","inRectWithRadius","halfWidth","inBox","inRect","parseRadius","r1","r2","r3","r4","Text","text","fontSize","fontFamily","fontStyle","fontWeight","fontVariant","textAlign","textBaseline","_assembleFont","_setText","font","assembleFont","textArr","split","startsWith","lineHeight","subY","spaceingY","_getSpaceingY","getTextHeight","subText","fillText","strokeText","_drawTextArr","_drawText"],"sourceRoot":""}