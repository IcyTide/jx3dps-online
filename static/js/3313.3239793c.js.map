{"version":3,"file":"static/js/3313.3239793c.js","mappings":"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","sources":["../node_modules/@antv/path-util/src/parse-path.ts","../node_modules/@antv/path-util/src/catmull-rom-2-bezier.ts","../node_modules/@antv/path-util/src/parse-path-string.ts","../node_modules/@antv/path-util/src/path-2-absolute.ts","../node_modules/@antv/path-util/src/process/arc-2-cubic.ts","../node_modules/@antv/path-util/src/get-arc-params.ts","../node_modules/@antv/path-util/src/path-2-segments.ts","../node_modules/@antv/path-util/src/point-in-polygon.ts","../node_modules/@antv/path-util/src/get-line-intersect.ts","../node_modules/@antv/path-util/src/is-polygons-intersect.ts"],"sourcesContent":["import { each, isArray, isString } from '@antv/util';\n\nconst regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\nconst regexDot = /[^\\s\\,]+/ig;\n\nfunction parsePath(p: string): string[] {\n  let path = p || [] as string | string[];\n  if (isArray(path)) {\n    return path;\n  }\n\n  if (isString(path)) {\n    path = path.match(regexTags);\n    each(path, (item, index) => {\n      // @ts-ignore\n      item = item.match(regexDot);\n      if (item[0].length > 1) {\n        const tag = item[0].charAt(0);\n        // @ts-ignore\n        item.splice(1, 0, item[0].substr(1));\n        // @ts-ignore\n        item[0] = tag;\n      }\n      // @ts-ignore\n      each(item, function (sub, i) {\n        if (!isNaN(sub)) {\n          // @ts-ignore\n          item[i] = +sub;\n        }\n      });\n      // @ts-ignore\n      path[index] = item;\n    });\n    return path;\n  }\n}\n\nexport default parsePath;\n","import { vec2 } from '@antv/matrix-util';\nimport type { PathCommand } from './types';\n\ntype Pos = [number, number];\n\nfunction smoothBezier(points: Pos[], smooth: number, isLoop: boolean, constraint: Pos[]) {\n  const cps: vec2[] = [];\n  const hasConstraint = !!constraint;\n\n  let prevPoint: Pos;\n  let nextPoint: Pos;\n  let min: vec2;\n  let max: vec2;\n  let nextCp0: vec2;\n  let cp1: vec2;\n  let cp0: vec2;\n\n  if (hasConstraint) {\n    [ min, max ] = constraint;\n    for (let i = 0, l = points.length; i < l; i += 1) {\n      const point = points[i];\n      min = vec2.min([ 0, 0 ], min, point);\n      max = vec2.max([ 0, 0 ], max, point);\n    }\n  }\n\n  for (let i = 0, len = points.length; i < len; i += 1) {\n    const point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      const prevIdx = [ i ? i - 1 : len - 1, i - 1 ][isLoop ? 0 : 1];\n      prevPoint = points[prevIdx];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n\n      let v: vec2 = [ 0, 0 ];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n\n      let d0 = vec2.distance(point, prevPoint);\n      let d1 = vec2.distance(point, nextPoint);\n\n      const sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n\n      let v1 = vec2.scale([ 0, 0 ], v, -d0);\n      let v2 = vec2.scale([ 0, 0 ], v, d1);\n\n      cp1 = vec2.add([ 0, 0 ], point, v1);\n      nextCp0 = vec2.add([ 0, 0 ], point, v2);\n\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([ 0, 0 ], nextCp0, vec2.max([ 0, 0 ], nextPoint, point));\n      nextCp0 = vec2.max([ 0, 0 ], nextCp0, vec2.min([ 0, 0 ], nextPoint, point));\n\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([ 0, 0 ], nextCp0, point);\n      v1 = vec2.scale([ 0, 0 ], v1, -d0 / d1);\n      cp1 = vec2.add([ 0, 0 ], point, v1);\n\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([ 0, 0 ], cp1, vec2.max([ 0, 0 ], prevPoint, point));\n      cp1 = vec2.max([ 0, 0 ], cp1, vec2.min([ 0, 0 ], prevPoint, point));\n\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([ 0, 0 ], point, cp1);\n      v2 = vec2.scale([ 0, 0 ], v2, d1 / d0);\n      nextCp0 = vec2.add([ 0, 0 ], point, v2);\n\n      if (hasConstraint) {\n        cp1 = vec2.max([ 0, 0 ], cp1, min);\n        cp1 = vec2.min([ 0, 0 ], cp1, max);\n        nextCp0 = vec2.max([ 0, 0 ], nextCp0, min);\n        nextCp0 = vec2.min([ 0, 0 ], nextCp0, max);\n      }\n\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\n/**\n * create bezier spline from catmull rom spline\n * @param {Array} crp Catmull Rom Points\n * @param {boolean} z Spline is loop\n * @param {Array} constraint Constraint\n */\nfunction catmullRom2Bezier(\n  crp: number[],\n  z: boolean = false,\n  constraint: Pos[] = [\n    [ 0, 0 ],\n    [ 1, 1 ],\n  ]\n): PathCommand[] {\n  const isLoop = !!z;\n  const pointList: Pos[] = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([ crp[i], crp[i + 1] ]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1: PathCommand[] = [];\n\n  let cp1: vec2;\n  let cp2: vec2;\n  let p: Pos;\n\n  for (let i = 0; i < len - 1; i += 1) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n\n    d1.push([ 'C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1] ]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    [ p ] = pointList;\n\n    d1.push([ 'C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1] ]);\n  }\n  return d1;\n}\n\nexport default catmullRom2Bezier;\n","import { isArray } from '@antv/util';\n\nconst SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\nconst PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');\nconst PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');\n\n// Parses given path string into an array of arrays of path segments\nexport default function parsePathString(pathString: string) {\n  if (!pathString) {\n    return null;\n  }\n\n  if (isArray(pathString)) {\n    return pathString;\n  }\n  const paramCounts = {\n    a: 7,\n    c: 6,\n    o: 2,\n    h: 1,\n    l: 2,\n    m: 2,\n    r: 4,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    u: 3,\n    z: 0,\n  };\n  const data = [];\n\n  String(pathString).replace(PATH_COMMAND, function (a, b, c) {\n    const params = [];\n    let name = b.toLowerCase();\n    c.replace(PATH_VALUES, function (a, b) {\n      b && params.push(+b);\n    });\n    if (name === 'm' && params.length > 2) {\n      data.push([ b ].concat(params.splice(0, 2)));\n      name = 'l';\n      b = b === 'm' ? 'l' : 'L';\n    }\n    if (name === 'o' && params.length === 1) {\n      data.push([ b, params[0] ]);\n    }\n    if (name === 'r') {\n      data.push([ b ].concat(params));\n    } else {\n      while (params.length >= paramCounts[name]) {\n        data.push([ b ].concat(params.splice(0, paramCounts[name])));\n        if (!paramCounts[name]) {\n          break;\n        }\n      }\n    }\n    return '';\n  });\n\n  return data;\n}\n","import parsePathString from './parse-path-string';\nconst REGEX_MD = /[a-z]/;\n\nfunction toSymmetry(p, c) { // 点对称\n  return [\n    c[0] + (c[0] - p[0]),\n    c[1] + (c[1] - p[1]),\n  ];\n}\n\nexport default function pathToAbsolute(pathString: string) {\n  const pathArray = parsePathString(pathString);\n\n  if (!pathArray || !pathArray.length) {\n    return [\n      [ 'M', 0, 0 ],\n    ];\n  }\n  let needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n  for (let i = 0; i < pathArray.length; i++) {\n    const cmd = pathArray[i][0];\n    // 如果存在相对位置的命令，则中断返回\n    if (REGEX_MD.test(cmd) || [ 'V', 'H', 'T', 'S' ].indexOf(cmd) >= 0) {\n      needProcess = true;\n      break;\n    }\n  }\n  // 如果不存在相对命令，则直接返回\n  // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n  if (!needProcess) {\n    return pathArray;\n  }\n\n  const res = [];\n  let x = 0;\n  let y = 0;\n  let mx = 0;\n  let my = 0;\n  let start = 0;\n  let pa0;\n  let dots;\n  const first = pathArray[0];\n  if (first[0] === 'M' || first[0] === 'm') {\n    x = +first[1];\n    y = +first[2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = [ 'M', x, y ];\n  }\n\n  for (let i = start, ii = pathArray.length; i < ii; i++) {\n    const pa = pathArray[i];\n    const preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n    let r = [];\n    const cmd = pa[0];\n    const upCmd = cmd.toUpperCase();\n    if (cmd !== upCmd) {\n      r[0] = upCmd;\n      switch (upCmd) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          r[1] = mx;\n          r[2] = my;\n          break; // for lint\n        default:\n          for (let j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + ((j % 2) ? x : y);\n          }\n      }\n    } else { // 如果本来已经大写，则不处理\n      r = pathArray[i];\n    }\n    // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n    switch (upCmd) {\n      case 'Z':\n        x = +mx;\n        y = +my;\n        break;\n      case 'H':\n        x = r[1];\n        r = [ 'L', x, y ];\n        break;\n      case 'V':\n        y = r[1];\n        r = [ 'L', x, y ];\n        break;\n      case 'T':\n        x = r[1];\n        y = r[2];\n        // 以 x, y 为中心的，上一个控制点的对称点\n        // 需要假设上一个节点的命令为 Q\n        const symetricT = toSymmetry([ preParams[1], preParams[2] ], [ preParams[3], preParams[4] ]);\n        r = [ 'Q', symetricT[0], symetricT[1], x, y ];\n        break;\n      case 'S':\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n        // 以 x,y 为中心，取上一个控制点，\n        // 需要假设上一个线段为 C 或者 S\n        const length = preParams.length;\n        const symetricS = toSymmetry(\n          [ preParams[length - 4], preParams[length - 3] ],\n          [ preParams[length - 2], preParams[length - 1] ]);\n        r = [ 'C', symetricS[0], symetricS[1], r[1], r[2], x, y ];\n        break;\n      case 'M':\n        mx = r[r.length - 2];\n        my = r[r.length - 1];\n        break; // for lint\n      default:\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n    }\n    res.push(r);\n  }\n\n  return res;\n}\n","const TAU = Math.PI * 2\n\nconst mapToEllipse = ({ x, y }: { x: number, y: number }, rx: number, ry: number, cosphi: number, sinphi: number, centerx: number, centery: number) => {\n  x *= rx\n  y *= ry\n\n  const xp = cosphi * x - sinphi * y\n  const yp = sinphi * x + cosphi * y\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  }\n}\n\nconst approxUnitArc = (ang1: number, ang2: number) => {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  const a = ang2 === 1.5707963267948966\n    ? 0.551915024494\n    : ang2 === -1.5707963267948966\n      ? -0.551915024494\n      : 4 / 3 * Math.tan(ang2 / 4)\n\n  const x1 = Math.cos(ang1)\n  const y1 = Math.sin(ang1)\n  const x2 = Math.cos(ang1 + ang2)\n  const y2 = Math.sin(ang1 + ang2)\n\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ]\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {\n  const sign = (ux * vy - uy * vx < 0) ? -1 : 1\n\n  let dot = ux * vx + uy * vy\n\n  if (dot > 1) {\n    dot = 1\n  }\n\n  if (dot < -1) {\n    dot = -1\n  }\n\n  return sign * Math.acos(dot)\n}\n\nconst getArcCenter = (\n  px: any,\n  py: any,\n  cx: any,\n  cy: any,\n  rx: number,\n  ry: number,\n  largeArcFlag: number,\n  sweepFlag: number,\n  sinphi: number,\n  cosphi: number,\n  pxp: number,\n  pyp: number\n) => {\n  const rxsq = Math.pow(rx, 2)\n  const rysq = Math.pow(ry, 2)\n  const pxpsq = Math.pow(pxp, 2)\n  const pypsq = Math.pow(pyp, 2)\n\n  let radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq)\n\n  if (radicant < 0) {\n    radicant = 0\n  }\n\n  radicant /= (rxsq * pypsq) + (rysq * pxpsq)\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1)\n\n  const centerxp = radicant * rx / ry * pyp\n  const centeryp = radicant * -ry / rx * pxp\n\n  const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2\n  const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2\n\n  const vx1 = (pxp - centerxp) / rx\n  const vy1 = (pyp - centeryp) / ry\n  const vx2 = (-pxp - centerxp) / rx\n  const vy2 = (-pyp - centeryp) / ry\n\n  let ang1 = vectorAngle(1, 0, vx1, vy1)\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2)\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU\n  }\n\n  return [ centerx, centery, ang1, ang2 ]\n}\n\nconst arcToBezier = ({\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  xAxisRotation = 0,\n  largeArcFlag = 0,\n  sweepFlag = 0\n}) => {\n  const curves = []\n\n  if (rx === 0 || ry === 0) {\n    return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n  }\n\n  const sinphi = Math.sin(xAxisRotation * TAU / 360)\n  const cosphi = Math.cos(xAxisRotation * TAU / 360)\n\n  const pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2\n  const pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2\n\n  if (pxp === 0 && pyp === 0) {\n    return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n  }\n\n  rx = Math.abs(rx)\n  ry = Math.abs(ry)\n\n  const lambda =\n    Math.pow(pxp, 2) / Math.pow(rx, 2) +\n    Math.pow(pyp, 2) / Math.pow(ry, 2)\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda)\n    ry *= Math.sqrt(lambda)\n  }\n\n  let [ centerx, centery, ang1, ang2 ] = getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinphi,\n    cosphi,\n    pxp,\n    pyp\n  )\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n  let ratio = Math.abs(ang2) / (TAU / 4)\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0\n  }\n\n  const segments = Math.max(Math.ceil(ratio), 1)\n\n  ang2 /= segments\n\n  for (let i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2))\n    ang1 += ang2\n  }\n\n  return curves.map(curve => {\n    const { x: x1, y: y1 } = mapToEllipse(curve[ 0 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x: x2, y: y2 } = mapToEllipse(curve[ 1 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x, y } = mapToEllipse(curve[ 2 ], rx, ry, cosphi, sinphi, centerx, centery)\n\n    return { x1, y1, x2, y2, x, y }\n  })\n}\n\nexport function arcToCubic(x1: number, y1: number, rx: number, ry: number, angle: number, LAF: number, SF: number, x2: number, y2: number) {\n  const curves = arcToBezier({\n    px: x1,\n    py: y1,\n    cx: x2,\n    cy: y2,\n    rx,\n    ry,\n    xAxisRotation: angle,\n    largeArcFlag: LAF,\n    sweepFlag: SF,\n  });\n\n  return curves.reduce((prev, cur) => {\n    const { x1, y1, x2, y2, x, y } = cur;\n    prev.push(x1, y1, x2, y2, x, y);\n    return prev;\n  }, [] as number[]);\n}\n","import { mod, toRadian } from '@antv/util';\n\n// 向量长度\nfunction vMag(v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n}\n\n// u.v/|u||v|，计算夹角的余弦值\nfunction vRatio(u, v) {\n  // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\n  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\n}\n\n// 向量角度\nfunction vAngle(u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n}\n\n/**\n * 判断两个点是否重合，点坐标的格式为 [x, y]\n * @param {Array} point1 第一个点\n * @param {Array} point2 第二个点\n */\nexport function isSamePoint(point1, point2) {\n  return point1[0] === point2[0] && point1[1] === point2[1];\n}\n\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\nexport default function getArcParams(startPoint, params) {\n  let rx = params[1];\n  let ry = params[2];\n  const xRotation = mod(toRadian(params[3]), Math.PI * 2);\n  const arcFlag = params[4];\n  const sweepFlag = params[5];\n  // 弧形起点坐标\n  const x1 = startPoint[0];\n  const y1 = startPoint[1];\n  // 弧形终点坐标\n  const x2 = params[6];\n  const y2 = params[7];\n  const xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;\n  const yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;\n  const lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  const diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\n\n  let f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\n\n  if (arcFlag === sweepFlag) {\n    f *= -1;\n  }\n  if (isNaN(f)) {\n    f = 0;\n  }\n\n  // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\n  const cxp = ry ? (f * rx * yp) / ry : 0;\n  const cyp = rx ? (f * -ry * xp) / rx : 0;\n\n  // 椭圆圆心坐标\n  const cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\n  const cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\n\n  // 起始点的单位向量\n  const u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n  // 终止点的单位向量\n  const v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n  // 计算起始点和圆心的连线，与 x 轴正方向的夹角\n  const theta = vAngle([ 1, 0 ], u);\n\n  // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\n  let dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = Math.PI;\n  }\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n  if (sweepFlag === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * Math.PI;\n  }\n  if (sweepFlag === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * Math.PI;\n  }\n  return {\n    cx,\n    cy,\n    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\n    rx: isSamePoint(startPoint, [ x2, y2 ]) ? 0 : rx,\n    ry: isSamePoint(startPoint, [ x2, y2 ]) ? 0 : ry,\n    startAngle: theta,\n    endAngle: theta + dTheta,\n    xRotation,\n    arcFlag,\n    sweepFlag,\n  };\n}\n","import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path';\n\n// 点对称\nfunction toSymmetry(point, center) {\n  return [ center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1]) ];\n}\n\nexport default function getSegments(path) {\n  path = parsePath(path);\n  const segments = [];\n  let currentPoint = null; // 当前图形\n  let nextParams = null; // 下一节点的 path 参数\n  let startMovePoint = null; // 开始 M 的点，可能会有多个\n  let lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n  const count = path.length;\n  for (let i = 0; i < count; i++) {\n    const params = path[i];\n    nextParams = path[i + 1];\n    const command = params[0];\n    // 数学定义上的参数，便于后面的计算\n    const segment = {\n      command,\n      prePoint: currentPoint,\n      params,\n      startTangent: null,\n      endTangent: null,\n    };\n    switch (command) {\n      case 'M':\n        startMovePoint = [ params[1], params[2] ];\n        lastStartMovePointIndex = i;\n        break;\n      case 'A':\n        const arcParams = getArcParams(currentPoint, params);\n        segment['arcParams'] = arcParams;\n        break;\n      default:\n        break;\n    }\n    if (command === 'Z') {\n      // 有了 Z 后，当前节点从开始 M 的点开始\n      currentPoint = startMovePoint;\n      // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n      nextParams = path[lastStartMovePointIndex + 1];\n    } else {\n      const len = params.length;\n      currentPoint = [ params[len - 2], params[len - 1] ];\n    }\n    if (nextParams && nextParams[0] === 'Z') {\n      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n      nextParams = path[lastStartMovePointIndex];\n      if (segments[lastStartMovePointIndex]) {\n        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n        segments[lastStartMovePointIndex].prePoint = currentPoint;\n      }\n    }\n    segment['currentPoint'] = currentPoint;\n    // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n    if (\n      segments[lastStartMovePointIndex] &&\n      isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)\n    ) {\n      segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n    }\n    const nextPoint = nextParams ? [ nextParams[nextParams.length - 2], nextParams[nextParams.length - 1] ] : null;\n    segment['nextPoint'] = nextPoint;\n    // Add startTangent and endTangent\n    const { prePoint } = segment;\n    if ([ 'L', 'H', 'V' ].includes(command)) {\n      segment.startTangent = [ prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1] ];\n      segment.endTangent = [ currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1] ];\n    } else if (command === 'Q') {\n      // 二次贝塞尔曲线只有一个控制点\n      const cp = [ params[1], params[2] ];\n      // 二次贝塞尔曲线的终点为 currentPoint\n      segment.startTangent = [ prePoint[0] - cp[0], prePoint[1] - cp[1] ];\n      segment.endTangent = [ currentPoint[0] - cp[0], currentPoint[1] - cp[1] ];\n    } else if (command === 'T') {\n      const preSegment = segments[i - 1];\n      const cp = toSymmetry(preSegment.currentPoint, prePoint);\n      if (preSegment.command === 'Q') {\n        segment.command = 'Q';\n        segment.startTangent = [ prePoint[0] - cp[0], prePoint[1] - cp[1] ];\n        segment.endTangent = [ currentPoint[0] - cp[0], currentPoint[1] - cp[1] ];\n      } else {\n        segment.command = 'TL';\n        segment.startTangent = [ prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1] ];\n        segment.endTangent = [ currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1] ];\n      }\n    } else if (command === 'C') {\n      // 三次贝塞尔曲线有两个控制点\n      const cp1 = [ params[1], params[2] ];\n      const cp2 = [ params[3], params[4] ];\n      segment.startTangent = [ prePoint[0] - cp1[0], prePoint[1] - cp1[1] ];\n      segment.endTangent = [ currentPoint[0] - cp2[0], currentPoint[1] - cp2[1] ];\n\n      // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\n      }\n      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\n      }\n    } else if (command === 'S') {\n      const preSegment = segments[i - 1];\n      const cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n      const cp2 = [ params[1], params[2] ];\n      if (preSegment.command === 'C') {\n        segment.command = 'C'; // 将 S 命令变换为 C 命令\n        segment.startTangent = [ prePoint[0] - cp1[0], prePoint[1] - cp1[1] ];\n        segment.endTangent = [ currentPoint[0] - cp2[0], currentPoint[1] - cp2[1] ];\n      } else {\n        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n        segment.startTangent = [ prePoint[0] - cp2[0], prePoint[1] - cp2[1] ];\n        segment.endTangent = [ currentPoint[0] - cp2[0], currentPoint[1] - cp2[1] ];\n      }\n    } else if (command === 'A') {\n      let d = 0.001;\n      const {\n        cx = 0,\n        cy = 0,\n        rx = 0,\n        ry = 0,\n        sweepFlag = 0,\n        startAngle = 0,\n        endAngle = 0,\n      } = segment['arcParams'] || {};\n      if (sweepFlag === 0) {\n        d *= -1;\n      }\n      const dx1 = rx * Math.cos(startAngle - d) + cx;\n      const dy1 = ry * Math.sin(startAngle - d) + cy;\n      segment.startTangent = [ dx1 - startMovePoint[0], dy1 - startMovePoint[1] ];\n      const dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n      const dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n      segment.endTangent = [ prePoint[0] - dx2, prePoint[1] - dy2 ];\n    }\n    segments.push(segment);\n  }\n  return segments;\n}\n","/**\n * @fileoverview 判断点是否在多边形内\n * @author dxq613@gmail.com\n */\n\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nconst tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n\n  return x < 0 ? -1 : 1;\n}\n\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1, p2, q) {\n  if (\n    (q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n    Math.min(p1[0], p2[0]) <= q[0] &&\n    q[0] <= Math.max(p1[0], p2[0]) &&\n    Math.min(p1[1], p2[1]) <= q[1] &&\n    q[1] <= Math.max(p1[1], p2[1])\n  ) {\n    return true;\n  }\n  return false;\n}\n\n// 判断点P在多边形内-射线法\nexport default function isInPolygon(points, x, y) {\n  let isHit = false;\n  const n = points.length;\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (\n      dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n      dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0\n    ) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n}\n","type Point = {\n  /**\n   * x 值\n   * @type {number}\n   */\n  x: number;\n  /**\n   * y 值\n   * @type {number}\n   */\n  y: number;\n};\n\nconst isBetween = (value: number, min: number, max: number) => value >= min && value <= max;\n\n\nexport default function getLineIntersect(p0: Point, p1: Point, p2: Point, p3: Point): Point | null {\n  const tolerance = 0.001;\n  const E: Point = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y,\n  };\n  const D0: Point = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y,\n  };\n  const D1: Point = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y,\n  };\n  const kross: number = D0.x * D1.y - D0.y * D1.x;\n  const sqrKross: number = kross * kross;\n  const sqrLen0: number = D0.x * D0.x + D0.y * D0.y;\n  const sqrLen1: number = D1.x * D1.x + D1.y * D1.y;\n  let point: Point | null = null;\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    const s = (E.x * D1.y - E.y * D1.x) / kross;\n    const t = (E.x * D0.y - E.y * D0.x) / kross;\n    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {\n      point = {\n        x: p0.x + s * D0.x,\n        y: p0.y + s * D0.y,\n      };\n    }\n  }\n  return point;\n};","\nimport isPointInPolygon from './point-in-polygon';\nimport getLineIntersect from './get-line-intersect';\nimport {each} from '@antv/util';\n\nfunction parseToLines(points) {\n  const lines = [];\n  const count = points.length;\n  for(let i = 0; i < count - 1; i++) {\n    const point = points[i];\n    const next = points[i + 1];\n    lines.push({\n      from: {\n        x: point[0],\n        y: point[1]\n      },\n      to: {\n        x: next[0],\n        y: next[1]\n      }\n    });\n  }\n  if (lines.length > 1) {\n    const first = points[0];\n    const last = points[count - 1];\n    lines.push({\n      from: {\n        x: last[0],\n        y: last[1]\n      },\n      to: {\n        x: first[0],\n        y: first[1]\n      }\n    });\n  }\n  return lines;\n}\n\nfunction lineIntersectPolygon(lines, line) {\n  let isIntersect = false;\n  each(lines, l => {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}\n\ntype BBox = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n};\n\nfunction getBBox(points): BBox {\n  const xArr = points.map(p => p[0]);\n  const yArr = points.map(p => p[1]);\n  return {\n    minX: Math.min.apply(null, xArr),\n    maxX: Math.max.apply(null, xArr),\n    minY: Math.min.apply(null, yArr),\n    maxY: Math.max.apply(null, yArr)\n  };\n}\n\nfunction intersectBBox(box1:BBox, box2:BBox) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n\nexport default function isPolygonsIntersect(points1, points2) {\n  // 空数组，或者一个点返回 false\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  const bbox1 = getBBox(points1);\n  const bbox2 = getBBox(points2);\n  // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n  \n  let isIn = false;\n  // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n  each(points2, point => {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n  // 两个多边形都需要判定\n  each(points1, point => {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n  if (isIn) {\n    return true;\n  }\n\n  const lines1 = parseToLines(points1);\n  const lines2 = parseToLines(points2);\n  let isIntersect = false;\n  each(lines2, line => {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n}"],"names":["regexTags","regexDot","p","path","isArray","isString","match","each","item","index","length","tag","charAt","splice","substr","sub","i","isNaN","crp","z","constraint","isLoop","pointList","l","push","cp1","cp2","controlPointList","points","smooth","prevPoint","nextPoint","min","max","nextCp0","cp0","cps","hasConstraint","point","vec2","len","v","d0","d1","sum","v1","v2","shift","smoothBezier","SPACES","PATH_COMMAND","RegExp","PATH_VALUES","parsePathString","pathString","paramCounts","a","c","o","h","m","r","q","s","t","u","data","String","replace","b","params","name","toLowerCase","concat","REGEX_MD","toSymmetry","pathToAbsolute","pathArray","needProcess","cmd","test","indexOf","res","x","y","mx","my","start","first","ii","pa","preParams","upCmd","toUpperCase","j","jj","symetricT","length_1","symetricS","Math","PI","vMag","sqrt","vRatio","vAngle","acos","isSamePoint","point1","point2","getArcParams","startPoint","rx","ry","xRotation","mod","toRadian","arcFlag","sweepFlag","x1","y1","x2","y2","xp","cos","sin","yp","lambda","diff","f","cxp","cyp","cx","cy","theta","dTheta","startAngle","endAngle","center","getSegments","segments","currentPoint","nextParams","startMovePoint","lastStartMovePointIndex","count","parsePath","command","segment","prePoint","startTangent","endTangent","arcParams","includes","cp","preSegment","d","_b","_c","_d","_e","_f","_g","_h","dx1","dy1","dx2","dy2","dcmp","abs","onSegment","p1","p2","isInPolygon","isHit","n","isBetween","value","parseToLines","lines","next","from","to","last","lineIntersectPolygon","line","isIntersect","p0","p3","E","D0","D1","kross","getLineIntersect","getBBox","xArr","map","yArr","minX","apply","maxX","minY","maxY","isPolygonsIntersect","points1","points2","box1","box2","bbox1","bbox2","isIn","isPointInPolygon","lines1","lines2"],"sourceRoot":""}