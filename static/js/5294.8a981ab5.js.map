{"version":3,"file":"static/js/5294.8a981ab5.js","mappings":"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","sources":["../node_modules/@antv/component/src/axis/base.ts","../node_modules/@antv/component/src/axis/line.ts","../node_modules/@antv/component/src/axis/circle.ts"],"sourcesContent":["import { IGroup, IShape } from '@antv/g-base';\nimport { ext } from '@antv/matrix-util';\nimport { each, filter, get, isFunction, isNil, isNumberEqual, mix, size, isArray } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nimport { IList } from '../interfaces';\nimport { AxisBaseCfg, ListItem, OptimizeCfg, Point } from '../types';\nimport { getMatrixByAngle } from '../util/matrix';\nimport { getStatesStyle } from '../util/state';\nimport Theme from '../util/theme';\n\nabstract class AxisBase<T extends AxisBaseCfg = AxisBaseCfg> extends GroupComponent<T> implements IList {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      name: 'axis',\n      ticks: [],\n      line: {},\n      tickLine: {},\n      subTickLine: null,\n      title: null,\n      /**\n       * 文本标签的配置项\n       */\n      label: {},\n      /**\n       * 垂直于坐标轴方向的因子，决定文本、title、tickLine 在坐标轴的哪一侧\n       */\n      verticalFactor: 1,\n      // 垂直方向限制的长度，对文本自适应有很大影响\n      verticalLimitLength: null,\n      overlapOrder: ['autoRotate', 'autoEllipsis', 'autoHide'],\n      tickStates: {},\n      optimize: {},\n      defaultCfg: {\n        line: {\n          // @type {Attrs} 坐标轴线的图形属性,如果设置成null，则不显示轴线\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor,\n          },\n        },\n        tickLine: {\n          // @type {Attrs} 标注坐标线的图形属性\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor,\n          },\n          alignTick: true, // 是否同 tick 对齐\n          length: 5,\n          displayWithLabel: true,\n        },\n        subTickLine: {\n          // @type {Attrs} 标注坐标线的图形属性\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor,\n          },\n          count: 4, // 子刻度线的数量，将两个刻度线划分成 5 份\n          length: 2,\n        },\n        label: {\n          autoRotate: true,\n          autoHide: false,\n          autoEllipsis: false,\n          style: {\n            fontSize: 12,\n            fill: Theme.textColor,\n            fontFamily: Theme.fontFamily,\n            fontWeight: 'normal',\n          },\n          offset: 10,\n          offsetX: 0,\n          offsetY: 0,\n        },\n        title: {\n          autoRotate: true,\n          spacing: 5,\n          position: 'center', // start, center, end\n          style: {\n            fontSize: 12,\n            fill: Theme.textColor,\n            textBaseline: 'middle',\n            fontFamily: Theme.fontFamily,\n            textAlign: 'center',\n          },\n          iconStyle: {\n            fill: Theme.descriptionIconFill,\n            stroke: Theme.descriptionIconStroke,\n          },\n          description: ''\n        },\n        tickStates: {\n          active: {\n            labelStyle: {\n              fontWeight: 500,\n            },\n            tickLineStyle: {\n              lineWidth: 2,\n            },\n          },\n          inactive: {\n            labelStyle: {\n              fill: Theme.uncheckedColor,\n            },\n          },\n        },\n        // 针对大数据量进行优化配置\n        optimize: {\n          enable: true,\n          threshold: 400,\n        },\n      },\n      theme: {},\n    };\n  }\n\n  /**\n   * 绘制组件\n   */\n  public renderInner(group: IGroup) {\n    if (this.get('line')) {\n      this.drawLine(group);\n    }\n    // drawTicks 包括 drawLabels 和 drawTickLines\n    this.drawTicks(group);\n    if (this.get('title')) {\n      this.drawTitle(group);\n    }\n  }\n\n  // 实现 IList 接口\n  public isList(): boolean {\n    return true;\n  }\n\n  /**\n   * 获取图例项\n   * @return {ListItem[]} 列表项集合\n   */\n  public getItems(): ListItem[] {\n    return this.get('ticks');\n  }\n\n  /**\n   * 设置列表项\n   * @param {ListItem[]} items 列表项集合\n   */\n  public setItems(items: ListItem[]) {\n    this.update({\n      ticks: items,\n    } as Partial<T>);\n  }\n\n  /**\n   * 更新列表项\n   * @param {ListItem} item 列表项\n   * @param {object}   cfg  列表项\n   */\n  public updateItem(item: ListItem, cfg: object) {\n    mix(item, cfg);\n    this.clear(); // 由于单个图例项变化，会引起全局变化，所以全部更新\n    this.render();\n  }\n\n  /**\n   * 清空列表\n   */\n  public clearItems() {\n    const itemGroup = this.getElementByLocalId('label-group');\n    itemGroup && itemGroup.clear();\n  }\n\n  /**\n   * 设置列表项的状态\n   * @param {ListItem} item  列表项\n   * @param {string}   state 状态名\n   * @param {boolean}  value 状态值, true, false\n   */\n  public setItemState(item: ListItem, state: string, value: boolean) {\n    item[state] = value;\n    this.updateTickStates(item); // 应用状态样式\n  }\n\n  /**\n   * 是否存在指定的状态\n   * @param {ListItem} item  列表项\n   * @param {boolean} state 状态名\n   */\n  public hasState(item: ListItem, state: string): boolean {\n    return !!item[state];\n  }\n\n  public getItemStates(item: ListItem): string[] {\n    const tickStates = this.get('tickStates');\n    const rst = [];\n    each(tickStates, (v, k) => {\n      if (item[k]) {\n        // item.selected\n        rst.push(k);\n      }\n    });\n    return rst;\n  }\n\n  /**\n   * 清楚所有列表项的状态\n   * @param {string} state 状态值\n   */\n  public clearItemsState(state: string) {\n    const items = this.getItemsByState(state);\n    each(items, (item) => {\n      this.setItemState(item, state, false);\n    });\n  }\n\n  /**\n   * 根据状态获取图例项\n   * @param  {string}     state [description]\n   * @return {ListItem[]}       [description]\n   */\n  public getItemsByState(state: string): ListItem[] {\n    const items = this.getItems();\n    return filter(items, (item) => {\n      return this.hasState(item, state);\n    });\n  }\n\n  /**\n   * @protected\n   * 获取坐标轴线的路径，不同的坐标轴不一样\n   */\n  protected abstract getLinePath(): any[];\n\n  /**\n   * 获取坐标轴垂直方向的向量\n   * @param {number} offset 距离点距离\n   * @param {Point} point  坐标轴上的一点\n   */\n  protected abstract getSideVector(offset: number, point: Point);\n  /**\n   * 获取坐标轴的向量\n   * @param {Point} point 坐标轴上的点\n   */\n  protected abstract getAxisVector(point: Point): [number, number];\n\n  protected getSidePoint(point: Point, offset: number): Point {\n    const self = this;\n    const vector = self.getSideVector(offset, point);\n    return {\n      x: point.x + vector[0],\n      y: point.y + vector[1],\n    };\n  }\n\n  /**\n   * 根据 tick.value 获取坐标轴上对应的点\n   * @param {number} tickValue\n   * @returns {Point}\n   */\n  protected abstract getTickPoint(tickValue: number): Point;\n\n  protected getTextAnchor(vector: number[]): string {\n    let align;\n    if (isNumberEqual(vector[0], 0)) {\n      align = 'center';\n    } else if (vector[0] > 0) {\n      align = 'start';\n    } else if (vector[0] < 0) {\n      align = 'end';\n    }\n    return align;\n  }\n\n  protected getTextBaseline(vector: number[]): string {\n    let base;\n    if (isNumberEqual(vector[1], 0)) {\n      base = 'middle';\n    } else if (vector[1] > 0) {\n      base = 'top';\n    } else if (vector[1] < 0) {\n      base = 'bottom';\n    }\n    return base;\n  }\n\n  protected processOverlap(labelGroup) {}\n\n  // 绘制坐标轴线\n  private drawLine(group: IGroup) {\n    const path = this.getLinePath();\n    const line = this.get('line'); // line 的判空在调用 drawLine 之前，不在这里判定\n    this.addShape(group, {\n      type: 'path',\n      id: this.getElementId('line'),\n      name: 'axis-line',\n      attrs: mix(\n        {\n          path,\n        },\n        line.style\n      ),\n    });\n  }\n\n  private getTickLineItems(ticks: ListItem[]) {\n    const tickLineItems = [];\n    const tickLine = this.get('tickLine');\n    const alignTick = tickLine.alignTick;\n    const tickLineLength = tickLine.length;\n    let tickSegment = 1;\n    const tickCount = ticks.length;\n    if (tickCount >= 2) {\n      tickSegment = ticks[1].value - ticks[0].value;\n    }\n\n    each(ticks, (tick) => {\n      let point = tick.point;\n      if (!alignTick) {\n        // tickLine 不同 tick 对齐时需要调整 point\n        point = this.getTickPoint(tick.value - tickSegment / 2);\n      }\n      const endPoint = this.getSidePoint(point, tickLineLength);\n      tickLineItems.push({\n        startPoint: point,\n        tickValue: tick.value,\n        endPoint,\n        tickId: tick.id,\n        id: `tickline-${tick.id}`,\n      });\n    });\n\n    // 如果 tickLine 不居中对齐，则需要在最后面补充一个 tickLine\n    // if (!alignTick && tickCount > 0) {\n    //   const tick = ticks[tickCount - 1];\n    //   const point = this.getTickPoint(tick.value + tickSegment / 2);\n    // }\n    return tickLineItems;\n  }\n\n  private getSubTickLineItems(tickLineItems) {\n    const subTickLineItems = [];\n    const subTickLine = this.get('subTickLine');\n    const subCount = subTickLine.count;\n    const tickLineCount = tickLineItems.length;\n    // 刻度线的数量大于 2 时，才绘制子刻度\n    if (tickLineCount >= 2) {\n      for (let i = 0; i < tickLineCount - 1; i++) {\n        const pre = tickLineItems[i];\n        const next = tickLineItems[i + 1];\n        for (let j = 0; j < subCount; j++) {\n          const percent = (j + 1) / (subCount + 1);\n          const tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;\n          const point = this.getTickPoint(tickValue);\n          const endPoint = this.getSidePoint(point, subTickLine.length);\n          subTickLineItems.push({\n            startPoint: point,\n            endPoint,\n            tickValue,\n            id: `sub-${pre.id}-${j}`,\n          });\n        }\n      }\n    }\n    return subTickLineItems;\n  }\n\n  private getTickLineAttrs(tickItem: ListItem, type: string, index: number, tickItems: ListItem[]) {\n    let style = this.get(type).style;\n\n    // 保持和 grid 相同的数据结构\n    const item = {\n      points: [tickItem.startPoint, tickItem.endPoint],\n    };\n\n    const defaultTickLineStyle = get(this.get('theme'), ['tickLine', 'style'], {});\n    style = isFunction(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;\n\n    const { startPoint, endPoint } = tickItem;\n    return {\n      x1: startPoint.x,\n      y1: startPoint.y,\n      x2: endPoint.x,\n      y2: endPoint.y,\n      ...style,\n    };\n  }\n\n  // 绘制坐标轴刻度线\n  private drawTick(tickItem: ListItem, tickLineGroup: IGroup, type: string, index: number, tickItems: ListItem[]) {\n    this.addShape(tickLineGroup, {\n      type: 'line',\n      id: this.getElementId(tickItem.id),\n      name: `axis-${type}`,\n      attrs: this.getTickLineAttrs(tickItem, type, index, tickItems),\n    });\n  }\n\n  // 绘制坐标轴刻度线，包括子刻度线\n  private drawTickLines(group: IGroup) {\n    const ticks = this.get('ticks');\n    const subTickLine = this.get('subTickLine');\n    const tickLineItems = this.getTickLineItems(ticks);\n    const tickLineGroup = this.addGroup(group, {\n      name: 'axis-tickline-group',\n      id: this.getElementId('tickline-group'),\n    });\n    const tickCfg = this.get('tickLine');\n    each(tickLineItems, (item, index) => {\n      if (tickCfg.displayWithLabel) {\n        // 如果跟随 label 显示，则检测是否存在对应的 label\n        const labelId = this.getElementId(`label-${item.tickId}`);\n        if (group.findById(labelId)) {\n          this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);\n        }\n      } else {\n        this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);\n      }\n    });\n\n    if (subTickLine) {\n      const subTickLineItems = this.getSubTickLineItems(tickLineItems);\n      each(subTickLineItems, (item, index: number) => {\n        this.drawTick(item, tickLineGroup, 'subTickLine', index, subTickLineItems);\n      });\n    }\n  }\n\n  // 预处理 ticks 确定位置和补充 id\n  private processTicks() {\n    const ticks = this.get('ticks');\n    each(ticks, (tick) => {\n      tick.point = this.getTickPoint(tick.value);\n      // 补充 tick 的 id，为动画和更新做准备\n      if (isNil(tick.id)) {\n        // 默认使用 tick.name 作为id\n        tick.id = tick.name;\n      }\n    });\n  }\n\n  // 绘制 ticks 包括文本和 tickLine\n  private drawTicks(group: IGroup) {\n    this.optimizeTicks();\n    this.processTicks();\n    if (this.get('label')) {\n      this.drawLabels(group);\n    }\n\n    if (this.get('tickLine')) {\n      this.drawTickLines(group);\n    }\n\n    const ticks = this.get('ticks');\n    each(ticks, (tick) => {\n      this.applyTickStates(tick, group);\n    });\n  }\n\n  /**\n   * 根据 optimize 配置对 ticks 进行抽样，对抽样过后的 ticks 才进行真实的渲染\n   */\n  private optimizeTicks() {\n    const optimize: OptimizeCfg = this.get('optimize');\n    const ticks = this.get('ticks');\n    if (optimize && optimize.enable && optimize.threshold > 0) {\n      const len = size(ticks);\n      if (len > optimize.threshold) {\n        const page = Math.ceil(len / optimize.threshold);\n        const optimizedTicks = ticks.filter((tick, idx) => idx % page === 0);\n        this.set('ticks', optimizedTicks);\n        this.set('originalTicks', ticks);\n      }\n    }\n  }\n\n  // 获取 label 的配置项\n  private getLabelAttrs(tick: ListItem, index: number, ticks: ListItem[]) {\n    const labelCfg = this.get('label');\n    const { offset, offsetX, offsetY, rotate, formatter } = labelCfg;\n    const point = this.getSidePoint(tick.point, offset);\n    const vector = this.getSideVector(offset, point);\n    const text = formatter ? formatter(tick.name, tick, index) : tick.name;\n    let { style } = labelCfg;\n    style = isFunction(style) ? get(this.get('theme'), ['label', 'style'], {}) : style;\n\n    const attrs = mix(\n      {\n        x: point.x + offsetX,\n        y: point.y + offsetY,\n        text,\n        textAlign: this.getTextAnchor(vector),\n        textBaseline: this.getTextBaseline(vector),\n      },\n      style\n    );\n    if (rotate) {\n      attrs.matrix = getMatrixByAngle(point, rotate);\n    }\n    return attrs;\n  }\n\n  // 绘制文本\n  private drawLabels(group: IGroup) {\n    const ticks = this.get('ticks');\n    const labelGroup = this.addGroup(group, {\n      name: 'axis-label-group',\n      id: this.getElementId('label-group'),\n    });\n    each(ticks, (tick: ListItem, index: number) => {\n      this.addShape(labelGroup, {\n        type: 'text',\n        name: 'axis-label',\n        id: this.getElementId(`label-${tick.id}`),\n        attrs: this.getLabelAttrs(tick, index, ticks),\n        delegateObject: {\n          tick,\n          item: tick,\n          index,\n        },\n      });\n    });\n    this.processOverlap(labelGroup);\n\n    // 处理完后再进行 style 回调处理\n    const labels = labelGroup.getChildren();\n    const defaultLabelStyle = get(this.get('theme'), ['label', 'style'], {});\n    const { style, formatter } = this.get('label');\n    if (isFunction(style)) {\n      const afterProcessTicks = labels.map((label) => get(label.get('delegateObject'), 'tick'));\n      each(labels, (label, index) => {\n        const { tick } = label.get('delegateObject');\n        const text = formatter ? formatter(tick.name, tick, index) : tick.name;\n        const newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks));\n        label.attr(newStyle);\n      });\n    }\n  }\n\n  // 标题的属性\n  private getTitleAttrs() {\n    const titleCfg = this.get('title');\n    const { style, position, offset, spacing = 0, autoRotate } = titleCfg;\n    const titleHeight = style.fontSize;\n    let percent = 0.5;\n    if (position === 'start') {\n      percent = 0;\n    } else if (position === 'end') {\n      percent = 1;\n    }\n    const point = this.getTickPoint(percent); // 标题对应的坐标轴上的点\n    // 如果没有指定 titleOffset 也没有渲染 label，这里需要自动计算 offset\n    const titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2); // 标题的点\n\n    const attrs = mix(\n      {\n        x: titlePoint.x,\n        y: titlePoint.y,\n        text: titleCfg.text,\n      },\n      style\n    );\n\n    const rotate = titleCfg.rotate; // rotate 是角度值\n    let angle = rotate;\n    if (isNil(rotate) && autoRotate) {\n      // 用户没有设定旋转角度，同时设置自动旋转\n      const vector = this.getAxisVector(point);\n      const v1: [number, number] = [1, 0]; // 水平方向的向量\n      angle = ext.angleTo(vector, v1, true);\n    }\n    if (angle) {\n      const matrix = getMatrixByAngle(titlePoint, angle);\n      attrs.matrix = matrix;\n    }\n    return attrs;\n  }\n\n  // 绘制标题\n  private drawTitle(group: IGroup) {\n    const titleAttrs = this.getTitleAttrs();\n    const titleShape = this.addShape(group, {\n      type: 'text',\n      id: this.getElementId('title'),\n      name: 'axis-title',\n      attrs: titleAttrs\n    });\n    // description字段存在时，显示icon\n    if(this.get('title')?.description) {\n      this.drawDescriptionIcon(group, titleShape, titleAttrs.matrix)\n    }\n  }\n\n  private drawDescriptionIcon(group: IGroup, titleShape: IShape, matrix: number[]) {\n    const descriptionShape = this.addGroup(group, {\n      name: 'axis-description',\n      id: this.getElementById('description')\n    })\n\n    const { maxX, maxY, height } = titleShape.getBBox();\n    const { iconStyle } = this.get('title')\n    const spacing = 4; // 设置icon与文本之间距离\n    const r = height / 2;\n    const lineWidth =  r / 6;\n    const startX = maxX + spacing;\n    const startY = maxY - height / 2;\n    // 绘制 information icon 路径\n    // 外圆环path\n    const [x0, y0] = [startX + r, startY - r];\n    const [x1, y1] = [x0 + r, y0 + r];\n    const [x2, y2] = [x0, y1 + r];\n    const [x3, y3] = [startX, y0 + r];\n    // i path\n    const [x4, y4] = [startX + r, startY - height / 4];\n    const [x5, y5] = [x4, y4 + lineWidth];\n    const [x6, y6] = [x5, y5 + lineWidth];\n    const [x7, y7] = [x6, y6 + r * 3 / 4];\n    this.addShape(descriptionShape, {\n      type: 'path',\n      id: this.getElementId('title-description-icon'),\n      name: 'axis-title-description-icon',\n      attrs: {\n        path: [\n          ['M', x0, y0],\n          ['A', r, r, 0, 0, 1, x1, y1],\n          ['A', r, r, 0, 0, 1, x2, y2],\n          ['A', r, r, 0, 0, 1, x3, y3],\n          ['A', r, r, 0, 0, 1, x0, y0],\n          ['M', x4, y4],\n          ['L', x5, y5],\n          ['M', x6, y6],\n          ['L', x7, y7]\n        ],\n        lineWidth,\n        matrix,\n        ...iconStyle\n      },\n    });\n    // 点击热区，设置透明矩形\n    this.addShape(descriptionShape, {\n      type: 'rect',\n      id: this.getElementId('title-description-rect'),\n      name: 'axis-title-description-rect',\n      attrs: {\n        x: startX,\n        y: startY - height / 2,\n        width: height,\n        height,\n        stroke: '#000',\n        fill: '#000',\n        opacity: 0,\n        matrix,\n        cursor: 'pointer'\n      }\n    })\n\n  }\n\n  private applyTickStates(tick, group) {\n    const states = this.getItemStates(tick);\n    if (states.length) {\n      const tickStates = this.get('tickStates');\n      // 分别更新 label 和 tickLine\n      const labelId = this.getElementId(`label-${tick.id}`);\n      const labelShape = group.findById(labelId);\n      if (labelShape) {\n        const labelStateStyle = getStatesStyle(tick, 'label', tickStates);\n        labelStateStyle && labelShape.attr(labelStateStyle);\n      }\n      const tickLineId = this.getElementId(`tickline-${tick.id}`);\n      const tickLineShape = group.findById(tickLineId);\n      if (tickLineShape) {\n        const tickLineStateStyle = getStatesStyle(tick, 'tickLine', tickStates);\n        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);\n      }\n    }\n  }\n\n  private updateTickStates(tick) {\n    const states = this.getItemStates(tick);\n    const tickStates = this.get('tickStates');\n    const labelCfg = this.get('label');\n    const labelShape = this.getElementByLocalId(`label-${tick.id}`);\n    const tickLineCfg = this.get('tickLine');\n    const tickLineShape = this.getElementByLocalId(`tickline-${tick.id}`);\n\n    if (states.length) {\n      if (labelShape) {\n        const labelStateStyle = getStatesStyle(tick, 'label', tickStates);\n        labelStateStyle && labelShape.attr(labelStateStyle);\n      }\n      if (tickLineShape) {\n        const tickLineStateStyle = getStatesStyle(tick, 'tickLine', tickStates);\n        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);\n      }\n    } else {\n      if (labelShape) {\n        labelShape.attr(labelCfg.style);\n      }\n      if (tickLineShape) {\n        tickLineShape.attr(tickLineCfg.style);\n      }\n    }\n  }\n}\n\nexport default AxisBase;\n","import { IGroup } from '@antv/g-base';\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\nimport { ILocation } from '../interfaces';\nimport { AxisLabelAutoHideCfg, BBox, LineAxisCfg, Point, RegionLocationCfg } from '../types';\nimport Theme from '../util/theme';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\n\nclass Line extends AxisBase<LineAxisCfg> implements ILocation<RegionLocationCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'line',\n      locationType: 'region',\n      /**\n       * 起始点, x, y\n       * @type {object}\n       */\n      start: null,\n      /**\n       * 结束点, x, y\n       * @type {object}\n       */\n      end: null,\n    };\n  }\n\n  // 获取坐标轴线的 path\n  public getLinePath(): any[] {\n    const start = this.get('start');\n    const end = this.get('end');\n    const path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  }\n\n  // 重新计算 layout bbox，考虑到 line 不显示\n  protected getInnerLayoutBBox(): BBox {\n    const start = this.get('start');\n    const end = this.get('end');\n    const bbox = super.getInnerLayoutBBox();\n    const minX = Math.min(start.x, end.x, bbox.x);\n    const minY = Math.min(start.y, end.y, bbox.y);\n    const maxX = Math.max(start.x, end.x, bbox.maxX);\n    const maxY = Math.max(start.y, end.y, bbox.maxY);\n    return {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n\n  protected isVertical() {\n    const start = this.get('start');\n    const end = this.get('end');\n    return isNumberEqual(start.x, end.x);\n  }\n\n  protected isHorizontal() {\n    const start = this.get('start');\n    const end = this.get('end');\n    return isNumberEqual(start.y, end.y);\n  }\n\n  protected getTickPoint(tickValue: number): Point {\n    const self = this;\n    const start = self.get('start');\n    const end = self.get('end');\n    const regionX = end.x - start.x;\n    const regionY = end.y - start.y;\n    return {\n      x: start.x + regionX * tickValue,\n      y: start.y + regionY * tickValue,\n    };\n  }\n\n  // 直线坐标轴下任一点的向量方向都相同\n  protected getSideVector(offset: number) {\n    const axisVector = this.getAxisVector();\n    const normal = vec2.normalize([0, 0], axisVector);\n    const factor = this.get('verticalFactor');\n    const verticalVector: [number, number] = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n    return vec2.scale([0, 0], verticalVector, offset * factor);\n  }\n\n  // 获取坐标轴的向量\n  protected getAxisVector(): [number, number] {\n    const start = this.get('start');\n    const end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  }\n\n  protected processOverlap(labelGroup) {\n    const isVertical = this.isVertical();\n    const isHorizontal = this.isHorizontal();\n    // 非垂直，或者非水平时不处理遮挡问题\n    if (!isVertical && !isHorizontal) {\n      return;\n    }\n    const labelCfg = this.get('label');\n    const titleCfg = this.get('title');\n    const verticalLimitLength = this.get('verticalLimitLength');\n    const labelOffset = labelCfg.offset;\n    let limitLength = verticalLimitLength;\n    let titleHeight = 0;\n    let titleSpacing = 0;\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n    const overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, (name) => {\n      if (labelCfg[name] && this.canProcessOverlap(name)) {\n        this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        const bbox = labelGroup.getCanvasBBox();\n        const length = isVertical ? bbox.width : bbox.height;\n        // 如果用户没有设置 offset，则自动计算\n        titleCfg.offset = labelOffset + length + titleSpacing + titleHeight / 2;\n      }\n    }\n  }\n\n  /**\n   * 是否可以执行某一 overlap\n   * @param name\n   */\n  private canProcessOverlap(name: string) {\n    const labelCfg = this.get('label');\n\n    // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    }\n\n    // 默认所有 overlap 都可执行\n    return true;\n  }\n\n  private autoProcessOverlap(name: string, value: any, labelGroup: IGroup, limitLength: number) {\n    const isVertical = this.isVertical();\n    let hasAdjusted = false;\n    const util = OverlapUtil[name];\n    if (value === true) {\n      const labelCfg = this.get('label');\n      // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n      hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n    } else if (isFunction(value)) {\n      // 回调函数形式的配置： 用户可以传入回调函数\n      hasAdjusted = value(isVertical, labelGroup, limitLength);\n    } else if (isObject(value)) {\n      // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n      const overlapCfg = value as { type: string; cfg?: AxisLabelAutoHideCfg };\n      if (util[overlapCfg.type]) {\n        hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\n      }\n    } else if (util[value]) {\n      // 字符串类型的配置：按照名称执行 overlap 处理方法\n      hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n    }\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        const labels = labelGroup.getChildren();\n        const verticalFactor = this.get('verticalFactor');\n        each(labels, (label) => {\n          const textAlign = label.attr('textAlign');\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            const newAlign = verticalFactor > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      const children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n      each(children, (label) => {\n        if (!label.get('visible')) {\n          if (this.get('isRegister')) {\n            // 已经注册过了，则删除\n            this.unregisterElement(label);\n          }\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  }\n}\n\nexport default Line;\n","import { IGroup } from '@antv/g-base';\nimport { each, isNil, isFunction, isObject } from '@antv/util';\nimport { vec2 } from '@antv/matrix-util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nimport type { AxisLabelAutoHideCfg } from '../types';\nimport type { CircleAxisCfg, Point, } from '../types';\n\nclass Circle extends AxisBase<CircleAxisCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: null,\n      startAngle: -Math.PI / 2,\n      endAngle: (Math.PI * 3) / 2,\n    };\n  }\n\n  protected getLinePath(): any[] {\n    const center = this.get('center');\n    const x = center.x;\n    const y = center.y;\n    const rx = this.get('radius');\n    const ry = rx;\n    const startAngle = this.get('startAngle');\n    const endAngle = this.get('endAngle');\n\n    let path = [];\n    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {\n      path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];\n    } else {\n      const startPoint = this.getCirclePoint(startAngle);\n      const endPoint = this.getCirclePoint(endAngle);\n      const large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      const sweep = startAngle > endAngle ? 0 : 1;\n      path = [\n        ['M', x, y],\n        ['L', startPoint.x, startPoint.y],\n        ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y],\n        ['L', x, y],\n      ];\n    }\n    return path;\n  }\n\n  protected getTickPoint(tickValue): Point {\n    const startAngle = this.get('startAngle');\n    const endAngle = this.get('endAngle');\n    const angle = startAngle + (endAngle - startAngle) * tickValue;\n    return this.getCirclePoint(angle);\n  }\n\n  // 获取垂直于坐标轴的向量\n  protected getSideVector(offset: number, point: Point) {\n    const center = this.get('center');\n    const vector: [number, number] = [point.x - center.x, point.y - center.y];\n    const factor = this.get('verticalFactor');\n    const vecLen = vec2.length(vector);\n    vec2.scale(vector, vector, (factor * offset) / vecLen);\n    return vector;\n  }\n\n  // 获取沿坐标轴方向的向量\n  protected getAxisVector(point: Point): [number, number] {\n    const center = this.get('center');\n    const vector = [point.x - center.x, point.y - center.y];\n    return [vector[1], -1 * vector[0]]; // 获取顺时针方向的向量\n  }\n\n  // 根据圆心和半径获取点\n  private getCirclePoint(angle: number, radius?: number) {\n    const center = this.get('center');\n    radius = radius || this.get('radius');\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius,\n    };\n  }\n\n  /**\n   * 是否可以执行某一 overlap\n   * @param name\n   */\n  private canProcessOverlap(name: string) {\n    const labelCfg = this.get('label');\n\n    // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    }\n\n    // 默认所有 overlap 都可执行\n    return true;\n  }\n\n  protected processOverlap(labelGroup) {\n    const labelCfg = this.get('label');\n    const titleCfg = this.get('title');\n    const verticalLimitLength = this.get('verticalLimitLength');\n    const labelOffset = labelCfg.offset;\n    let limitLength = verticalLimitLength;\n    let titleHeight = 0;\n    let titleSpacing = 0;\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n    const overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, (name) => {\n      if (labelCfg[name] && this.canProcessOverlap(name)) {\n        this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        const { height: length } = labelGroup.getCanvasBBox();\n        // 如果用户没有设置 offset，则自动计算\n        titleCfg.offset = labelOffset + length + titleSpacing + titleHeight / 2;\n      }\n    }\n  }\n\n  private autoProcessOverlap(name: string, value: any, labelGroup: IGroup, limitLength: number) {\n    let hasAdjusted = false;\n    const util = OverlapUtil[name];\n    if (limitLength > 0) {\n      if (value === true) {\n        // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n        hasAdjusted = util.getDefault()(false, labelGroup, limitLength);\n      } else if (isFunction(value)) {\n        // 回调函数形式的配置： 用户可以传入回调函数\n        hasAdjusted = value(false, labelGroup, limitLength);\n      } else if (isObject(value)) {\n        // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n        const overlapCfg = value as { type: string; cfg?: AxisLabelAutoHideCfg };\n        if (util[overlapCfg.type]) {\n          hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);\n        }\n      } else if (util[value]) {\n        // 字符串类型的配置：按照名称执行 overlap 处理方法\n        hasAdjusted = util[value](false, labelGroup, limitLength);\n      }\n    }\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        const labels = labelGroup.getChildren();\n        const verticalFactor = this.get('verticalFactor');\n        each(labels, (label) => {\n          const textAlign = label.attr('textAlign');\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            const newAlign = verticalFactor > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      const children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n      each(children, (label) => {\n        if (!label.get('visible')) {\n          if (this.get('isRegister')) {\n            // 已经注册过了，则删除\n            this.unregisterElement(label);\n          }\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  }\n}\n\nexport default Circle;\n"],"names":["__extends","AxisBase","cfg","_super","getDefaultCfg","call","name","ticks","line","tickLine","subTickLine","title","label","verticalFactor","verticalLimitLength","overlapOrder","tickStates","optimize","defaultCfg","style","lineWidth","stroke","Theme","alignTick","length","displayWithLabel","count","autoRotate","autoHide","autoEllipsis","fontSize","fill","fontFamily","fontWeight","offset","offsetX","offsetY","spacing","position","textBaseline","textAlign","iconStyle","description","active","labelStyle","tickLineStyle","inactive","enable","threshold","theme","group","this","get","drawLine","drawTicks","drawTitle","items","update","item","mix","clear","render","itemGroup","getElementByLocalId","state","value","updateTickStates","rst","each","v","k","push","getItemsByState","_this","setItemState","getItems","filter","hasState","point","vector","getSideVector","x","y","align","isNumberEqual","base","labelGroup","path","getLinePath","addShape","type","id","getElementId","attrs","tickLineItems","tickLineLength","tickSegment","tick","getTickPoint","endPoint","getSidePoint","startPoint","tickValue","tickId","subTickLineItems","subCount","tickLineCount","i","pre","next","j","percent","tickItem","index","tickItems","points","defaultTickLineStyle","isFunction","x1","y1","x2","y2","tickLineGroup","getTickLineAttrs","getTickLineItems","addGroup","tickCfg","labelId","findById","drawTick","subTickLineItems_1","getSubTickLineItems","isNil","optimizeTicks","processTicks","drawLabels","drawTickLines","applyTickStates","len","size","page_1","Math","ceil","optimizedTicks","idx","set","labelCfg","rotate","formatter","text","getTextAnchor","getTextBaseline","matrix","getMatrixByAngle","getLabelAttrs","delegateObject","processOverlap","labels","getChildren","defaultLabelStyle","afterProcessTicks_1","map","newStyle","attr","titleCfg","_a","titleHeight","titlePoint","angle","getAxisVector","ext","titleAttrs","getTitleAttrs","titleShape","drawDescriptionIcon","descriptionShape","getElementById","getBBox","maxX","maxY","height","r","startX","startY","x0","y0","x3","y3","x4","y4","x5","y5","x6","y6","x7","y7","width","opacity","cursor","getItemStates","labelShape","labelStateStyle","getStatesStyle","tickLineId","tickLineShape","tickLineStateStyle","states","tickLineCfg","GroupComponent","Line","locationType","start","end","bbox","getInnerLayoutBBox","minX","min","minY","max","regionX","regionY","axisVector","normal","vec2","factor","verticalVector","isVertical","isHorizontal","labelOffset","limitLength","titleSpacing","canProcessOverlap","autoProcessOverlap","getCanvasBBox","length_1","hasAdjusted","util","OverlapUtil","getDefault","isObject","overlapCfg","verticalFactor_1","newAlign","children","slice","unregisterElement","remove","Circle","center","radius","startAngle","PI","endAngle","rx","ry","abs","getCirclePoint","large","sweep","vecLen","cos","sin"],"sourceRoot":""}