{"version":3,"file":"static/js/1904.a2bd32b3.js","mappings":"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","sources":["../node_modules/@antv/adjust/src/adjusts/adjust.ts","../node_modules/@antv/adjust/src/constant.ts","../node_modules/@antv/adjust/src/factory.ts","../node_modules/@antv/adjust/node_modules/tslib/tslib.es6.js","../node_modules/@antv/adjust/src/adjusts/dodge.ts","../node_modules/@antv/adjust/src/adjusts/jitter.ts","../node_modules/@antv/adjust/src/adjusts/stack.ts","../node_modules/@antv/adjust/src/adjusts/symmetric.ts","../node_modules/@antv/adjust/src/index.ts","../node_modules/@antv/attr/src/attributes/base.ts","../node_modules/@antv/attr/src/attributes/color.ts","../node_modules/@antv/attr/src/attributes/opacity.ts","../node_modules/@antv/attr/src/attributes/position.ts","../node_modules/@antv/attr/src/attributes/shape.ts","../node_modules/@antv/attr/src/attributes/size.ts","../node_modules/@antv/attr/src/factory.ts","../node_modules/@antv/attr/src/index.ts","../node_modules/@antv/color-util/src/index.ts","../node_modules/antd/lib/time-picker/locale/zh_CN.js"],"sourcesContent":["import * as _ from '@antv/util';\nimport { DEFAULT_Y } from '../constant';\nimport { AdjustCfg, Data, Range } from '../interface';\n\nexport type AdjustConstructor = new (cfg: any) => Adjust;\n\nexport interface DimValuesMapType {\n  [dim: string]: number[];\n}\n\nexport default abstract class Adjust {\n  /** 参与调整的维度 */\n  public adjustNames: string[];\n  /** x 维度对应的字段 */\n  public xField: string;\n  /** y 维度对应的字段 */\n  public yField: string;\n\n  // Dodge 属性\n  /** 调整占单位宽度的比例，例如：占 2 个分类间距的 1 / 2 */\n  public dodgeRatio: number;\n  /** 调整过程中 2 个数据的间距，以 dodgeRatio 为分母 */\n  public marginRatio: number;\n  /** 指定进行 dodge 的字段 */\n  public dodgeBy: string;\n  /** 自定义 offset */\n  public customOffset: ((data: any, range: any) => number) | number;\n\n  // Stack 属性\n  public height: number;\n  public size: number;\n  public reverseOrder: boolean;\n\n  /** 像素级组间距 */\n  public intervalPadding: number;\n  /** 像素级组内间距 */\n  public dodgePadding: number;\n  /** x维度长度，计算归一化padding使用 */\n  public xDimensionLegenth: number;\n  /** 分组数 */\n  public groupNum: number;\n\n  // 图形宽度相关配置\n  /** 用户配置宽度 */\n  public defaultSize: number;\n  /** 最大宽度约束 */\n  public maxColumnWidth: number;\n  /** 最小宽度约束 */\n  public minColumnWidth: number;\n  /** 宽度比例 */\n  public columnWidthRatio: number;\n\n  /** 用户自定义的dimValuesMap */\n  public dimValuesMap: DimValuesMapType;\n\n  constructor(cfg: AdjustCfg & { dimValuesMap?: DimValuesMapType }) {\n    const { xField, yField, adjustNames = ['x', 'y'], dimValuesMap } = cfg;\n\n    this.adjustNames = adjustNames;\n    this.xField = xField;\n    this.yField = yField;\n    this.dimValuesMap = dimValuesMap;\n  }\n\n  // 需要各自实现的方法\n  public abstract process(dataArray: Data[][]): Data[][];\n\n  /**\n   * 查看维度是否是 adjust 字段\n   * @param dim\n   */\n  public isAdjust(dim: string): boolean {\n    return this.adjustNames.indexOf(dim) >= 0;\n  }\n\n  protected getAdjustRange(dim: string, dimValue: number, values: number[]): Range {\n    const { yField } = this;\n\n    const index = values.indexOf(dimValue);\n    const length = values.length;\n\n    let pre;\n    let next;\n\n    // 没有 y 字段，但是需要根据 y 调整\n    if (!yField && this.isAdjust('y')) {\n      pre = 0;\n      next = 1;\n    } else if (length > 1) {\n      // 如果以其开头，则取之，否则取他前面一个\n      pre = values[index === 0 ? 0 : index - 1];\n      // 如果以其结尾，则取之，否则取他后面一个\n      next = values[index === length - 1 ? length - 1 : index + 1];\n\n      if (index !== 0) {\n        pre += (dimValue - pre) / 2;\n      } else {\n        pre -= (next - dimValue) / 2;\n      }\n\n      if (index !== length - 1) {\n        next -= (next - dimValue) / 2;\n      } else {\n        next += (dimValue - values[length - 2]) / 2;\n      }\n    } else {\n      pre = dimValue === 0 ? 0 : dimValue - 0.5;\n      next = dimValue === 0 ? 1 : dimValue + 0.5;\n    }\n\n    return {\n      pre,\n      next,\n    };\n  }\n\n  protected adjustData(groupedDataArray: Data[][], mergedData: Data[]) {\n    // 所有调整维度的值数组\n    const dimValuesMap = this.getDimValues(mergedData);\n\n    // 按照每一个分组来进行调整\n    _.each(groupedDataArray, (dataArray, index) => {\n      // 遍历所有数据集合\n      // 每个分组中，分别按照不同的 dim 进行调整\n      _.each(dimValuesMap, (values: number[], dim: string) => {\n        // 根据不同的度量分别调整位置\n        this.adjustDim(dim, values, dataArray, index);\n      });\n    });\n  }\n\n  /**\n   * 对数据进行分组adjustData\n   * @param data 数据\n   * @param dim 分组的字段\n   * @return 分组结果\n   */\n  protected groupData(data: Data[], dim: string): { [dim: string]: Data[] } {\n    // 补齐数据空数据为默认值\n    _.each(data, (record: Data) => {\n      if (record[dim] === undefined) {\n        record[dim] = DEFAULT_Y;\n      }\n    });\n\n    // 按照 dim 维度分组\n    return _.groupBy(data, dim);\n  }\n\n  /** @override */\n  protected adjustDim(dim: string, values: number[], data: Data[], index?: number): void {}\n\n  /**\n   * 获取可调整度量对应的值\n   * @param mergedData 数据\n   * @return 值的映射\n   */\n  private getDimValues(mergedData: Data[]): DimValuesMapType {\n    const { xField, yField } = this;\n\n    const dimValuesMap: DimValuesMapType = _.assign({}, this.dimValuesMap);\n\n    // 所有的维度\n    const dims = [];\n    if (xField && this.isAdjust('x')) {\n      dims.push(xField);\n    }\n    if (yField && this.isAdjust('y')) {\n      dims.push(yField);\n    }\n\n    dims.forEach((dim: string): void => {\n      if (dimValuesMap && dimValuesMap[dim]) {\n        return;\n      }\n      // 在每个维度上，所有的值\n      dimValuesMap[dim] = _.valuesOfKey(mergedData, dim).sort((v1, v2) => v1 - v2) as number[];\n    });\n\n    // 只有一维的情况下，同时调整 y，赋予默认值\n    if (!yField && this.isAdjust('y')) {\n      const dim = 'y';\n      dimValuesMap[dim] = [DEFAULT_Y, 1]; // 默认分布在 y 轴的 0 与 1 之间\n    }\n\n    return dimValuesMap;\n  }\n}\n","export const DEFAULT_Y = 0; // 默认的 y 的值\n\n// 偏移之后，间距\nexport const MARGIN_RATIO = 1 / 2;\nexport const DODGE_RATIO = 1 / 2;\n\n// 散点分开之后，距离边界的距离\nexport const GAP = 0.05;\n","import Adjust, { AdjustConstructor } from './adjusts/adjust';\n\ninterface AdjustMapType {\n  [type: string]: AdjustConstructor;\n}\n\nconst ADJUST_MAP: AdjustMapType = {};\n\n/**\n * 根据类型获取 Adjust 类\n * @param type\n */\nconst getAdjust = (type: string): AdjustConstructor => {\n  return ADJUST_MAP[type.toLowerCase()];\n};\n\n/**\n * 注册自定义 Adjust\n * @param type\n * @param ctor\n */\nconst registerAdjust = (type: string, ctor: AdjustConstructor): void => {\n  // 注册的时候，需要校验 type 重名，不区分大小写\n  if (getAdjust(type)) {\n    throw new Error(`Adjust type '${type}' existed.`);\n  }\n  // 存储到 map 中\n  ADJUST_MAP[type.toLowerCase()] = ctor;\n};\n\nexport { getAdjust, registerAdjust, Adjust };\n\nexport * from './interface';\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import * as _ from '@antv/util';\nimport { DODGE_RATIO, MARGIN_RATIO } from '../constant';\nimport { Data, DodgeCfg, Range } from '../interface';\nimport Adjust from './adjust';\n\nexport default class Dodge extends Adjust {\n  private cacheMap: { [key: string]: any } = {};\n  private adjustDataArray: Data[][] = [];\n  private mergeData: Data[] = [];\n\n  constructor(cfg: DodgeCfg) {\n    super(cfg);\n    const {\n      marginRatio = MARGIN_RATIO,\n      dodgeRatio = DODGE_RATIO,\n      dodgeBy,\n      intervalPadding,\n      dodgePadding,\n      xDimensionLength,\n      groupNum,\n      defaultSize,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n      customOffset\n    } = cfg;\n    this.marginRatio = marginRatio;\n    this.dodgeRatio = dodgeRatio;\n    this.dodgeBy = dodgeBy;\n    this.intervalPadding = intervalPadding;\n    this.dodgePadding = dodgePadding;\n    this.xDimensionLegenth = xDimensionLength;\n    this.groupNum = groupNum;\n    this.defaultSize = defaultSize;\n    this.maxColumnWidth = maxColumnWidth;\n    this.minColumnWidth = minColumnWidth;\n    this.columnWidthRatio = columnWidthRatio;\n    this.customOffset = customOffset;\n  }\n\n  public process(groupDataArray: Data[][]): Data[][] {\n    const groupedDataArray = _.clone(groupDataArray);\n    // 将数据数组展开一层\n    const mergeData = _.flatten(groupedDataArray);\n\n    const { dodgeBy } = this;\n\n    // 如果指定了分组 dim 的字段\n    const adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;\n\n    this.cacheMap = {};\n    this.adjustDataArray = adjustDataArray;\n    this.mergeData = mergeData;\n\n    this.adjustData(adjustDataArray, mergeData);\n\n    this.adjustDataArray = [];\n    this.mergeData = [];\n\n    return groupedDataArray;\n  }\n\n  protected adjustDim(dim: string, values: number[], data: Data[], frameIndex: number): any[] {\n    const { customOffset } = this;\n    const map = this.getDistribution(dim);\n    const groupData = this.groupData(data, dim); // 根据值分组\n    \n    _.each(groupData, (group, key) => {\n      let range: Range;\n\n      // xField 中只有一个值，不需要做 dodge\n      if (values.length === 1) {\n        range = {\n          pre: values[0] - 1,\n          next: values[0] + 1,\n        };\n      } else {\n        // 如果有多个，则需要获取调整的范围\n        range = this.getAdjustRange(dim, parseFloat(key), values);\n      }\n      _.each(group, (d) => {\n        const value = d[dim];\n        const valueArr = map[value];\n        const valIndex = valueArr.indexOf(frameIndex);\n        if (!_.isNil(customOffset)) {\n          const { pre, next } = range;\n          d[dim] = _.isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;\n        } else {\n          d[dim] = this.getDodgeOffset(range, valIndex, valueArr.length);\n        }\n      });\n    });\n    return [];\n  }\n\n  private getDodgeOffset(range: Range, idx: number, len: number): number {\n    const {\n      dodgeRatio,\n      marginRatio,\n      intervalPadding,\n      dodgePadding,\n    } = this;\n    const { pre, next } = range;\n\n    const tickLength = next - pre;\n    let position;\n    // 分多种输入情况\n    if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {\n      // 仅配置intervalPadding\n      const offset = this.getIntervalOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {\n      // 仅配置dodgePadding\n      const offset = this.getDodgeOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (\n      !_.isNil(intervalPadding) &&\n      !_.isNil(dodgePadding) &&\n      intervalPadding >= 0 &&\n      dodgePadding >= 0\n    ) {\n      // 同时配置intervalPadding和dodgePadding\n      const offset = this.getIntervalAndDodgeOffset(len, idx);\n      position = pre + offset;\n    } else {\n      // 默认情况\n      const width = (tickLength * dodgeRatio) / len;\n      const margin = marginRatio * width;\n      const offset =\n      (1 / 2) * (tickLength - len * width - (len - 1) * margin) +\n      ((idx + 1) * width + idx * margin) -\n      (1 / 2) * width -\n      (1 / 2) * tickLength;\n      position = (pre + next) / 2 + offset;\n    }\n    return position;\n  }\n\n  private getIntervalOnlyOffset(len: number, idx: number): number {\n    const {\n      defaultSize,\n      intervalPadding,\n      xDimensionLegenth,\n      groupNum,\n      dodgeRatio,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n    } = this;\n    const normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    let normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);\n    let geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = (!_.isNil(columnWidthRatio)) ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      const normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      const normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;\n    // 调整组内间隔\n    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);\n    const offset =\n      ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n      (1 / 2) * normalizedIntervalPadding) * groupNum -\n      normalizedIntervalPadding / 2;\n    return offset;\n  }\n\n  private getDodgeOnlyOffset(len: number, idx: number): number {\n    const {\n      defaultSize,\n      dodgePadding,\n      xDimensionLegenth,\n      groupNum,\n      marginRatio,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n    } = this;\n    const normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    let normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);\n    let geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      const normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      const normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;\n    // 调整组间距\n    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);\n    const offset =\n      ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n      (1 / 2) * normalizedIntervalPadding) * groupNum -\n      normalizedIntervalPadding / 2;\n    return offset;\n  }\n\n  private getIntervalAndDodgeOffset(len: number, idx: number): number {\n    const {\n      intervalPadding,\n      dodgePadding,\n      xDimensionLegenth,\n      groupNum,\n    } = this;\n    const normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    const normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    const geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    const offset =\n      ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n      (1 / 2) * normalizedIntervalPadding) * groupNum -\n      normalizedIntervalPadding / 2;\n    return offset;\n  }\n\n  private getDistribution(dim: string) {\n    const groupedDataArray = this.adjustDataArray;\n    const cacheMap = this.cacheMap;\n    let map = cacheMap[dim];\n\n    if (!map) {\n      map = {};\n      _.each(groupedDataArray, (data, index) => {\n        const values = _.valuesOfKey(data, dim) as number[];\n        if (!values.length) {\n          values.push(0);\n        }\n        _.each(values, (val: number) => {\n          if (!map[val]) {\n            map[val] = [];\n          }\n          map[val].push(index);\n        });\n      });\n      cacheMap[dim] = map;\n    }\n\n    return map;\n  }\n}\n","import * as _ from '@antv/util';\nimport { GAP } from '../constant';\nimport { Data, Range } from '../interface';\nimport Adjust from './adjust';\n\nfunction randomNumber(min: number, max: number): number {\n  return (max - min) * Math.random() + min;\n}\n\nexport default class Jitter extends Adjust {\n  public process(groupDataArray: Data[][]): Data[][] {\n    const groupedDataArray = _.clone(groupDataArray);\n\n    // 之前分组之后的数据，然后有合并回去（和分组前可以理解成是一样的）\n    const mergeData = _.flatten(groupedDataArray) as Data[];\n\n    // 返回值\n    this.adjustData(groupedDataArray, mergeData);\n\n    return groupedDataArray;\n  }\n\n  /**\n   * 当前数据分组（index）中，按照维度 dim 进行 jitter 调整\n   * @param dim\n   * @param values\n   * @param dataArray\n   */\n  protected adjustDim(dim: string, values: number[], dataArray: Data[]) {\n    // 在每一个分组中，将数据再按照 dim 分组，用于散列\n    const groupDataArray = this.groupData(dataArray, dim);\n    return _.each(groupDataArray, (data: Data[], dimValue: string) => {\n      return this.adjustGroup(data, dim, parseFloat(dimValue), values);\n    });\n  }\n\n  // 随机出来的字段值\n  private getAdjustOffset(range: Range): number {\n    const { pre, next } = range;\n    // 随机的范围\n    const margin = (next - pre) * GAP;\n    return randomNumber(pre + margin, next - margin);\n  }\n\n  // adjust group data\n  private adjustGroup(group: Data[], dim: string, dimValue: number, values: number[]): Data[] {\n    // 调整范围\n    const range = this.getAdjustRange(dim, dimValue, values);\n\n    _.each(group, (data: Data) => {\n      data[dim] = this.getAdjustOffset(range); // 获取调整的位置\n    });\n    return group;\n  }\n}\n","import * as _ from '@antv/util';\nimport { Data, StackCfg } from '../interface';\nimport Adjust from './adjust';\n\nconst Cache = _.Cache;\n\nexport default class Stack extends Adjust {\n  constructor(cfg: StackCfg) {\n    super(cfg);\n\n    const { adjustNames = ['y'], height = NaN, size = 10, reverseOrder = false } = cfg;\n    this.adjustNames = adjustNames;\n    this.height = height;\n    this.size = size;\n    this.reverseOrder = reverseOrder;\n  }\n\n  /**\n   * 方法入参是经过数据分组、数据数字化之后的二维数组\n   * @param groupDataArray 分组之后的数据\n   */\n  public process(groupDataArray: Data[][]): Data[][] {\n    const { yField, reverseOrder } = this;\n\n    // 如果有指定 y 字段，那么按照 y 字段来 stack\n    // 否则，按照高度均分\n    const d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);\n\n    return reverseOrder ? this.reverse(d) : d;\n  }\n\n  private reverse(groupedDataArray: Data[][]): Data[][] {\n    return groupedDataArray.slice(0).reverse();\n  }\n\n  private processStack(groupDataArray: Data[][]): Data[][] {\n    const { xField, yField, reverseOrder } = this;\n\n    // 层叠顺序翻转\n    const groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;\n\n    // 用来缓存，正数和负数的堆叠问题\n    const positive = new Cache<number>();\n    const negative = new Cache<number>();\n\n    return groupedDataArray.map((dataArray) => {\n      return dataArray.map((data) => {\n        const x: number = _.get(data, xField, 0);\n        let y: number = _.get(data, [yField]);\n\n        const xKey = x.toString();\n\n        // todo 是否应该取 _origin？因为 y 可能取到的值不正确，比如先 symmetric，再 stack！\n        y = _.isArray(y) ? y[1] : y;\n\n        if (!_.isNil(y)) {\n          const cache = y >= 0 ? positive : negative;\n\n          if (!cache.has(xKey)) {\n            cache.set(xKey, 0);\n          }\n          const xValue = cache.get(xKey) as number;\n          const newXValue = y + xValue;\n\n          // 存起来\n          cache.set(xKey, newXValue);\n\n          return {\n            ...data,\n            // 叠加成数组，覆盖之前的数据\n            [yField]: [xValue, newXValue],\n          };\n        }\n\n        // 没有修改，则直接返回\n        return data;\n      });\n    });\n  }\n\n  private processOneDimStack(groupDataArray: Data[][]): Data[][] {\n    const { xField, height, reverseOrder } = this;\n    const yField = 'y';\n\n    // 如果层叠的顺序翻转\n    const groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;\n\n    // 缓存累加数据\n    const cache = new Cache<number>();\n\n    return groupedDataArray.map((dataArray): Data[] => {\n      return dataArray.map(\n        (data): Data => {\n          const { size } = this;\n          const xValue: string = data[xField];\n\n          // todo 没有看到这个 stack 计算原理\n          const stackHeight = (size * 2) / height;\n\n          if (!cache.has(xValue)) {\n            cache.set(xValue, stackHeight / 2); // 初始值大小\n          }\n\n          const stackValue = cache.get(xValue) as number;\n          // 增加一层 stackHeight\n          cache.set(xValue, stackValue + stackHeight);\n\n          return {\n            ...data,\n            [yField]: stackValue,\n          };\n        }\n      );\n    });\n  }\n}\n","import * as _ from '@antv/util';\nimport { Data } from '../interface';\nimport Adjust from './adjust';\n\nexport default class Symmetric extends Adjust {\n  public process(groupDataArray: Data[][]): Data[][] {\n    const mergeData = _.flatten(groupDataArray);\n\n    const { xField, yField } = this;\n\n    // 每个 x 值对应的 最大值\n    const cache = this.getXValuesMaxMap(mergeData);\n\n    // 所有数据的最大的值\n    const max = Math.max(...Object.keys(cache).map((key) => cache[key]));\n\n    return _.map(groupDataArray, (dataArray) => {\n      return _.map(dataArray, (data) => {\n        const yValue = data[yField];\n        const xValue = data[xField];\n\n        // 数组处理逻辑\n        if (_.isArray(yValue)) {\n          const off = (max - cache[xValue]) / 2;\n\n          return {\n            ...data,\n            [yField]: _.map(yValue, (y: number) => off + y),\n          };\n        }\n\n        // 非数组处理逻辑\n        const offset = (max - yValue) / 2;\n        return {\n          ...data,\n          [yField]: [offset, yValue + offset],\n        };\n      });\n    });\n  }\n\n  // 获取每个 x 对应的最大的值\n  private getXValuesMaxMap(mergeData: Data[]): { [key: string]: number } {\n    const { xField, yField } = this;\n\n    // 根据 xField 的值进行分组\n    const groupDataArray = _.groupBy(mergeData, (data) => data[xField] as string);\n\n    // 获取每个 xField 值中的最大值\n    return _.mapValues(groupDataArray, (dataArray) => this.getDimMaxValue(dataArray, yField));\n  }\n\n  private getDimMaxValue(mergeData: Data[], dim: string): number {\n    // 所有的 value 值\n    const dimValues = _.map(mergeData, (data) => _.get(data, dim, []));\n    // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n    const flattenValues = _.flatten(dimValues);\n\n    // 求出数组的最大值\n    return Math.max(...flattenValues);\n  }\n}\n","import { getAdjust, registerAdjust } from './factory';\n\nimport Adjust from './adjusts/adjust';\n\nimport Dodge from './adjusts/dodge';\nimport Jitter from './adjusts/jitter';\nimport Stack from './adjusts/stack';\nimport Symmetric from './adjusts/symmetric';\n\n// 注册内置的 adjust\nregisterAdjust('Dodge', Dodge);\nregisterAdjust('Jitter', Jitter);\nregisterAdjust('Stack', Stack);\nregisterAdjust('Symmetric', Symmetric);\n\n// 最终暴露给外部的方法\nexport { getAdjust, registerAdjust, Adjust };\n\nexport * from './interface';\n","import { each, identity, isArray, isNil, isString, mix } from '@antv/util';\nimport { AttributeCfg, CallbackType, Scale } from '../interface';\n\n// todo 这个到底目的是什么？\nconst toScaleString = (scale: Scale, value: any): any => {\n  if (isString(value)) {\n    return value;\n  }\n  return scale.invert(scale.scale(value));\n};\n\nexport type AttributeConstructor = new (cfg: any) => Attribute;\n\n/**\n * 所有视觉通道属性的基类\n * @class Base\n */\nexport default class Attribute {\n  public type: string;\n  public names: string[] = [];\n  public scales: Scale[] = [];\n  public linear: boolean = false;\n\n  public values: any[] = [];\n\n  constructor(cfg: AttributeCfg) {\n    // 解析配置\n    this._parseCfg(cfg);\n  }\n  public callback: CallbackType = () => [];\n\n  /**\n   * 映射的值组成的数组\n   * @param params 对应 scale 顺序的值传入\n   */\n  public mapping(...params: any[]): any[] {\n    const values = params.map((param, idx) => {\n      return this._toOriginParam(param, this.scales[idx]);\n    });\n\n    return this.callback.apply(this, values);\n  }\n\n  /**\n   * 如果进行线性映射，返回对应的映射值\n   * @param percent\n   */\n  public getLinearValue(percent: number): number | string {\n    // 分段数量\n    const steps = this.values.length - 1;\n\n    const step = Math.floor(steps * percent);\n    const leftPercent = steps * percent - step;\n\n    // todo 不懂这个逻辑\n    const start = this.values[step];\n    const end = step === steps ? start : this.values[step + 1];\n\n    // 线性方程\n    return start + (end - start) * leftPercent;\n  }\n\n  /**\n   * 根据度量获取属性名\n   */\n  public getNames() {\n    const scales = this.scales;\n    const names = this.names;\n\n    const length = Math.min(scales.length, names.length);\n    const rst = [];\n    for (let i = 0; i < length; i += 1) {\n      rst.push(names[i]);\n    }\n    return rst;\n  }\n\n  /**\n   * 获取所有的维度名\n   */\n  public getFields() {\n    return this.scales.map((scale) => scale.field);\n  }\n\n  /**\n   * 根据名称获取度量\n   * @param name\n   */\n  public getScale(name: string) {\n    return this.scales[this.names.indexOf(name)];\n  }\n\n  /**\n   * 默认的回调函数（用户没有自定义 callback，或者用户自定义 callback 返回空的时候，使用 values 映射）\n   * @param params\n   */\n  private defaultCallback(...params: any[]): any[] {\n    // 没有 params 的情况，是指没有指定 fields，直接返回配置的 values 常量\n    if (params.length === 0) {\n      return this.values;\n    }\n\n    return params.map((param, idx) => {\n      const scale = this.scales[idx];\n\n      return scale.type === 'identity' ? scale.values[0] : this._getAttributeValue(scale, param);\n    });\n  }\n\n  // 解析配置\n  private _parseCfg(cfg: AttributeCfg) {\n    const { type = 'base', names = [], scales = [], values = [], callback } = cfg;\n\n    this.type = type;\n\n    this.scales = scales;\n    this.values = values;\n    this.names = names;\n\n    // 构造 callback 方法\n    this.callback = (...params: any[]): any[] => {\n      /**\n       * 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值\n       */\n      if (callback) {\n        // 使用用户返回的值处理\n        const ret = callback(...params);\n        if (!isNil(ret)) {\n          return [ret];\n        }\n      }\n\n      // 没有 callback 或者用户 callback 返回值为空，则使用默认的逻辑处理\n      return this.defaultCallback.apply(this, params);\n    };\n  }\n\n  // 获取属性值，将值映射到视觉通道\n  private _getAttributeValue(scale: Scale, value: any) {\n    // 如果是非线性的字段，直接从 values 中取值即可\n    if (scale.isCategory && !this.linear) {\n      // 离散 scale 变换成索引\n      const idx = scale.translate(value) as number;\n      return this.values[idx % this.values.length];\n    }\n\n    // 线性则使用线性值\n    const percent = scale.scale(value);\n    return this.getLinearValue(percent);\n  }\n\n  /**\n   * 通过 scale 拿到数据对应的原始的参数\n   * @param param\n   * @param scale\n   * @private\n   */\n  private _toOriginParam(param: any, scale: Scale) {\n    // 是线性，直接返回\n    // 非线性，使用 scale 变换\n    return !scale.isLinear\n      ? isArray(param)\n        ? param.map((p: any) => toScaleString(scale, p))\n        : toScaleString(scale, param)\n      : param;\n  }\n}\n","import colorUtil from '@antv/color-util';\nimport { isString } from '@antv/util';\nimport { AttributeCfg } from '../interface';\nimport Attribute from './base';\n\nexport default class Color extends Attribute {\n  public gradient: (percent: number) => string;\n\n  constructor(cfg: AttributeCfg) {\n    super(cfg);\n    this.type = 'color';\n    this.names = ['color'];\n\n    if (isString(this.values)) {\n      this.linear = true;\n    }\n\n    this.gradient = colorUtil.gradient(this.values);\n  }\n\n  /**\n   * @override\n   */\n  public getLinearValue(percent: number): string {\n    return this.gradient(percent);\n  }\n}\n","import { AttributeCfg } from '../interface';\nimport Attribute from './base';\n\nexport default class Opacity extends Attribute {\n  constructor(cfg: AttributeCfg) {\n    super(cfg);\n    this.type = 'opacity';\n    this.names = ['opacity'];\n  }\n}\n","import { isArray, isNil } from '@antv/util';\nimport { AttributeCfg } from '../interface';\nimport Attribute from './base';\n\nexport type Value = number | string;\nexport type MappingValue = Value[] | Value;\n\nexport default class Position extends Attribute {\n  constructor(cfg: AttributeCfg) {\n    super(cfg);\n    this.names = ['x', 'y'];\n    this.type = 'position';\n  }\n\n  public mapping(x: MappingValue, y: MappingValue) {\n    const [scaleX, scaleY] = this.scales;\n\n    if (isNil(x) || isNil(y)) {\n      return [];\n    }\n\n    return [\n      isArray(x) ? x.map((xi) => scaleX.scale(xi)) : scaleX.scale(x),\n      isArray(y) ? y.map((yi) => scaleY.scale(yi)) : scaleY.scale(y),\n    ];\n  }\n}\n","import { AttributeCfg } from '../interface';\nimport Attribute from './base';\n\nexport default class Shape extends Attribute {\n  constructor(cfg: AttributeCfg) {\n    super(cfg);\n    this.type = 'shape';\n    this.names = ['shape'];\n  }\n\n  /**\n   * @override\n   */\n  public getLinearValue(percent: number): string {\n    const idx = Math.round((this.values.length - 1) * percent);\n    return this.values[idx];\n  }\n}\n","import { AttributeCfg } from '../interface';\nimport Attribute from './base';\n\nexport default class Size extends Attribute {\n  constructor(cfg: AttributeCfg) {\n    super(cfg);\n    this.type = 'size';\n    this.names = ['size'];\n  }\n}\n","import Attribute, { AttributeConstructor } from './attributes/base';\n\ninterface AttributeMapType {\n  [key: string]: any;\n}\n\n// 所有的 attribute map\nconst ATTRIBUTE_MAP: AttributeMapType = {};\n\n/**\n * 通过类型获得 Attribute 类\n * @param type\n */\nconst getAttribute = (type: string) => {\n  return ATTRIBUTE_MAP[type.toLowerCase()];\n};\n\nconst registerAttribute = (type: string, ctor: AttributeConstructor) => {\n  // 注册的时候，需要校验 type 重名，不区分大小写\n  if (getAttribute(type)) {\n    throw new Error(`Attribute type '${type}' existed.`);\n  }\n  // 存储到 map 中\n  ATTRIBUTE_MAP[type.toLowerCase()] = ctor;\n};\n\nexport { getAttribute, registerAttribute, Attribute };\nexport * from './interface';\n","import Attribute from './attributes/base';\n\nimport Color from './attributes/color';\nimport Opacity from './attributes/opacity';\nimport Position from './attributes/position';\nimport Shape from './attributes/shape';\nimport Size from './attributes/size';\n\nimport { getAttribute, registerAttribute } from './factory';\n\nregisterAttribute('Color', Color);\nregisterAttribute('Opacity', Opacity);\nregisterAttribute('Position', Position);\nregisterAttribute('Shape', Shape);\nregisterAttribute('Size', Size);\n\nexport {\n  registerAttribute,\n  getAttribute,\n  Attribute,\n  // 以下 export 是为了兼容，理论上是不需要的\n  Color,\n  Opacity,\n  Position,\n  Shape,\n  Size,\n};\n\nexport * from './interface';\n","import { map, memoize, isString, each } from '@antv/util';\n\nconst RGB_REG = /rgba?\\(([\\s.,0-9]+)\\)/;\nconst regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nconst regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nconst regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\n\nconst isGradientColor = (val) => /^[r,R,L,l]{1}[\\s]*\\(/.test(val);\n\n// 创建辅助 tag 取颜色\nconst createTmp = (): HTMLElement => {\n  const i = document.createElement('i');\n  i.title = 'Web Colour Picker';\n  i.style.display = 'none';\n  document.body.appendChild(i);\n  return i;\n};\n\n// 获取颜色之间的插值\nconst getValue = (start: number[], end: number[], percent: number, index: number): number => {\n  return start[index] + (end[index] - start[index]) * percent;\n};\n\n// 数组转换成颜色\nfunction arr2rgb(arr: number[]): string {\n  return `#${toHex(arr[0])}${toHex(arr[1])}${toHex(arr[2])}`;\n}\n\n// rgb 颜色转换成数组\nconst rgb2arr = (str: string): number[] => {\n  return [\n    parseInt(str.substr(1, 2), 16),\n    parseInt(str.substr(3, 2), 16),\n    parseInt(str.substr(5, 2), 16),\n  ];\n};\n\n// 将数值从 0-255 转换成16进制字符串\nconst toHex = (value: number): string => {\n  const x16Value = Math.round(value).toString(16);\n\n  return x16Value.length === 1 ? `0${x16Value}` : x16Value;\n};\n\n// 计算颜色\nconst calColor = (points: number[][], percent: number) => {\n  const fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 :\n    percent > 1 ? 1 :\n      Number(percent);\n\n  const steps = points.length - 1;\n\n  const step = Math.floor(steps * fixedPercent);\n\n  const left = steps * fixedPercent - step;\n\n  const start = points[step];\n\n  const end = step === steps ? start : points[step + 1];\n\n  return arr2rgb([\n    getValue(start, end, left, 0),\n    getValue(start, end, left, 1),\n    getValue(start, end, left, 2),\n  ]);\n};\n\n// 用于给 toRGB 的缓存（使用 memoize 方法替换）\n// const colorCache = {};\nlet iEl: HTMLElement;\n\n/**\n * 将颜色转换到 rgb 的格式\n * @param {color} color 颜色\n * @return 将颜色转换到 '#ffffff' 的格式\n */\nconst toRGB = (color: string): string => {\n  // 如果已经是 rgb的格式\n  if (color[0] === '#' && color.length === 7) {\n    return color;\n  }\n\n  if (!iEl) {\n    // 防止防止在页头报错\n    iEl = createTmp();\n  }\n\n  iEl.style.color = color;\n\n  let rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');\n\n  const matches = RGB_REG.exec(rst) as string[] ;\n  const cArray: number[] = matches[1].split(/\\s*,\\s*/).map((s) => Number(s));\n\n  rst = arr2rgb(cArray);\n\n  return rst;\n};\n\n/**\n * 获取渐变函数\n * @param colors 多个颜色\n * @return 颜色值\n */\nconst gradient = (colors: string | string[]) => {\n  const colorArray = isString(colors) ? (colors as string).split('-') : colors;\n\n  const points = map(colorArray, (color) => {\n    return rgb2arr(color.indexOf('#') === -1 ? toRGB(color) : color);\n  });\n\n  // 返回一个函数\n  return (percent: number): string => {\n    return calColor(points, percent);\n  };\n};\n\nconst toCSSGradient = (gradientColor) => {\n  if (isGradientColor(gradientColor)) {\n    let cssColor;\n    let steps;\n    if (gradientColor[0] === 'l') {\n      // 线性渐变\n      const arr = regexLG.exec(gradientColor);\n      const angle = +arr[1] + 90; // css 和 g 的渐变起始角度不同\n      steps = arr[2];\n\n      cssColor = `linear-gradient(${angle}deg, `;\n    } else if (gradientColor[0] === 'r') {\n      // 径向渐变\n      cssColor = 'radial-gradient(';\n      const arr = regexRG.exec(gradientColor);\n      steps = arr[4];\n    }\n\n    const colorStops: string[] = steps.match(regexColorStop);\n    each(colorStops, (item, index) => {\n      const itemArr = item.split(':');\n      cssColor += `${itemArr[1]} ${itemArr[0] * 100}%`;\n      if (index !== (colorStops.length - 1)) {\n        cssColor += ', ';\n      }\n    });\n\n    cssColor += ')';\n\n    return cssColor;\n  }\n\n  return gradientColor;\n};\n\nexport default {\n  rgb2arr,\n  gradient,\n  toRGB: memoize(toRGB),\n  toCSSGradient,\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar locale = {\n  placeholder: '请选择时间',\n  rangePlaceholder: ['开始时间', '结束时间']\n};\nvar _default = locale;\nexports[\"default\"] = _default;"],"names":["cfg","xField","yField","_a","adjustNames","dimValuesMap","this","Adjust","dim","indexOf","dimValue","values","pre","next","index","length","isAdjust","groupedDataArray","mergedData","getDimValues","_","dataArray","_this","adjustDim","data","record","undefined","dims","push","forEach","sort","v1","v2","ADJUST_MAP","getAdjust","type","toLowerCase","registerAdjust","ctor","Error","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","call","apply","_super","marginRatio","_b","dodgeRatio","dodgeBy","intervalPadding","dodgePadding","xDimensionLength","groupNum","defaultSize","maxColumnWidth","minColumnWidth","columnWidthRatio","customOffset","xDimensionLegenth","Dodge","groupDataArray","mergeData","adjustDataArray","cacheMap","adjustData","frameIndex","map","getDistribution","groupData","group","key","range","getAdjustRange","parseFloat","value","valueArr","valIndex","getDodgeOffset","idx","len","position","tickLength","getIntervalOnlyOffset","getDodgeOnlyOffset","getIntervalAndDodgeOffset","width","margin","normalizedIntervalPadding","normalizedDodgePadding","geomWidth","normalizedMaxWidht","Math","min","normalizedMinWidht","max","val","Jitter","adjustGroup","random","getAdjustOffset","Cache","height","NaN","_c","size","_d","reverseOrder","Stack","processStack","processOneDimStack","reverse","slice","positive","negative","x","y","xKey","toString","cache","has","set","xValue","get","newXValue","stackHeight","stackValue","Symmetric","getXValuesMaxMap","keys","yValue","off_1","offset","getDimMaxValue","dimValues","flattenValues","toScaleString","scale","isString","invert","names","scales","linear","callback","_parseCfg","Attribute","params","param","_toOriginParam","percent","steps","step","floor","leftPercent","start","rst","field","name","_getAttributeValue","ret","isNil","defaultCallback","isCategory","translate","getLinearValue","isLinear","isArray","gradient","colorUtil","Color","Position","scaleX","scaleY","xi","yi","Shape","round","ATTRIBUTE_MAP","getAttribute","registerAttribute","Opacity","Size","RGB_REG","regexLG","regexRG","regexColorStop","getValue","end","arr2rgb","arr","toHex","iEl","rgb2arr","str","parseInt","substr","x16Value","toRGB","color","document","createElement","title","style","display","body","appendChild","createTmp","defaultView","getComputedStyle","getPropertyValue","exec","split","Number","colors","colorArray","points","fixedPercent","isNaN","left","calColor","memoize","toCSSGradient","gradientColor","test","cssColor_1","angle","colorStops_1","match","each","item","itemArr","defineProperty","exports","_default","placeholder","rangePlaceholder"],"sourceRoot":""}