{"version":3,"file":"static/js/2802.461f36c4.js","mappings":"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","sources":["../node_modules/@antv/g2/src/geometry/label/index.ts","../node_modules/@antv/g2/src/geometry/label/interval.ts","../node_modules/@antv/g2/src/geometry/label/layout/adjust-color.ts","../node_modules/@antv/g2/src/geometry/label/layout/hide-overlap.ts","../node_modules/@antv/g2/src/geometry/label/layout/interval/adjust-position.ts","../node_modules/@antv/g2/src/geometry/label/layout/interval/hide-overlap.ts","../node_modules/@antv/g2/src/geometry/label/layout/limit-in-canvas.ts","../node_modules/@antv/g2/src/geometry/label/layout/limit-in-plot.ts","../node_modules/@antv/g2/src/geometry/label/layout/limit-in-shape.ts","../node_modules/@antv/g2/src/geometry/label/layout/overlap.ts","../node_modules/@antv/g2/src/geometry/label/layout/path/adjust-position.ts","../node_modules/@antv/g2/src/geometry/label/layout/pie/distribute.ts","../node_modules/@antv/g2/src/geometry/label/layout/pie/outer.ts","../node_modules/@antv/g2/src/geometry/label/layout/pie/spider.ts"],"sourcesContent":["import { BBox, IGroup, IShape } from '../../dependents';\nimport { LooseObject } from '../../interface';\nimport { GeometryLabelConstructor } from './base';\nimport { LabelItem } from './interface';\n\n/**\n * label 布局函数定义\n * @param items 存储每个 label 的详细信息\n * @param labels 所有的 labels 图形实例\n * @param shapes 所有 label 对应的图形元素实例\n * @param region 画布区域\n * @param cfg 用于存储各个布局函数开放给用户的配置数据\n */\ntype GeometryLabelsLayoutFn = (\n  items: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox,\n  cfg?: LooseObject\n) => void;\n\nconst GEOMETRY_LABELS_MAP: Record<string, GeometryLabelConstructor> = {};\nconst GEOMETRY_LABELS_LAYOUT_MAP: Record<string, GeometryLabelsLayoutFn> = {};\n\n/**\n * 获取 `type` 对应的 [[GeometryLabel]] 类\n * @param type\n * @returns\n */\nexport function getGeometryLabel(type: string): GeometryLabelConstructor {\n  return GEOMETRY_LABELS_MAP[type.toLowerCase()];\n}\n\n/**\n * 注册定义的 GeometryLabel 类\n * @param type GeometryLabel 类型名称\n * @param ctor GeometryLabel 类\n */\nexport function registerGeometryLabel(type: string, ctor: GeometryLabelConstructor) {\n  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;\n}\n\n/**\n * 获取 `type` 对应的 [[GeometryLabelsLayoutFn]] label 布局函数\n * @param type 布局函数名称\n * @returns\n */\nexport function getGeometryLabelLayout(type: string): GeometryLabelsLayoutFn {\n  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];\n}\n\n/**\n * 注册定义的 label 布局函数\n * @param type label 布局函数名称\n * @param layoutFn label 布局函数\n */\nexport function registerGeometryLabelLayout(type: string, layoutFn: GeometryLabelsLayoutFn) {\n  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;\n}\n","import { get, deepMix, isArray } from '@antv/util';\nimport { Writeable } from '../../util/types';\nimport { MappingDatum, Point } from '../../interface';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\n/**\n * 柱状图 label\n */\nexport default class IntervalLabel extends GeometryLabel {\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  private getLabelValueDir(mappingData: MappingDatum) {\n    // points 中的 x/y 和 transpose 无关\n    const dim = 'y';\n    const { points } = mappingData;\n\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  }\n\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number, position?: string) {\n    let point = super.getLabelOffsetPoint(labelCfg, index, total);\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = { ...point, [dim]: point[dim] * dir };\n\n    if (coordinate.isReflect('x')) {\n      point = {\n        ...point,\n        x: point.x * -1,\n      };\n    }\n    if (coordinate.isReflect('y')) {\n      point = {\n        ...point,\n        y: point.y * -1,\n      };\n    }\n\n    return point;\n  }\n\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { theme } = geometry;\n\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);\n  }\n\n  protected setLabelPosition(\n    labelPointCfg: Writeable<LabelPointCfg>,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const shapePoints = mappingData.points as Point[];\n    const point0 = coordinate.convert(shapePoints[0]);\n    const point2 = coordinate.convert(shapePoints[2]);\n    const dir = this.getLabelValueDir(mappingData);\n\n    let top;\n    let right;\n    let bottom;\n    let left;\n\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const p0 = coordinate.convert(points[0] as Point);\n        const p1 = coordinate.convert(points[1] as Point);\n        const nextP0 = coordinate.convert(nextPoints[0] as Point);\n        const nextP1 = coordinate.convert(nextPoints[1] as Point);\n\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  }\n}\n","import { IGroup, IShape } from '../../../dependents';\nimport { BBox } from '../../../util/bbox';\nimport { isContrastColorWhite } from '../../../util/color';\nimport Element from '../../element';\nimport { LabelItem } from '../interface';\n\nexport function adjustColor(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[]) {\n  if (shapes.length === 0) {\n    return;\n  }\n  const element: Element = shapes[0].get('element');\n  const theme = element.geometry.theme;\n  const { fillColorLight, fillColorDark } = theme.labels || {};\n\n  shapes.forEach((shape: IShape | IGroup, index: number) => {\n    const label = labels[index];\n    const textShape = label.find((el) => el.get('type') === 'text');\n    const shapeBBox = BBox.fromObject(shape.getBBox());\n    const textBBox = BBox.fromObject(textShape.getCanvasBBox());\n    const overflow = !shapeBBox.contains(textBBox);\n\n    const bgColor = shape.attr('fill');\n    const fillWhite = isContrastColorWhite(bgColor);\n\n    if (!overflow) {\n      if (fillWhite) {\n        if (fillColorLight) {\n          textShape.attr('fill', fillColorLight);\n        }\n      } else {\n        if (fillColorDark) {\n          textShape.attr('fill', fillColorDark);\n        }\n      }\n    } else {\n      // 出现溢出直接应用 overflowLabel 样式\n      textShape.attr(theme.overflowLabels.style);\n    }\n  });\n}\n","import { get, each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { intersect } from '../../../util/collision-detect';\nimport { LabelItem } from '../interface';\nimport { getLabelBackgroundInfo } from '../util';\nimport { createWorker } from '../util/createWorker';\nimport { code as layoutCode } from './worker/hide-overlap';\n\ntype Item = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  visible?: boolean;\n};\n\nconst layout = (items: Item[]): Item[] => {\n  const boxes = items.slice();\n  for (let i = 0; i < boxes.length; i++) {\n    const box1 = boxes[i];\n    if (box1.visible) {\n      for (let j = i + 1; j < boxes.length; j++) {\n        const box2 = boxes[j];\n        if (box1 !== box2 && box2.visible) {\n          if (intersect(box1, box2)) {\n            box2.visible = false;\n          }\n        }\n      }\n    }\n  }\n  return boxes;\n};\n\nconst cache: Map<string, any> = new Map();\nconst worker = createWorker(layoutCode);\n\n/**\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行隐藏（非移除）\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport async function hideOverlap(\n  labelItems: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox\n) {\n  const boxes = labels.map((d, idx) => ({\n    ...getLabelBackgroundInfo(d, labelItems[idx], get(labelItems[idx], 'background.padding')),\n    visible: true,\n  }));\n  const memoKey = JSON.stringify(boxes);\n  const cb = (items: Item[]) => {\n    cache.set(memoKey, items);\n    each(items, ({ visible }, idx) => {\n      const labelShape = labels[idx];\n      if (visible) {\n        labelShape?.show();\n      } else {\n        labelShape?.hide();\n      }\n    });\n    return items;\n  };\n  if (cache.get(memoKey)) {\n    cb(cache.get(memoKey));\n  } else if (worker) {\n    // Do layout in worker.\n    try {\n      const params = JSON.stringify({ type: 'hide-overlap', items: boxes });\n      const res = await worker.post(params, () => cb(layout(boxes)));\n      cb(Array.isArray(res.data) ? res.data : []);\n    } catch (e) {\n      console.error(e);\n      cb(layout(boxes));\n    }\n  } else {\n    // Normal layout in main thread.\n    cb(layout(boxes));\n  }\n}\n","import { IElement, IGroup, IShape } from '../../../../dependents';\nimport { BBox } from '../../../../util/bbox';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { findLabelTextShape } from '../../util';\n\nfunction shouldInShapeSingle(geometry: Geometry, label: IGroup, shape: IElement): boolean {\n  const coordinate = geometry.coordinate;\n  const textShape = findLabelTextShape(label);\n  const textBBox = BBox.fromObject(textShape.getCanvasBBox());\n  const shapeBBox = BBox.fromObject(shape.getBBox());\n\n  return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;\n}\n\nfunction shouldInShape(geometry: Geometry, labels: IGroup[], shapes: IShape[] | IGroup[]): boolean {\n  const isStack = !!geometry.getAdjust('stack');\n\n  return (\n    isStack ||\n    labels.every((label: IGroup, index: number) => {\n      const shape = shapes[index];\n      return shouldInShapeSingle(geometry, label, shape);\n    })\n  );\n}\n\nfunction moveInShape(geometry: Geometry, label: IGroup, shape: IElement): void {\n  const coordinate = geometry.coordinate;\n  const shapeBBox = BBox.fromObject(shape.getBBox());\n  const textShape = findLabelTextShape(label);\n\n  if (coordinate.isTransposed) {\n    // 水平方向：条形图系列\n    textShape.attr({\n      x: shapeBBox.minX + shapeBBox.width / 2,\n      textAlign: 'center',\n    });\n  } else {\n    // 垂直方向：柱形图系列\n    textShape.attr({\n      y: shapeBBox.minY + shapeBBox.height / 2,\n      textBaseline: 'middle',\n    });\n  }\n}\n\n/**\n * 适用于 interval geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n */\nexport function intervalAdjustPosition(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[]) {\n  if (shapes.length === 0) {\n    return;\n  }\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  const inShape = shouldInShape(geometry, labels, shapes);\n  if (inShape) {\n    shapes.forEach((shape: IShape | IGroup, index: number) => {\n      const label = labels[index];\n      moveInShape(geometry, label, shape);\n    });\n  }\n}\n","import { IGroup, IShape } from '../../../../dependents';\nimport { each, groupBy, uniq, map, size, filter } from '@antv/util';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { checkShapeOverlap } from '../../util';\n\nfunction filterLabel(labels: IShape[] | IGroup[]) {\n  const MAX_CNT = 500; // 最多显示 500 个数据标签\n  const filteredLabels = [];\n  const pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);\n  each(labels, (label, idx) => {\n    if (idx % pages === 0) {\n      filteredLabels.push(label);\n    } else {\n      label.set('visible', false);\n    }\n  });\n\n  return filteredLabels;\n}\n\n/**\n * 为 interval geometry 定制的数据标签重叠自动隐藏布局方法\n * @param items\n * @param labels\n * @param shapes\n */\nexport function intervalHideOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[]) {\n  if (shapes.length === 0) {\n    return;\n  }\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || geometry.type !== 'interval') {\n    return;\n  }\n\n  const filteredLabels = filterLabel(labels);\n  const [xField] = geometry.getXYFields();\n  const dones: IShape[] = [];\n  const todo: IShape[] = [];\n  const groupedLabels = groupBy(filteredLabels, (label) => label.get('data')[xField]);\n  const xValues = uniq(map(filteredLabels, (label: IShape) => label.get('data')[xField]));\n  let xValue;\n\n  filteredLabels.forEach((label) => {\n    label.set('visible', true);\n  });\n\n  const addCurrentGroup = (curItems: IShape[]) => {\n    if (curItems) {\n      if (curItems.length) {\n        // 最后一个\n        todo.push(curItems.pop());\n      }\n      todo.push(...curItems);\n    }\n  };\n\n  if (size(xValues) > 0) {\n    // 第一组\n    xValue = xValues.shift();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n  if (size(xValues) > 0) {\n    // 最后一组\n    xValue = xValues.pop();\n    addCurrentGroup(groupedLabels[xValue]);\n  }\n  each(xValues.reverse(), (val) => {\n    // 其他组\n    addCurrentGroup(groupedLabels[val]);\n  });\n\n  while (todo.length > 0) {\n    const cur = todo.shift();\n    if (cur.get('visible')) {\n      if (checkShapeOverlap(cur, dones)) {\n        cur.set('visible', false);\n      } else {\n        dones.push(cur);\n      }\n    }\n  }\n}\n","import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { translate } from '../../../util/transform';\nimport { LabelItem } from '../interface';\n\n/**\n * @ignore\n * 将 label 限制在画布范围内，简单得将超出画布的 label 往画布内调整\n * @param labels\n * @param cfg\n */\nexport function limitInCanvas(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  each(labels, (label: IGroup) => {\n    const { minX: regionMinX, minY: regionMinY, maxX: regionMaxX, maxY: regionMaxY } = region;\n    const { minX, minY, maxX, maxY, x, y, width, height } = label.getCanvasBBox();\n\n    let finalX = x;\n    let finalY = y;\n    if (minX < regionMinX || maxX < regionMinX) {\n      // 超出左侧\n      finalX = regionMinX;\n    }\n    if (minY < regionMinY || maxY < regionMinY) {\n      // 超出顶部\n      finalY = regionMinY;\n    }\n\n    if (minX > regionMaxX) {\n      // 整体超出右侧\n      finalX = regionMaxX - width;\n    } else if (maxX > regionMaxX) {\n      // 超出右侧\n      finalX = finalX - (maxX - regionMaxX);\n    }\n\n    if (minY > regionMaxY) {\n      // 整体超出顶部\n      finalY = regionMaxY - height;\n    } else if (maxY > regionMaxY) {\n      // 超出底部\n      finalY = finalY - (maxY - regionMaxY);\n    }\n\n    if (finalX !== x || finalY !== y) {\n      translate(label, finalX - x, finalY - y);\n    }\n  });\n}\n","import { each, pick } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { getCoordinateBBox } from '../../../util/coordinate';\nimport { getEllipsisText } from '../../../util/text';\nimport { translate } from '../../../util/transform';\nimport { LabelItem } from '../interface';\n\n/** limitInPlot layout 的可选配置 */\nexport interface LimitInPlotLayoutCfg {\n  /** 需要限制哪些方向上不能超过 Plot 范围，默认四个方向上都限制 */\n  direction?: ('top' | 'right' | 'bottom' | 'left')[];\n  /** 可以允许的 margin */\n  margin?: number;\n  /** 超过限制后的动作，默认 translate 移动位置; ellipsis 对 text 进行省略展示 */\n  action?: 'hide' | 'translate' | 'ellipsis';\n}\n\n/**\n * @ignore\n * 将 label 限制在 Plot 范围内，将超出 Plot 范围的 label 可选择进行隐藏或者移动位置\n * @param labels\n * @param cfg\n */\nexport function limitInPlot(\n  items: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox,\n  cfg?: LimitInPlotLayoutCfg\n) {\n  if (labels.length <= 0) {\n    return;\n  }\n  const direction = cfg?.direction || ['top', 'right', 'bottom', 'left'];\n  const action = cfg?.action || 'translate';\n  const margin = cfg?.margin || 0;\n  const coordinate = labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n  const {\n    minX: regionMinX,\n    minY: regionMinY,\n    maxX: regionMaxX,\n    maxY: regionMaxY,\n  } = getCoordinateBBox(coordinate, margin);\n\n  each(labels, (label: IGroup) => {\n    const { minX, minY, maxX, maxY, x, y, width, height } = label.getCanvasBBox();\n\n    let finalX = x;\n    let finalY = y;\n    if (direction.indexOf('left') >= 0 && (minX < regionMinX || maxX < regionMinX)) {\n      // 超出左侧\n      finalX = regionMinX;\n    }\n    if (direction.indexOf('top') >= 0 && (minY < regionMinY || maxY < regionMinY)) {\n      // 超出顶部\n      finalY = regionMinY;\n    }\n\n    if (direction.indexOf('right') >= 0) {\n      if (minX > regionMaxX) {\n        // 整体超出右侧\n        finalX = regionMaxX - width;\n      } else if (maxX > regionMaxX) {\n        // 超出右侧\n        finalX = finalX - (maxX - regionMaxX);\n      }\n    }\n\n    if (direction.indexOf('bottom') >= 0) {\n      if (minY > regionMaxY) {\n        // 整体超出底部\n        finalY = regionMaxY - height;\n      } else if (maxY > regionMaxY) {\n        // 超出底部\n        finalY = finalY - (maxY - regionMaxY);\n      }\n    }\n\n    if (finalX !== x || finalY !== y) {\n      const translateX = finalX - x;\n      if (action === 'translate') {\n        translate(label, translateX, finalY - y);\n      } else if (action === 'ellipsis') {\n        const textShapes = label.findAll((shape) => shape.get('type') === 'text');\n        textShapes.forEach((textShape) => {\n          const style = pick(textShape.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);\n          const textBox = textShape.getCanvasBBox();\n          const text = getEllipsisText(textShape.attr('text'), textBox.width - Math.abs(translateX), style);\n          textShape.attr('text', text);\n        });\n      } else {\n        label.hide();\n      }\n    }\n  });\n}\n","import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\n/**\n * @ignore\n * 根据图形元素以及 label 的 bbox 进行调整，如果 label 超出了 shape 的 bbox 则不展示\n */\nexport function limitInShape(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  each(labels, (label, index) => {\n    const labelBBox = label.getCanvasBBox(); // 文本有可能发生旋转\n    const shapeBBox = shapes[index].getBBox();\n    if (\n      labelBBox.minX < shapeBBox.minX ||\n      labelBBox.minY < shapeBBox.minY ||\n      labelBBox.maxX > shapeBBox.maxX ||\n      labelBBox.maxY > shapeBBox.maxY\n    ) {\n      label.remove(true); // 超出则不展示\n    }\n  });\n}\n","import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\nconst MAX_TIMES = 100;\n\n/** @ignore */\ninterface Bitmap {\n  [key: number]: {\n    [key: number]: boolean;\n  };\n}\n\n/** @ignore */\ninterface GreedyCfg {\n  readonly xGap?: number;\n  readonly yGap?: number;\n}\n\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nclass Greedy {\n  public readonly xGap: number;\n  /** optimizing for text overlapping detection: use a min text height as gap */\n  public readonly yGap: number;\n\n  private bitmap: Bitmap = {};\n\n  constructor(cfg: GreedyCfg = {}) {\n    const { xGap = 1, yGap = 8 } = cfg;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  public hasGap(bbox: BBox): boolean {\n    let hasGap = true;\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (let j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  }\n\n  public fillGap(bbox: BBox): void {\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (let i = minX; i <= maxX; i += this.xGap) {\n      for (let j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (let i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (let i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  }\n\n  public destroy(): void {\n    this.bitmap = {};\n  }\n}\n\nfunction spiralFill(label: IShape, greedy: Greedy, maxTimes: number = MAX_TIMES) {\n  const dt = -1;\n  const { x, y } = label.attr();\n  const bbox = label.getCanvasBBox();\n  const maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  let dxdy;\n  let t = -dt;\n  let dx = 0;\n  let dy = 0;\n  const f = (param: number) => {\n    const nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  let canFill = false;\n  let times = 0;\n  const accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f((t += dt));\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if ((!dx && !dy) || accessedCache[`${dx}-${dy}`]) {\n      continue;\n    }\n    label.attr({ x: x + dx, y: y + dy });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[`${dx}-${dy}`] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label: IShape, x: number, y: number, index: number) {\n  const { width, height } = label.getCanvasBBox();\n  const attrs = {\n    x,\n    y,\n    textAlign: 'center',\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    const { x, y } = labelShape.attr();\n    let canFill = false;\n    for (let i = 0; i <= 8; i++) {\n      const bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n\n  greedy.destroy();\n}\n","import { groupBy, keys, map } from '@antv/util';\nimport { IGroup, IShape, BBox } from '../../../../dependents';\nimport Geometry from '../../../base';\nimport Element from '../../../element';\nimport { LabelItem } from '../../interface';\nimport { findLabelTextShape } from '../../util';\n\n/**\n * point-adjust-position layout 的配置类型\n */\nexport interface PointAdjustPositionLayoutCfg {\n  offset?: number;\n}\n\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\nfunction sortLabels(geometry: Geometry, labels: IGroup[]) {\n  const yField = geometry.getXYFields()[1];\n  const result: IGroup[] = [];\n  const sortedLabels = labels.sort((left, right) => left.get('data')[yField] - left.get('data')[yField]);\n\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.shift());\n  }\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.pop());\n  }\n  result.push(...sortedLabels);\n\n  return result;\n}\n\nfunction hasSome(dones: IGroup[], current: IGroup, compare: (left: IGroup, right: IGroup) => boolean): boolean {\n  return dones.some((done) => compare(done, current));\n}\n\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nfunction getOverlapArea(a: BBox, b: BBox, margin = 0) {\n  const xOverlap = Math.max(\n    0,\n    Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin)\n  );\n  const yOverlap = Math.max(\n    0,\n    Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin)\n  );\n\n  return xOverlap * yOverlap;\n}\n\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\nfunction checkShapeOverlap(dones: IGroup[], current: IGroup): boolean {\n  return hasSome(dones, current, (left, right) => {\n    const leftText = findLabelTextShape(left);\n    const rightText = findLabelTextShape(right);\n\n    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n  });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\nexport function pathAdjustPosition(\n  items: LabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox,\n  cfg: PointAdjustPositionLayoutCfg\n): void {\n  if (shapes.length === 0) {\n    return;\n  }\n\n  const element: Element = shapes[0]?.get('element');\n  const geometry: Geometry = element?.geometry;\n  if (!geometry || ['path', 'line', 'area'].indexOf(geometry.type) < 0) {\n    return;\n  }\n  const [xField, yField] = geometry.getXYFields();\n  const groupedLabels = groupBy(labels, (label) => label.get('data')[xField]);\n  const dones: IGroup[] = [];\n  const offset = (cfg && cfg.offset) || items[0]?.offset || 12;\n\n  map(keys(groupedLabels).reverse(), (xValue) => {\n    const sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n    while (sortedCollections.length) {\n      const current = sortedCollections.shift();\n      const textShape = findLabelTextShape(current);\n      if (\n        hasSome(\n          dones,\n          current,\n          (left, right) =>\n            left.get('data')[xField] === right.get('data')[xField] &&\n            left.get('data')[yField] === right.get('data')[yField]\n        )\n      ) {\n        // 重复位置，直接隐藏\n        textShape.set('visible', false);\n        continue;\n      }\n      const upFail = checkShapeOverlap(dones, current);\n      let downFail: boolean = false;\n      if (upFail) {\n        textShape.attr('y', textShape.attr('y') + 2 * offset);\n        downFail = checkShapeOverlap(dones, current);\n      }\n      if (downFail) {\n        textShape.set('visible', false);\n        continue;\n      }\n      dones.push(current);\n    }\n  });\n}\n","import { isObject, each, find, get } from '@antv/util';\n\nimport { BBox, IGroup, IShape } from '../../../../dependents';\nimport { LabelItem } from '../../interface';\n\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { IElement } from '@antv/g-base';\n\n/** label text和line距离 4px */\nconst MARGIN = 4;\n\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n  // adjust y position of labels to avoid overlapping\n  let overlapping = true;\n  const start = plotRange.start;\n  const end = plotRange.end;\n  const startY = Math.min(start.y, end.y);\n  let totalHeight = Math.abs(start.y - end.y);\n  let i;\n\n  let maxY = 0;\n  let minY = Number.MIN_VALUE;\n  const boxes = labels.map((label) => {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      size: lineHeight,\n      targets: [label.y - startY],\n    };\n  });\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach((box) => {\n      const target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      // box.pos = Math.max(0, target - box.size / 2);\n    });\n\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        const previousBox = boxes[i - 1];\n        const box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach((b) => {\n    let posInCompositeBox = startY + lineHeight / 2; // middle of the label\n    b.targets.forEach(() => {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += lineHeight;\n      i++;\n    });\n  });\n\n  const labelsMap = {};\n  for (const labelShape of labelShapes) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  // (x - cx)^2 + (y - cy)^2 = totalR^2\n  labels.forEach((label) => {\n    const rPow2 = label.r * label.r;\n    const dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n    if (rPow2 < dyPow2) {\n      label.x = center.x;\n    } else {\n      const dx = Math.sqrt(rPow2 - dyPow2);\n      if (!isRight) {\n        // left\n        label.x = center.x - dx;\n      } else {\n        // right\n        label.x = center.x + dx;\n      }\n    }\n\n    // adjust labelShape\n    const labelShape = labelsMap[label.id];\n    labelShape.attr('x', label.x);\n    labelShape.attr('y', label.y);\n\n    // because group could not effect text-shape, should set text-shape position manually\n    const textShape = find(labelShape.getChildren(), (ele) => ele.get('type') === 'text') as IElement;\n    // @ts-ignore\n    if (textShape) {\n      textShape.attr('y', label.y);\n      textShape.attr('x', label.x);\n    }\n  });\n}\n\nexport function distribute(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  if (!items.length || !labels.length) {\n    return;\n  }\n  const offset = items[0] ? items[0].offset : 0;\n  const coordinate = labels[0].get('coordinate');\n  const radius = coordinate.getRadius();\n  const center = coordinate.getCenter();\n\n  if (offset > 0) {\n    // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);\n    const lineHeight = 14; // TODO\n    const totalR = radius + offset;\n    const totalHeight = totalR * 2 + lineHeight * 2;\n    const plotRange = {\n      start: coordinate.start,\n      end: coordinate.end,\n    };\n\n    // step 1: separate labels\n    const halves = [\n      [], // left\n      [], // right\n    ];\n    items.forEach((labelItem) => {\n      if (!labelItem) {\n        return;\n      }\n      if (labelItem.textAlign === 'right') {\n        // left\n        halves[0].push(labelItem);\n      } else {\n        // right or center will be put on the right side\n        halves[1].push(labelItem);\n      }\n    });\n\n    halves.forEach((half, index) => {\n      // step 2: reduce labels\n      const maxLabelsCountForOneSide = totalHeight / lineHeight;\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort((a, b) => {\n          // sort by percentage DESC\n          return b['..percent'] - a['..percent'];\n        });\n        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n      }\n\n      // step 3: distribute position (x and y)\n      half.sort((a, b) => {\n        // sort by y ASC\n        return a.y - b.y;\n      });\n\n      antiCollision(labels, half, lineHeight, plotRange, center, index);\n    });\n  }\n\n  // 配置 labelLine\n  each(items, (item) => {\n    if (item && item.labelLine) {\n      const distance = item.offset;\n      const angle = item.angle;\n      // 贴近圆周\n      const startPoint = polarToCartesian(center.x, center.y, radius, angle);\n      const innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n      const itemX = item.x + get(item, 'offsetX', 0);\n      const itemY = item.y + get(item, 'offsetY', 0);\n      const endPoint = {\n        x: itemX - Math.cos(angle) * MARGIN,\n        y: itemY - Math.sin(angle) * MARGIN,\n      };\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n      item.labelLine.path = [\n        `M ${startPoint.x}`,\n        `${startPoint.y} Q${innerPoint.x}`,\n        `${innerPoint.y} ${endPoint.x}`,\n        endPoint.y,\n      ].join(',');\n    }\n  });\n}\n","import { Coordinate } from '@antv/coord';\nimport { BBox, IGroup, IShape, IElement } from '@antv/g-base';\nimport { isObject, each, get, groupBy, isNil, filter } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\n\n/** label text和line距离 4px */\nconst MARGIN = 4;\n\n/**\n * 配置 labelline\n * @param item PolarLabelItem\n */\nfunction drawLabelline(item: any /** PolarLabelItem */, coordinate: Coordinate) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n\n  if (item && item.labelLine) {\n    const { angle, offset: labelOffset } = item;\n    // 贴近圆周\n    const startPoint = polarToCartesian(center.x, center.y, radius, angle);\n    const itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n    const itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n\n    const endPoint = {\n      x: itemX - Math.cos(angle) * MARGIN,\n      y: itemY - Math.sin(angle) * MARGIN,\n    };\n\n    const smoothConnector = item.labelLine.smooth;\n    const path = [];\n    const dx = endPoint.x - center.x;\n    const dy = endPoint.y - center.y;\n    let endAngle = Math.atan(dy / dx);\n    // 第三象限 & 第四象限\n    if (dx < 0) {\n      endAngle += Math.PI;\n    }\n\n    // 默认 smooth, undefined 也为 smooth\n    if (smoothConnector === false) {\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n\n      // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n      let sweepFlag = 0;\n\n      // 第一象限\n      if ((angle < 0 && angle > -Math.PI / 2) || angle > Math.PI * 1.5) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第二象限\n      if (angle >= 0 && angle < Math.PI / 2) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第三象限\n      if (angle >= Math.PI / 2 && angle < Math.PI) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第四象限\n      if (angle < -Math.PI / 2 || (angle >= Math.PI && angle < Math.PI * 1.5)) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      const distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);\n      const breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);\n      // 圆弧的结束点\n      const breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);\n\n      /**\n       * @example\n       * M 100 100 L100 90 A 50 50 0 0 0 150 50\n       * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n       * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n       * 第 5 个参数: 是否顺时针绘制\n       */\n      // 默认小弧\n      const largeArcFlag = 0;\n      // step1: 移动至起点\n      path.push(`M ${startPoint.x} ${startPoint.y}`);\n      // step2: 连接拐点\n      path.push(`L ${breakPoint.x} ${breakPoint.y}`);\n      // step3: 绘制圆弧 至 结束点\n      path.push(`A ${center.x} ${center.y} 0 ${largeArcFlag} ${sweepFlag} ${breakPoint3.x} ${breakPoint3.y}`);\n      // step4: 连接结束点\n      path.push(`L ${endPoint.x} ${endPoint.y}`);\n    } else {\n      const breakPoint = polarToCartesian(\n        center.x,\n        center.y,\n        radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)),\n        angle\n      );\n      // G2 旧的拉线\n      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n      const xSign = startPoint.x < center.x ? 1 : -1;\n      // step1: 连接结束点\n      path.push(`M ${endPoint.x} ${endPoint.y}`);\n      const slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n      const slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n        // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n        path.push(\n          ...[\n            'C',\n            endPoint.x + xSign * 4,\n            endPoint.y,\n            2 * breakPoint.x - startPoint.x,\n            2 * breakPoint.y - startPoint.y,\n            startPoint.x,\n            startPoint.y,\n          ]\n        );\n      }\n      // step3: 连接至起点\n      path.push(`L ${startPoint.x} ${startPoint.y}`);\n    }\n    item.labelLine.path = path.join(' ');\n  }\n}\n\n/**\n * 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签\n */\nexport function pieOuterLabelLayout(\n  originalItems: PolarLabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox\n) {\n  const items = filter(originalItems, (item) => !isNil(item));\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  // note labelHeight 可以控制 label 的行高\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = get(items[0], 'offset', 0);\n\n  if (labelOffset <= 0) {\n    return;\n  }\n\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  const { start, end } = coordinate;\n  // step2: calculate totalHeight\n  const totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());\n  const totalR = totalHeight / 2;\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalR,\n    maxY: center.y + totalR,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx + 1 > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  each(separateLabels, (half: PolarLabelItem[], key: string) => {\n    each(half, (item: PolarLabelItem) => {\n      const isRight = key === RIGHT_HALF_KEY;\n      const labelShape = labelsMap[item.id];\n\n      // because group could not effect content-shape, should set content-shape position manually\n      const content = labelShape.getChildByIndex(0) as IElement;\n\n      // textShape 发生过调整\n      if (content) {\n        const r = radius + labelOffset;\n        // (x - cx)^2 + (y - cy)^2 = totalR^2\n        const dy = item.y - center.y;\n\n        const rPow2 = Math.pow(r, 2);\n        const dyPow2 = Math.pow(dy, 2);\n        const dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;\n        const dx = Math.sqrt(dxPow2);\n\n        const dx_offset = Math.abs(Math.cos(item.angle) * r);\n        if (!isRight) {\n          // left\n          item.x = center.x - Math.max(dx, dx_offset);\n        } else {\n          // right\n          item.x = center.x + Math.max(dx, dx_offset);\n        }\n      }\n\n      // adjust labelShape\n      if (content) {\n        content.attr('y', item.y);\n        content.attr('x', item.x);\n      }\n\n      drawLabelline(item, coordinate);\n    });\n  });\n}\n","import { BBox, IGroup, IShape } from '@antv/g-base';\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem, PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\nimport { Coordinate } from '@antv/coord';\n\n/** 拐点偏移量, 暂不可配置 */\nconst INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nconst LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nconst LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item: PolarLabelItem, coordinate: Coordinate, inRight: boolean) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  const startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y,\n  };\n  const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  const p1 = { x: startPoint.x, y: startPoint.y };\n  const p2 = { x: inflectionPoint.x, y: inflectionPoint.y };\n\n  const endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  let path = '';\n\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    const offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\n    `M ${startPoint.x},${startPoint.y}`,\n    `L ${p1.x},${p1.y}`,\n    `L ${p2.x},${p2.y}`,\n    `L ${inflectionPoint.x},${inflectionPoint.y}`,\n    `L ${endPoint.x},${endPoint.y}`,\n  ].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, { path });\n}\n\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n\n  // step 1: adjust items to spider\n  each(items, (item) => {\n    if (!item) return;\n    const label = get(labelsMap, [item.id]);\n    if (!label) return;\n\n    const inRight = item.x > center.x || (item.x === center.x && item.y > center.y);\n    const offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n\n    const totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n\n  const { start, end } = coordinate;\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  // step2: calculate totalHeight\n  let totalHeight = (radius + labelOffset) * 2 + labelHeight;\n\n  each(separateLabels, (half: PolarLabelItem[]) => {\n    const halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  const startY = labelsContainerRange.minY;\n  const endY = labelsContainerRange.maxY;\n\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, (half, key) => {\n    const inRight = key === RIGHT_HALF_KEY;\n\n    each(half, (item) => {\n      const label: IGroup = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      const labelContent = label.getChildByIndex(0);\n      const box = labelContent.getCanvasBBox();\n      const originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };\n\n      translate(labelContent as any, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}\n"],"names":["GEOMETRY_LABELS_MAP","GEOMETRY_LABELS_LAYOUT_MAP","getGeometryLabel","type","toLowerCase","registerGeometryLabel","ctor","getGeometryLabelLayout","registerGeometryLabelLayout","layoutFn","__extends","IntervalLabel","mappingData","points","labelCfg","index","total","position","point","_super","getLabelOffsetPoint","call","coordinate","this","getCoordinate","dim","isTransposed","dir","getLabelValueDir","_a","isReflect","x","y","geometry","defaultLabelCfg","getDefaultLabelCfg","theme","deepMix","labels","offset","labelPointCfg","top","right","bottom","left","transposed","shapePoints","point0","convert","point2","shape","isArray","nextPoints","get","p0","p1","nextP0","nextP1","Math","min","max","textAlign","textBaseline","GeometryLabel","adjustColor","items","shapes","length","fillColorLight","fillColorDark","forEach","textShape","find","el","shapeBBox","BBox","getBBox","textBBox","getCanvasBBox","overflow","contains","bgColor","attr","fillWhite","isContrastColorWhite","overflowLabels","style","layout","boxes","slice","i","box1","visible","j","box2","intersect","cache","Map","worker","createWorker","layoutCode","hideOverlap","labelItems","region","map","d","idx","getLabelBackgroundInfo","memoKey","JSON","stringify","cb","set","each","labelShape","show","hide","params","post","res","Array","data","console","error","e_1","shouldInShape","getAdjust","every","label","findLabelTextShape","height","width","shouldInShapeSingle","intervalAdjustPosition","element","minX","minY","moveInShape","intervalHideOverlap","xValue","filteredLabels","pages","floor","push","filterLabel","xField","getXYFields","dones","todo","groupedLabels","groupBy","xValues","uniq","addCurrentGroup","curItems","pop","apply","__spreadArray","size","shift","reverse","val","cur","checkShapeOverlap","limitInCanvas","regionMinX","regionMinY","regionMaxX","regionMaxY","maxX","maxY","finalX","finalY","translate","limitInPlot","cfg","direction","action","margin","getCoordinateBBox","indexOf","translateX_1","findAll","pick","textBox","text","getEllipsisText","abs","limitInShape","labelBBox","remove","bitmap","xGap","_b","yGap","Greedy","bbox","hasGap","round","adjustLabelPosition","attrs","fixedOverlap","greedy","maxTimes","dxdy","maxDelta","sqrt","t","dx","dy","f","param","nt","cos","sin","fillGap","canFill","times","accessedCache","concat","spiralFill","destroy","overlap","hasSome","current","compare","some","done","a","b","leftText","rightText","pathAdjustPosition","yField","keys","sortedCollections","result","sortedLabels","sort","sortLabels","downFail","distribute","radius","getRadius","center","getCenter","totalHeight_1","lineHeight_1","plotRange_1","start","end","halves_1","labelItem","half","maxLabelsCountForOneSide","splice","labelShapes","lineHeight","plotRange","isRight","overlapping","startY","totalHeight","Number","MIN_VALUE","targets","box","target","pos","previousBox","posInCompositeBox","labelsMap","labelShapes_1_1","rPow2","r","dyPow2","pow","id","getChildren","ele","antiCollision","item","labelLine","distance","angle","startPoint","polarToCartesian","innerPoint","itemX","itemY","endPoint","isObject","path","join","pieOuterLabelLayout","originalItems","filter","isNil","labels_1_1","labelHeight","labelOffset","RIGHT_HALF_KEY","separateLabels","getHeight","totalR","labelsContainerRange","key","percent","invisible","content","getChildByIndex","dxPow2","dx_offset","smoothConnector","smooth","endAngle","atan","PI","sweepFlag","breakPoint","breakPoint3","xSign","slope1","slope2","E","drawLabelline","pieSpiderLabelLayout","inRight","offsetX","inflectionPoint","totalOffset","halfHeight","endY","labelContent","originalPos","p2"],"sourceRoot":""}