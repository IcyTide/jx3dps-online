{"version":3,"file":"static/js/7653.efe327c2.js","mappings":"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","sources":["../node_modules/@antv/component/src/axis/overlap/auto-ellipsis.ts","../node_modules/@antv/component/src/axis/overlap/auto-hide.ts","../node_modules/@antv/component/src/axis/overlap/auto-rotate.ts","../node_modules/@antv/component/src/crosshair/base.ts","../node_modules/@antv/component/src/crosshair/line.ts","../node_modules/@antv/component/src/crosshair/circle.ts","../node_modules/@antv/component/src/crosshair/css-const.ts","../node_modules/@antv/component/src/crosshair/html-theme.ts","../node_modules/@antv/component/src/crosshair/html.ts","../node_modules/@antv/component/src/grid/base.ts","../node_modules/@antv/component/src/grid/circle.ts","../node_modules/@antv/component/src/grid/line.ts"],"sourcesContent":["import { IGroup } from '@antv/g-base';\nimport { each } from '@antv/util';\nimport { ellipsisLabel } from '../../util/label';\n\nfunction ellipseLabels(isVertical: boolean, labelGroup: IGroup, limitLength: number, position: string): boolean {\n  const children = labelGroup.getChildren();\n  let ellipsisFlag = false;\n  each(children, (label) => {\n    const rst = ellipsisLabel(isVertical, label, limitLength, position);\n    ellipsisFlag = ellipsisFlag || rst;\n  });\n  return ellipsisFlag;\n}\n\nexport function getDefault() {\n  return ellipsisTail;\n}\n\nexport function ellipsisHead(isVertical: boolean, labelGroup: IGroup, limitLength: number): boolean {\n  return ellipseLabels(isVertical, labelGroup, limitLength, 'head');\n}\n\nexport function ellipsisTail(isVertical: boolean, labelGroup: IGroup, limitLength: number): boolean {\n  return ellipseLabels(isVertical, labelGroup, limitLength, 'tail');\n}\n\nexport function ellipsisMiddle(isVertical: boolean, labelGroup: IGroup, limitLength: number): boolean {\n  return ellipseLabels(isVertical, labelGroup, limitLength, 'middle');\n}\n","import { IElement, IGroup } from '@antv/g-base';\nimport { AxisLabelAutoHideCfg } from '../../types';\nimport { getMaxLabelWidth } from '../../util/label';\nimport { getAngleByMatrix } from '../../util/matrix';\nimport { near } from '../../util/util';\n\n// 文本是否旋转\nfunction isRotate(label: IElement) {\n  const matrix = label.attr('matrix');\n  return matrix && matrix[0] !== 1; // 仅在这个场景下判定\n}\n\nfunction getRotateAngle(label: IElement) {\n  const angle = isRotate(label) ? getAngleByMatrix(label.attr('matrix')) : 0;\n  return angle % 360;\n}\n\n// autohide 不再考虑超出限制\n// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {\n//   if (!limitLength) {\n//     // 如果没限制 limitLength 则直接返回 false\n//     return false;\n//   }\n//   const canvasBBox = label.getCanvasBBox();\n//   let isOut = false;\n//   if (isVertical) {\n//     isOut = canvasBBox.width > limitLength;\n//   } else {\n//     isOut = canvasBBox.height > limitLength;\n//   }\n//   return isOut;\n// }\n\n// 是否重叠\nfunction isOverlap(isVertical: boolean, first: IElement, second: IElement, minGap: number) {\n  let overlap = false;\n  const angle = getRotateAngle(first);\n  const distance = isVertical\n    ? Math.abs(second.attr('y') - first.attr('y'))\n    : Math.abs(second.attr('x') - first.attr('x'));\n  const prevBBox = (isVertical\n  ? second.attr('y') > first.attr('y')\n  : second.attr('x') > first.attr('x'))\n    ? first.getBBox()\n    : second.getBBox();\n\n  if (isVertical) {\n    const ratio = Math.abs(Math.cos(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      overlap = prevBBox.width + minGap > distance;\n    } else {\n      overlap = prevBBox.height / ratio + minGap > distance;\n    }\n  } else {\n    const ratio = Math.abs(Math.sin(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      overlap = prevBBox.width + minGap > distance;\n    } else {\n      overlap = prevBBox.height / ratio + minGap > distance;\n    }\n  }\n\n  return overlap;\n}\n\n// 保留第一个或者最后一个\nfunction reserveOne(isVertical: boolean, labelsGroup: IGroup, reversed: boolean, autoHideCfg?: AxisLabelAutoHideCfg) {\n  const minGap = autoHideCfg?.minGap || 0;\n  const labels = labelsGroup\n    .getChildren()\n    .slice() // 复制数组\n    .filter((item) => item.get('visible'));\n  if (!labels.length) {\n    return false;\n  }\n  let hasHide = false;\n  if (reversed) {\n    // 翻转\n    labels.reverse();\n  }\n  const count = labels.length;\n  const first = labels[0];\n  let prev = first;\n  for (let i = 1; i < count; i++) {\n    const label = labels[i];\n    const curBBox = label.getBBox();\n    // 不再考虑超出限制，而仅仅根据是否重叠进行隐藏 isOutLimit(isVertical, label, limitLength) ||\n    const isHide = isOverlap(isVertical, prev, label, minGap);\n    if (isHide) {\n      label.hide();\n      hasHide = true;\n    } else {\n      prev = label;\n    }\n  }\n  return hasHide;\n}\n\n// 均匀抽样隐藏标签，注意这里假设 label/tick 是均匀的\nfunction parityHide(isVertical: boolean, labelsGroup: IGroup, autoHideCfg?: AxisLabelAutoHideCfg) {\n  const minGap = autoHideCfg?.minGap || 0;\n  const labels = labelsGroup.getChildren().slice(); // 复制数组\n  if (labels.length < 2) {\n    // 如果数量小于 2 则直接返回，等于 2 时可能也会重合\n    return false;\n  }\n  let hasHide = false;\n  const first = labels[0];\n  const firstBBox = first.getBBox();\n  const second = labels[1];\n  const count = labels.length;\n  const angle = getRotateAngle(first);\n  const distance = isVertical\n    ? Math.abs(second.attr('y') - first.attr('y'))\n    : Math.abs(second.attr('x') - first.attr('x'));\n  let interval = 0; // 不重叠的坐标文本间距个数\n  if (isVertical) {\n    // 垂直的坐标轴计算垂直方向的间距\n    const ratio = Math.abs(Math.cos(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      const maxWidth = getMaxLabelWidth(labels);\n      interval = (maxWidth + minGap) / distance;\n    } else {\n      interval = (firstBBox.height / ratio + minGap) / distance;\n    }\n  } else {\n    // 水平坐标轴\n    const ratio = Math.abs(Math.sin(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      const maxWidth = getMaxLabelWidth(labels);\n      interval = (maxWidth + minGap) / distance;\n    } else {\n      interval = (firstBBox.height / ratio + minGap) / distance;\n    }\n  }\n  // interval > 1 时需要对 label 进行隐藏\n  if (interval > 1) {\n    interval = Math.ceil(interval);\n    for (let i = 0; i < count; i++) {\n      if (i % interval !== 0) {\n        // 仅保留被整除的 label\n        labels[i].hide();\n        hasHide = true;\n      }\n    }\n  }\n  return hasHide;\n}\n\nexport function getDefault() {\n  return equidistance;\n}\n\n/**\n * 保证首个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveFirst(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength?: number,\n  autoHideCfg?: AxisLabelAutoHideCfg\n): boolean {\n  return reserveOne(isVertical, labelsGroup, false, autoHideCfg);\n}\n\n/**\n * 保证最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveLast(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength?: number,\n  autoHideCfg?: AxisLabelAutoHideCfg\n): boolean {\n  return reserveOne(isVertical, labelsGroup, true, autoHideCfg);\n}\n\n/**\n * 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveBoth(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength?: number,\n  autoHideCfg?: AxisLabelAutoHideCfg\n): boolean {\n  const minGap = autoHideCfg?.minGap || 0;\n  const labels = labelsGroup.getChildren().slice(); // 复制数组\n  if (labels.length <= 2) {\n    // 如果数量小于或等于 2 则直接返回\n    return false;\n  }\n  let hasHide = false;\n  const count = labels.length;\n  const first = labels[0];\n  const last = labels[count - 1];\n  let preLabel = first;\n  // 按照先保存第一个的逻辑循环一遍，最后一个不参与循环\n  for (let i = 1; i < count - 1; i++) {\n    const label = labels[i];\n    const curBBox = label.getBBox();\n    // 废弃 isOutLimit(isVertical, label, limitLength) ||\n    const isHide = isOverlap(isVertical, preLabel, label, minGap);\n    if (isHide) {\n      label.hide();\n      hasHide = true;\n    } else {\n      preLabel = label;\n    }\n  }\n\n  const overlap = isOverlap(isVertical, preLabel, last, minGap);\n  if (overlap) {\n    // 发生冲突，则隐藏前一个保留后一个\n    preLabel.hide();\n    hasHide = true;\n  }\n  return hasHide;\n}\n\n/**\n * 保证 label 均匀显示 和 不出现重叠，主要解决文本层叠的问题，对于 limitLength 不处理\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function equidistance(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength?: number,\n  autoHideCfg?: AxisLabelAutoHideCfg\n): boolean {\n  let hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);\n\n  // 处理  timeCat 类型的 tick，在均匀的基础上，再次检查出现重叠的进行隐藏\n  if (reserveOne(isVertical, labelsGroup, false)) {\n    hasHide = true;\n  }\n\n  return hasHide;\n}\n\n/**\n * 同 equidistance， 首先会保证 labels 均匀显示，然后会保留首尾\n * @param isVertical\n * @param labelsGroup\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function equidistanceWithReverseBoth(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength?: number,\n  autoHideCfg?: AxisLabelAutoHideCfg\n): boolean {\n  const labels = labelsGroup.getChildren().slice(); // 复制数组\n  let hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);\n\n  if (labels.length > 2) {\n    const first = labels[0];\n    const last = labels[labels.length - 1];\n\n    // 如果第一个被隐藏了\n    if (!first.get('visible')) {\n      first.show();\n      if (reserveOne(isVertical, labelsGroup, false, autoHideCfg)) {\n        hasHide = true;\n      }\n    }\n\n    // 如果最后一个被隐藏了\n    if (!last.get('visible')) {\n      last.show();\n      if (reserveOne(isVertical, labelsGroup, true, autoHideCfg)) {\n        hasHide = true;\n      }\n    }\n  }\n\n  return hasHide;\n}\n","import { IElement, IGroup } from '@antv/g-base';\nimport { each, isNumber } from '@antv/util';\nimport { getMaxLabelWidth } from '../../util/label';\nimport { getMatrixByAngle } from '../../util/matrix';\nimport Theme from '../../util/theme';\n\n// 统一设置文本的角度\nfunction setLabelsAngle(labels: IElement[], angle: number) {\n  each(labels, (label) => {\n    const x = label.attr('x');\n    const y = label.attr('y');\n    const matrix = getMatrixByAngle({ x, y }, angle);\n    label.attr('matrix', matrix);\n  });\n}\n\ntype getAngleCallback = (limitLength: number, maxWidth: number) => number;\n\n// 旋转文本\nfunction labelRotate(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength: number,\n  getAngle: getAngleCallback\n): boolean {\n  const labels = labelsGroup.getChildren();\n  if (!labels.length) {\n    return false;\n  }\n  if (!isVertical && labels.length < 2) {\n    // 水平时至少有两个时才旋转\n    return false;\n  }\n\n  const maxWidth = getMaxLabelWidth(labels);\n  let isOverlap = false;\n  if (isVertical) {\n    // limitLength 为 0 或者 null 时不生效\n    isOverlap = !!limitLength && maxWidth > limitLength;\n  } else {\n    // 同 limitLength 无关\n    const tickWidth = Math.abs(labels[1].attr('x') - labels[0].attr('x'));\n    isOverlap = maxWidth > tickWidth;\n  }\n\n  if (isOverlap) {\n    const angle = getAngle(limitLength, maxWidth);\n    setLabelsAngle(labels, angle);\n  }\n  return isOverlap;\n}\n\nexport function getDefault() {\n  return fixedAngle;\n}\n\n/**\n * 固定角度旋转文本\n * @param  {boolean} isVertical  是否垂直方向\n * @param  {IGroup}  labelsGroup 文本的 group\n * @param  {number}  limitLength 限定长度\n * @param  {number}  customRotate 自定义旋转角度\n * @return {boolean}             是否发生了旋转\n */\nexport function fixedAngle(\n  isVertical: boolean,\n  labelsGroup: IGroup,\n  limitLength: number,\n  customRotate?: number\n): boolean {\n  return labelRotate(isVertical, labelsGroup, limitLength, () => {\n    if (isNumber(customRotate)) {\n      return customRotate;\n    }\n    return isVertical ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;\n  });\n}\n\n/**\n * 非固定角度旋转文本\n * @param  {boolean} isVertical  是否垂直方向\n * @param  {IGroup}  labelsGroup 文本的 group\n * @param  {number}  limitLength 限定长度\n * @return {boolean}             是否发生了旋转\n */\nexport function unfixedAngle(isVertical: boolean, labelsGroup: IGroup, limitLength: number): boolean {\n  return labelRotate(isVertical, labelsGroup, limitLength, (length, maxWidth) => {\n    if (!length) {\n      // 如果没有设置 limitLength，则使用固定的角度旋转\n      return isVertical ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;\n    }\n    if (isVertical) {\n      // 垂直时不需要判定 limitLength > maxWidth ，因为此时不会 overlap\n      return -Math.acos(length / maxWidth);\n    } else {\n      let angle = 0;\n      if (length > maxWidth) {\n        // 需要判定，asin 的参数 -1， 1\n        angle = Math.PI / 4;\n      } else {\n        angle = Math.asin(length / maxWidth);\n        if (angle > Math.PI / 4) {\n          // 大于 Math.PI / 4 时没意义\n          angle = Math.PI / 4;\n        }\n      }\n      return angle;\n    }\n  });\n}\n","import { IGroup } from '@antv/g-base';\nimport { isNil } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nimport { CrosshairBaseCfg, Point } from '../types';\nimport { getMatrixByAngle } from '../util/matrix';\nimport Theme from '../util/theme';\nimport { formatPadding } from '../util/util';\n\nabstract class CrosshairBase<T extends CrosshairBaseCfg = CrosshairBaseCfg> extends GroupComponent {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      name: 'crosshair',\n      type: 'base',\n      line: {},\n      text: null,\n      textBackground: {},\n      capture: false, // 不能被拾取\n      defaultCfg: {\n        line: {\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor,\n          },\n        },\n        text: {\n          position: 'start',\n          offset: 10,\n          autoRotate: false,\n          content: null,\n          style: {\n            fill: Theme.textColor,\n            textAlign: 'center',\n            textBaseline: 'middle',\n            fontFamily: Theme.fontFamily,\n          },\n        },\n        textBackground: {\n          padding: 5,\n          style: {\n            stroke: Theme.lineColor,\n          },\n        },\n      },\n    };\n  }\n\n  protected renderInner(group: IGroup) {\n    if (this.get('line')) {\n      this.renderLine(group);\n    }\n    if (this.get('text')) {\n      this.renderText(group);\n      this.renderBackground(group);\n    }\n  }\n\n  /**\n   * @protected\n   * 获取文本点的位置\n   * @return {Point} 文本的位置\n   */\n  protected abstract getTextPoint(): Point;\n\n  protected abstract getRotateAngle(): number;\n\n  protected renderText(group: IGroup) {\n    const text = this.get('text');\n    const { style, autoRotate, content } = text;\n    if (!isNil(content)) {\n      const textPoint = this.getTextPoint();\n      let matrix = null;\n      if (autoRotate) {\n        const angle = this.getRotateAngle();\n        matrix = getMatrixByAngle(textPoint, angle);\n      }\n      this.addShape(group, {\n        type: 'text',\n        name: 'crosshair-text',\n        id: this.getElementId('text'),\n        attrs: {\n          ...textPoint,\n          text: content,\n          matrix,\n          ...style,\n        },\n      });\n    }\n  }\n\n  protected abstract getLinePath(): any[];\n\n  protected renderLine(group: IGroup) {\n    const path = this.getLinePath();\n    const line = this.get('line');\n    const style = line.style;\n    this.addShape(group, {\n      type: 'path',\n      name: 'crosshair-line',\n      id: this.getElementId('line'),\n      attrs: {\n        path,\n        ...style,\n      },\n    });\n  }\n\n  // 绘制文本的背景\n  private renderBackground(group: IGroup) {\n    const textId = this.getElementId('text');\n    const textShape = group.findById(textId); // 查找文本\n    const textBackground = this.get('textBackground');\n\n    if (textBackground && textShape) {\n      const textBBox = textShape.getBBox();\n      const padding = formatPadding(textBackground.padding); // 用户传入的 padding 格式不定\n      const style = textBackground.style;\n      const backgroundShape = this.addShape(group, {\n        type: 'rect',\n        name: 'crosshair-text-background',\n        id: this.getElementId('text-background'),\n        attrs: {\n          x: textBBox.x - padding[3],\n          y: textBBox.y - padding[0],\n          width: textBBox.width + padding[1] + padding[3],\n          height: textBBox.height + padding[0] + padding[2],\n          matrix: textShape.attr('matrix'),\n          ...style,\n        },\n      });\n      backgroundShape.toBack();\n    }\n  }\n}\n\nexport default CrosshairBase;\n","import { ILocation } from '../interfaces';\nimport { LineCrosshairCfg, Point, RegionLocationCfg } from '../types';\nimport { getTextPoint } from '../util/util';\nimport CrosshairBase from './base';\n\nclass LineCrosshair extends CrosshairBase<LineCrosshairCfg> implements ILocation<RegionLocationCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'line',\n      locationType: 'region',\n      start: null,\n      end: null,\n    };\n  }\n\n  // 直线的文本需要同直线垂直\n  protected getRotateAngle(): number {\n    const { start, end } = this.getLocation();\n    const { position } = this.get('text');\n    const angle = Math.atan2(end.y - start.y, end.x - start.x);\n    const tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;\n    return tangentAngle;\n  }\n\n  protected getTextPoint() {\n    const { start, end } = this.getLocation();\n    const { position, offset } = this.get('text');\n    return getTextPoint(start, end, position, offset);\n  }\n\n  protected getLinePath(): any[] {\n    const { start, end } = this.getLocation();\n    return [\n      ['M', start.x, start.y],\n      ['L', end.x, end.y],\n    ];\n  }\n}\n\nexport default LineCrosshair;\n","import { ILocation } from '../interfaces';\nimport { CircleCrosshairCfg, CircleLocationCfg, Point } from '../types';\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\n\nclass LineCrosshair extends CrosshairBase<CircleCrosshairCfg> implements ILocation<CircleLocationCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: (Math.PI * 3) / 2,\n    };\n  }\n\n  protected getRotateAngle(): number {\n    const { startAngle, endAngle } = this.getLocation();\n    const { position } = this.get('text');\n    const tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  }\n\n  protected getTextPoint(): Point {\n    const text = this.get('text');\n    const { position, offset } = text;\n    const { center, radius, startAngle, endAngle } = this.getLocation();\n    const angle = position === 'start' ? startAngle : endAngle;\n    const tangentAngle = this.getRotateAngle() - Math.PI;\n    const point = getCirclePoint(center, radius, angle);\n    // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n    const offsetX = Math.cos(tangentAngle) * offset;\n    const offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY,\n    };\n  }\n\n  protected getLinePath(): any[] {\n    const { center, radius, startAngle, endAngle } = this.getLocation();\n    let path = null;\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      const { x, y } = center;\n      path = [\n        ['M', x, y - radius],\n        ['A', radius, radius, 0, 1, 1, x, y + radius],\n        ['A', radius, radius, 0, 1, 1, x, y - radius],\n        ['Z'],\n      ];\n    } else {\n      const startPoint = getCirclePoint(center, radius, startAngle);\n      const endPoint = getCirclePoint(center, radius, endAngle);\n      const large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      const sweep = startAngle > endAngle ? 0 : 1;\n      path = [\n        ['M', startPoint.x, startPoint.y],\n        ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y],\n      ];\n    }\n    return path;\n  }\n}\n\nexport default LineCrosshair;\n","export const CONTAINER_CLASS = 'g2-crosshair';\nexport const CROSSHAIR_LINE = `${CONTAINER_CLASS}-line`;\nexport const CROSSHAIR_TEXT = `${CONTAINER_CLASS}-text`;\n","import Theme from '../util/theme';\n\n// tooltip 相关 dom 的 css 类名\nimport * as CssConst from './css-const';\n\nexport default {\n  // css style for tooltip\n  [`${CssConst.CONTAINER_CLASS}`]: {\n    position: 'relative'\n  },\n  [`${CssConst.CROSSHAIR_LINE}`]: {\n    position: 'absolute',\n    backgroundColor: 'rgba(0, 0, 0, 0.25)',\n  },\n  [`${CssConst.CROSSHAIR_TEXT}`]: {\n    position: 'absolute',\n    color: Theme.textColor,\n    fontFamily: Theme.fontFamily,\n  }\n};","import { createDom, modifyCSS } from '@antv/dom-util';\nimport { substitute, hasKey } from '@antv/util';\nimport { toPx, getTextPoint } from '../util/util';\nimport HtmlComponent from '../abstract/html-component';\nimport * as CssConst from './css-const';\nimport HtmlTheme from './html-theme';\nimport {HtmlCrossHairCfg} from '../types';\nclass HtmlCrosshair<T extends HtmlCrossHairCfg = HtmlCrossHairCfg> extends HtmlComponent {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      name: 'crosshair',\n      type: 'html',\n      locationType: 'region',\n      start: {x: 0, y: 0}, // 防止初始化报错\n      end: {x: 0, y: 0}, // 防止初始化报错\n      capture: false,\n      text: null,\n      containerTpl: `<div class=\"${CssConst.CONTAINER_CLASS}\"></div>`,\n      crosshairTpl: `<div class=\"${CssConst.CROSSHAIR_LINE}\"></div>`,\n      textTpl: `<span class=\"${CssConst.CROSSHAIR_TEXT}\">{content}</span>`,\n      domStyles: null,\n      containerClassName: CssConst.CONTAINER_CLASS,\n      defaultStyles: HtmlTheme,\n      defaultCfg: {\n        text: {\n          position: 'start',\n          content: null,\n          align: 'center',\n          offset: 10\n        }\n      },\n    };\n  }\n\n  render() {\n    this.resetText();\n    this.resetPosition();\n  }\n\n  // 绘制 crosshair\n  private initCrossHair() {\n    const container = this.getContainer();\n    const crosshairTpl = this.get('crosshairTpl');\n    const crosshairEl = createDom(crosshairTpl);\n    container.appendChild(crosshairEl);\n    this.applyStyle(CssConst.CROSSHAIR_LINE, crosshairEl);\n    this.set('crosshairEl', crosshairEl);\n  }\n\n  // 获取文本的位置\n  private getTextPoint() {\n    const { start, end } = this.getLocation();\n    const { position, offset } = this.get('text');\n    return getTextPoint(start, end, position, offset);\n  }\n\n  // 设置 text\n  private resetText() {\n    const text = this.get('text');\n    let textEl = this.get('textEl') as HTMLElement;\n    if (text) {\n      const {content} = text;\n      if (!textEl) {\n        const container = this.getContainer();\n        const textTpl = substitute(this.get('textTpl'), text);\n        textEl = createDom(textTpl);\n        container.appendChild(textEl);\n        this.applyStyle(CssConst.CROSSHAIR_TEXT, textEl);\n        this.set('textEl', textEl);\n      }\n      textEl.innerHTML = content;\n    } else if (textEl) {\n      textEl.remove();\n    }\n  }\n  // 是否垂直\n  private isVertical(start, end) {\n    return start.x === end.x;\n  }\n  // 重新调整位置\n  protected resetPosition() {\n    let crosshairEl = this.get('crosshairEl');\n    if (!crosshairEl) {\n      this.initCrossHair();\n      crosshairEl = this.get('crosshairEl');\n    }\n    const start = this.get('start');\n    const end = this.get('end');\n    const minX = Math.min(start.x, end.x);\n    const minY = Math.min(start.y, end.y);\n    if (this.isVertical(start, end)) {\n      modifyCSS(crosshairEl, {\n        width: '1px',\n        height: toPx(Math.abs(end.y - start.y))\n      });\n    } else {\n      modifyCSS(crosshairEl, {\n        height: '1px',\n        width: toPx(Math.abs(end.x - start.x))\n      });\n    }\n    modifyCSS(crosshairEl, {\n      top: toPx(minY),\n      left: toPx(minX)\n    });\n    this.alignText();\n  }\n\n  private alignText() {\n    // 重新设置 text 位置\n    const textEl = this.get('textEl');\n    if (textEl) {\n      const { align } = this.get('text');\n      const clientWidth = textEl.clientWidth;\n      const point = this.getTextPoint();\n      switch(align) {\n        case 'center': \n          point.x = point.x - clientWidth / 2;\n          break;\n        case 'right':\n          point.x = point.x - clientWidth;\n        case 'left':\n          break;\n      }\n      modifyCSS(textEl, {\n        top: toPx(point.y),\n        left: toPx(point.x)\n      });\n    }\n  }\n\n  protected updateInner(cfg: Partial<T>) {\n    if (hasKey(cfg, 'text')) {\n      this.resetText();\n    }\n    super.updateInner(cfg);\n  }\n}\n\nexport default HtmlCrosshair;","import { IGroup } from '@antv/g-base';\nimport { each, isString, mix, isFunction } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nimport { GridBaseCfg, GroupComponentCfg, Point } from '../types';\nimport Theme from '../util/theme';\n\nabstract class GridBase<T extends GroupComponentCfg = GridBaseCfg> extends GroupComponent<T> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      name: 'grid',\n      line: {},\n      alternateColor: null,\n      capture: false,\n      items: [],\n      closed: false,\n      defaultCfg: {\n        line: {\n          type: 'line', // 对于 line 类型的 grid 有 line, smooth 两种，cirle 类型的 grid 有 line 和 circle\n          style: {\n            lineWidth: 1,\n            stroke: Theme.lineColor,\n          },\n        },\n      },\n    };\n  }\n\n  /**\n   * 获取栅格线的类型\n   * @return {string} 栅格线类型\n   */\n  protected getLineType(): string {\n    const line = this.get('line') || this.get('defaultCfg').line;\n    return line.type;\n  }\n\n  protected renderInner(group: IGroup) {\n    this.drawGrid(group);\n  }\n\n  /**\n   * 获取栅格线的路径\n   * @param  {Point[]} points   栅格线的点集合\n   * @param  {boolean} reversed 顺序是否相反\n   * @return {any[]}            路径\n   */\n  protected abstract getGridPath(points: Point[], reversed?: boolean): any[];\n\n  protected getAlternatePath(prePoints: Point[], points: Point[]) {\n    let regionPath = this.getGridPath(prePoints);\n    const reversePoints = points.slice(0).reverse();\n    const nextPath = this.getGridPath(reversePoints, true);\n    const closed = this.get('closed');\n    if (closed) {\n      regionPath = regionPath.concat(nextPath);\n    } else {\n      nextPath[0][0] = 'L'; // 更新第一个节点\n      regionPath = regionPath.concat(nextPath);\n      regionPath.push(['Z']);\n    }\n    return regionPath;\n  }\n  // 获取路径的配置项\n  private getPathStyle() {\n    return this.get('line').style;\n  }\n\n  // 绘制栅格\n  private drawGrid(group: IGroup) {\n    const line = this.get('line');\n    const items = this.get('items');\n    const alternateColor = this.get('alternateColor');\n    let preItem = null;\n    each(items, (item, index) => {\n      const id = item.id || index;\n      // 绘制栅格线\n      if (line) {\n        let style = this.getPathStyle();\n        style = isFunction(style) ? style(item, index, items) : style;\n\n        const lineId = this.getElementId(`line-${id}`);\n        const gridPath = this.getGridPath(item.points);\n        this.addShape(group, {\n          type: 'path',\n          name: 'grid-line',\n          id: lineId,\n          attrs: mix(\n            {\n              path: gridPath,\n            },\n            style\n          ),\n        });\n      }\n      // 如果存在 alternateColor 则绘制矩形\n      // 从第二个栅格线开始绘制\n      if (alternateColor && index > 0) {\n        const regionId = this.getElementId(`region-${id}`);\n        const isEven = index % 2 === 0;\n        if (isString(alternateColor)) {\n          // 如果颜色是单值，则是仅绘制偶数时的区域\n          if (isEven) {\n            this.drawAlternateRegion(regionId, group, preItem.points, item.points, alternateColor);\n          }\n        } else {\n          const color = isEven ? alternateColor[1] : alternateColor[0];\n          this.drawAlternateRegion(regionId, group, preItem.points, item.points, color);\n        }\n      }\n      preItem = item;\n    });\n  }\n\n  // 绘制栅格线间的间隔\n  private drawAlternateRegion(id: string, group: IGroup, prePoints: Point[], points: Point[], color: string) {\n    const regionPath = this.getAlternatePath(prePoints, points);\n    this.addShape(group, {\n      type: 'path',\n      id,\n      name: 'grid-region',\n      attrs: {\n        path: regionPath,\n        fill: color,\n      },\n    });\n  }\n}\n\nexport default GridBase;\n","import { each } from '@antv/util';\nimport { CircleGridCfg, Point } from '../types';\nimport GridBase from './base';\n\nfunction distance(x1, y1, x2, y2) {\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nclass Circle extends GridBase<CircleGridCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'circle',\n      /**\n       * 中心点\n       * @type {object}\n       */\n      center: null,\n      /**\n       * 栅格线是否封闭\n       * @type {true}\n       */\n      closed: true,\n    };\n  }\n\n  protected getGridPath(points: Point[], reversed: boolean) {\n    const lineType = this.getLineType();\n    const closed = this.get('closed');\n    const path = [];\n    if (points.length) {\n      // 防止出错\n      if (lineType === 'circle') {\n        const center = this.get('center');\n        const firstPoint = points[0];\n        const radius = distance(center.x, center.y, firstPoint.x, firstPoint.y);\n        const sweepFlag = reversed ? 0 : 1; // 顺时针还是逆时针\n        if (closed) {\n          // 封闭时，绘制整个圆\n          path.push(['M', center.x, center.y - radius]);\n          path.push(['A', radius, radius, 0, 0, sweepFlag, center.x, center.y + radius]);\n          path.push(['A', radius, radius, 0, 0, sweepFlag, center.x, center.y - radius]);\n          path.push(['Z']);\n        } else {\n          each(points, (point, index) => {\n            if (index === 0) {\n              path.push(['M', point.x, point.y]);\n            } else {\n              path.push(['A', radius, radius, 0, 0, sweepFlag, point.x, point.y]);\n            }\n          });\n        }\n      } else {\n        each(points, (point, index) => {\n          if (index === 0) {\n            path.push(['M', point.x, point.y]);\n          } else {\n            path.push(['L', point.x, point.y]);\n          }\n        });\n        if (closed) {\n          path.push(['Z']);\n        }\n      }\n    }\n    return path;\n  }\n}\n\nexport default Circle;\n","import { each } from '@antv/util';\nimport { Point } from '../types';\nimport GridBase from './base';\n\nclass Line extends GridBase {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'line',\n    };\n  }\n\n  protected getGridPath(points: Point[]): any[] {\n    const path = [];\n    each(points, (point, index) => {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  }\n}\n\nexport default Line;\n"],"names":["ellipseLabels","isVertical","labelGroup","limitLength","position","children","getChildren","ellipsisFlag","each","label","rst","ellipsisLabel","getDefault","ellipsisTail","ellipsisHead","ellipsisMiddle","getRotateAngle","angle","matrix","attr","isRotate","getAngleByMatrix","isOverlap","first","second","minGap","overlap","distance","Math","abs","prevBBox","getBBox","ratio","cos","near","PI","width","height","sin","reserveOne","labelsGroup","reversed","autoHideCfg","labels","slice","filter","item","get","length","hasHide","reverse","count","prev","i","hide","parityHide","firstBBox","interval","getMaxLabelWidth","ceil","equidistance","reserveFirst","reserveLast","reserveBoth","last","preLabel","equidistanceWithReverseBoth","show","labelRotate","getAngle","maxWidth","x","y","getMatrixByAngle","setLabelsAngle","fixedAngle","customRotate","isNumber","Theme","unfixedAngle","acos","asin","__extends","CrosshairBase","cfg","_super","getDefaultCfg","call","name","type","line","text","textBackground","capture","defaultCfg","style","lineWidth","stroke","offset","autoRotate","content","fill","textAlign","textBaseline","fontFamily","padding","group","this","renderLine","renderText","renderBackground","isNil","textPoint","getTextPoint","addShape","id","getElementId","attrs","path","getLinePath","textId","textShape","findById","textBBox","formatPadding","toBack","GroupComponent","LineCrosshair","locationType","start","end","getLocation","atan2","center","radius","startAngle","endAngle","tangentAngle","point","getCirclePoint","offsetX","offsetY","startPoint","endPoint","large","sweep","CONTAINER_CLASS","CROSSHAIR_LINE","CROSSHAIR_TEXT","_a","CssConst","backgroundColor","color","HtmlCrosshair","containerTpl","crosshairTpl","textTpl","domStyles","containerClassName","defaultStyles","HtmlTheme","align","resetText","resetPosition","container","getContainer","crosshairEl","createDom","appendChild","applyStyle","set","textEl","substitute","innerHTML","remove","initCrossHair","minX","min","minY","modifyCSS","toPx","top","left","alignText","clientWidth","hasKey","updateInner","HtmlComponent","GridBase","alternateColor","items","closed","drawGrid","prePoints","points","regionPath","getGridPath","reversePoints","nextPath","concat","push","preItem","index","_this","getPathStyle","isFunction","lineId","gridPath","mix","regionId","isEven","isString","drawAlternateRegion","getAlternatePath","Circle","lineType","getLineType","firstPoint","radius_1","x1","y1","x2","y2","dx","dy","sqrt","sweepFlag_1","Line"],"sourceRoot":""}